local ffi = require("ffi")
ffi.cdef([[typedef enum VkDynamicState{VK_DYNAMIC_STATE_VIEWPORT=0,VK_DYNAMIC_STATE_SCISSOR=1,VK_DYNAMIC_STATE_LINE_WIDTH=2,VK_DYNAMIC_STATE_DEPTH_BIAS=3,VK_DYNAMIC_STATE_BLEND_CONSTANTS=4,VK_DYNAMIC_STATE_DEPTH_BOUNDS=5,VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK=6,VK_DYNAMIC_STATE_STENCIL_WRITE_MASK=7,VK_DYNAMIC_STATE_STENCIL_REFERENCE=8,VK_DYNAMIC_STATE_BEGIN_RANGE=0,VK_DYNAMIC_STATE_END_RANGE=8,VK_DYNAMIC_STATE_RANGE_SIZE=9,VK_DYNAMIC_STATE_MAX_ENUM=2147483647};
typedef enum VkImageLayout{VK_IMAGE_LAYOUT_UNDEFINED=0,VK_IMAGE_LAYOUT_GENERAL=1,VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL=2,VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL=3,VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL=4,VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL=5,VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL=6,VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL=7,VK_IMAGE_LAYOUT_PREINITIALIZED=8,VK_IMAGE_LAYOUT_PRESENT_SRC_KHR=1000001002,VK_IMAGE_LAYOUT_BEGIN_RANGE=0,VK_IMAGE_LAYOUT_END_RANGE=8,VK_IMAGE_LAYOUT_RANGE_SIZE=9,VK_IMAGE_LAYOUT_MAX_ENUM=2147483647};
typedef enum VkSamplerMipmapMode{VK_SAMPLER_MIPMAP_MODE_NEAREST=0,VK_SAMPLER_MIPMAP_MODE_LINEAR=1,VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE=0,VK_SAMPLER_MIPMAP_MODE_END_RANGE=1,VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE=2,VK_SAMPLER_MIPMAP_MODE_MAX_ENUM=2147483647};
typedef enum VkIndexType{VK_INDEX_TYPE_UINT16=0,VK_INDEX_TYPE_UINT32=1,VK_INDEX_TYPE_BEGIN_RANGE=0,VK_INDEX_TYPE_END_RANGE=1,VK_INDEX_TYPE_RANGE_SIZE=2,VK_INDEX_TYPE_MAX_ENUM=2147483647};
typedef enum VkCullModeFlagBits{VK_CULL_MODE_NONE=0,VK_CULL_MODE_FRONT_BIT=1,VK_CULL_MODE_BACK_BIT=2,VK_CULL_MODE_FRONT_AND_BACK=3,VK_CULL_MODE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkPipelineStageFlagBits{VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT=1,VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT=2,VK_PIPELINE_STAGE_VERTEX_INPUT_BIT=4,VK_PIPELINE_STAGE_VERTEX_SHADER_BIT=8,VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT=16,VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT=32,VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT=64,VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT=128,VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT=256,VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT=512,VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT=1024,VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT=2048,VK_PIPELINE_STAGE_TRANSFER_BIT=4096,VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT=8192,VK_PIPELINE_STAGE_HOST_BIT=16384,VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT=32768,VK_PIPELINE_STAGE_ALL_COMMANDS_BIT=65536,VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkImageUsageFlagBits{VK_IMAGE_USAGE_TRANSFER_SRC_BIT=1,VK_IMAGE_USAGE_TRANSFER_DST_BIT=2,VK_IMAGE_USAGE_SAMPLED_BIT=4,VK_IMAGE_USAGE_STORAGE_BIT=8,VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT=16,VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT=32,VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT=64,VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT=128,VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkCommandPoolCreateFlagBits{VK_COMMAND_POOL_CREATE_TRANSIENT_BIT=1,VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT=2,VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkDependencyFlagBits{VK_DEPENDENCY_BY_REGION_BIT=1,VK_DEPENDENCY_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkSystemAllocationScope{VK_SYSTEM_ALLOCATION_SCOPE_COMMAND=0,VK_SYSTEM_ALLOCATION_SCOPE_OBJECT=1,VK_SYSTEM_ALLOCATION_SCOPE_CACHE=2,VK_SYSTEM_ALLOCATION_SCOPE_DEVICE=3,VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE=4,VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE=0,VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE=4,VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE=5,VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM=2147483647};
typedef enum VkFilter{VK_FILTER_NEAREST=0,VK_FILTER_LINEAR=1,VK_FILTER_CUBIC_IMG=1000015000,VK_FILTER_BEGIN_RANGE=0,VK_FILTER_END_RANGE=1,VK_FILTER_RANGE_SIZE=2,VK_FILTER_MAX_ENUM=2147483647};
typedef enum VkBufferUsageFlagBits{VK_BUFFER_USAGE_TRANSFER_SRC_BIT=1,VK_BUFFER_USAGE_TRANSFER_DST_BIT=2,VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT=4,VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT=8,VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT=16,VK_BUFFER_USAGE_STORAGE_BUFFER_BIT=32,VK_BUFFER_USAGE_INDEX_BUFFER_BIT=64,VK_BUFFER_USAGE_VERTEX_BUFFER_BIT=128,VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT=256,VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkDisplayPlaneAlphaFlagBitsKHR{VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR=1,VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR=2,VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR=4,VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR=8,VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR=2147483647};
typedef enum VkPipelineCreateFlagBits{VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT=1,VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT=2,VK_PIPELINE_CREATE_DERIVATIVE_BIT=4,VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkDebugReportObjectTypeEXT{VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT=0,VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT=1,VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT=2,VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT=3,VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT=4,VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT=5,VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT=6,VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT=7,VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT=8,VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT=9,VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT=10,VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT=11,VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT=12,VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT=13,VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT=14,VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT=15,VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT=16,VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT=17,VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT=18,VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT=19,VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT=20,VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT=21,VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT=22,VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT=23,VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT=24,VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT=25,VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT=26,VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT=27,VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT=28,VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT=0,VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT=28,VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT=29,VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT=2147483647};
typedef enum VkImageViewType{VK_IMAGE_VIEW_TYPE_1D=0,VK_IMAGE_VIEW_TYPE_2D=1,VK_IMAGE_VIEW_TYPE_3D=2,VK_IMAGE_VIEW_TYPE_CUBE=3,VK_IMAGE_VIEW_TYPE_1D_ARRAY=4,VK_IMAGE_VIEW_TYPE_2D_ARRAY=5,VK_IMAGE_VIEW_TYPE_CUBE_ARRAY=6,VK_IMAGE_VIEW_TYPE_BEGIN_RANGE=0,VK_IMAGE_VIEW_TYPE_END_RANGE=6,VK_IMAGE_VIEW_TYPE_RANGE_SIZE=7,VK_IMAGE_VIEW_TYPE_MAX_ENUM=2147483647};
typedef enum VkQueryControlFlagBits{VK_QUERY_CONTROL_PRECISE_BIT=1,VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkAttachmentDescriptionFlagBits{VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT=1,VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkPipelineCacheHeaderVersion{VK_PIPELINE_CACHE_HEADER_VERSION_ONE=1,VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE=1,VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE=1,VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE=1,VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM=2147483647};
typedef enum VkDebugReportFlagBitsEXT{VK_DEBUG_REPORT_INFORMATION_BIT_EXT=1,VK_DEBUG_REPORT_WARNING_BIT_EXT=2,VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT=4,VK_DEBUG_REPORT_ERROR_BIT_EXT=8,VK_DEBUG_REPORT_DEBUG_BIT_EXT=16,VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT=2147483647};
typedef enum VkPrimitiveTopology{VK_PRIMITIVE_TOPOLOGY_POINT_LIST=0,VK_PRIMITIVE_TOPOLOGY_LINE_LIST=1,VK_PRIMITIVE_TOPOLOGY_LINE_STRIP=2,VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST=3,VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP=4,VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN=5,VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY=6,VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY=7,VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY=8,VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY=9,VK_PRIMITIVE_TOPOLOGY_PATCH_LIST=10,VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE=0,VK_PRIMITIVE_TOPOLOGY_END_RANGE=10,VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE=11,VK_PRIMITIVE_TOPOLOGY_MAX_ENUM=2147483647};
typedef enum VkSparseMemoryBindFlagBits{VK_SPARSE_MEMORY_BIND_METADATA_BIT=1,VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkSurfaceTransformFlagBitsKHR{VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR=1,VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR=2,VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR=4,VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR=8,VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR=16,VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR=32,VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR=64,VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR=128,VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR=256,VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR=2147483647};
typedef enum VkCompareOp{VK_COMPARE_OP_NEVER=0,VK_COMPARE_OP_LESS=1,VK_COMPARE_OP_EQUAL=2,VK_COMPARE_OP_LESS_OR_EQUAL=3,VK_COMPARE_OP_GREATER=4,VK_COMPARE_OP_NOT_EQUAL=5,VK_COMPARE_OP_GREATER_OR_EQUAL=6,VK_COMPARE_OP_ALWAYS=7,VK_COMPARE_OP_BEGIN_RANGE=0,VK_COMPARE_OP_END_RANGE=7,VK_COMPARE_OP_RANGE_SIZE=8,VK_COMPARE_OP_MAX_ENUM=2147483647};
typedef enum VkShaderStageFlagBits{VK_SHADER_STAGE_VERTEX_BIT=1,VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT=2,VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT=4,VK_SHADER_STAGE_GEOMETRY_BIT=8,VK_SHADER_STAGE_FRAGMENT_BIT=16,VK_SHADER_STAGE_COMPUTE_BIT=32,VK_SHADER_STAGE_ALL_GRAPHICS=31,VK_SHADER_STAGE_ALL=2147483647,VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkResult{VK_SUCCESS=0,VK_NOT_READY=1,VK_TIMEOUT=2,VK_EVENT_SET=3,VK_EVENT_RESET=4,VK_INCOMPLETE=5,VK_ERROR_OUT_OF_HOST_MEMORY=-1,VK_ERROR_OUT_OF_DEVICE_MEMORY=-2,VK_ERROR_INITIALIZATION_FAILED=-3,VK_ERROR_DEVICE_LOST=-4,VK_ERROR_MEMORY_MAP_FAILED=-5,VK_ERROR_LAYER_NOT_PRESENT=-6,VK_ERROR_EXTENSION_NOT_PRESENT=-7,VK_ERROR_FEATURE_NOT_PRESENT=-8,VK_ERROR_INCOMPATIBLE_DRIVER=-9,VK_ERROR_TOO_MANY_OBJECTS=-10,VK_ERROR_FORMAT_NOT_SUPPORTED=-11,VK_ERROR_FRAGMENTED_POOL=-12,VK_ERROR_SURFACE_LOST_KHR=-1000000000,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR=-1000000001,VK_SUBOPTIMAL_KHR=1000001003,VK_ERROR_OUT_OF_DATE_KHR=-1000001004,VK_ERROR_INCOMPATIBLE_DISPLAY_KHR=-1000003001,VK_ERROR_VALIDATION_FAILED_EXT=-1000011001,VK_ERROR_INVALID_SHADER_NV=-1000012000,VK_RESULT_BEGIN_RANGE=-12,VK_RESULT_END_RANGE=5,VK_RESULT_RANGE_SIZE=18,VK_RESULT_MAX_ENUM=2147483647};
typedef enum VkFenceCreateFlagBits{VK_FENCE_CREATE_SIGNALED_BIT=1,VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkImageCreateFlagBits{VK_IMAGE_CREATE_SPARSE_BINDING_BIT=1,VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT=2,VK_IMAGE_CREATE_SPARSE_ALIASED_BIT=4,VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT=8,VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT=16,VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkSampleCountFlagBits{VK_SAMPLE_COUNT_1_BIT=1,VK_SAMPLE_COUNT_2_BIT=2,VK_SAMPLE_COUNT_4_BIT=4,VK_SAMPLE_COUNT_8_BIT=8,VK_SAMPLE_COUNT_16_BIT=16,VK_SAMPLE_COUNT_32_BIT=32,VK_SAMPLE_COUNT_64_BIT=64,VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkQueryResultFlagBits{VK_QUERY_RESULT_64_BIT=1,VK_QUERY_RESULT_WAIT_BIT=2,VK_QUERY_RESULT_WITH_AVAILABILITY_BIT=4,VK_QUERY_RESULT_PARTIAL_BIT=8,VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkPresentModeKHR{VK_PRESENT_MODE_IMMEDIATE_KHR=0,VK_PRESENT_MODE_MAILBOX_KHR=1,VK_PRESENT_MODE_FIFO_KHR=2,VK_PRESENT_MODE_FIFO_RELAXED_KHR=3,VK_PRESENT_MODE_BEGIN_RANGE_KHR=0,VK_PRESENT_MODE_END_RANGE_KHR=3,VK_PRESENT_MODE_RANGE_SIZE_KHR=4,VK_PRESENT_MODE_MAX_ENUM_KHR=2147483647};
typedef enum VkAccessFlagBits{VK_ACCESS_INDIRECT_COMMAND_READ_BIT=1,VK_ACCESS_INDEX_READ_BIT=2,VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT=4,VK_ACCESS_UNIFORM_READ_BIT=8,VK_ACCESS_INPUT_ATTACHMENT_READ_BIT=16,VK_ACCESS_SHADER_READ_BIT=32,VK_ACCESS_SHADER_WRITE_BIT=64,VK_ACCESS_COLOR_ATTACHMENT_READ_BIT=128,VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT=256,VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT=512,VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT=1024,VK_ACCESS_TRANSFER_READ_BIT=2048,VK_ACCESS_TRANSFER_WRITE_BIT=4096,VK_ACCESS_HOST_READ_BIT=8192,VK_ACCESS_HOST_WRITE_BIT=16384,VK_ACCESS_MEMORY_READ_BIT=32768,VK_ACCESS_MEMORY_WRITE_BIT=65536,VK_ACCESS_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkExternalMemoryFeatureFlagBitsNV{VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV=1,VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV=2,VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV=4,VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV=2147483647};
typedef enum VkFormatFeatureFlagBits{VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT=1,VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT=2,VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT=4,VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT=8,VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT=16,VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT=32,VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT=64,VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT=128,VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT=256,VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT=512,VK_FORMAT_FEATURE_BLIT_SRC_BIT=1024,VK_FORMAT_FEATURE_BLIT_DST_BIT=2048,VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT=4096,VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG=8192,VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkCommandPoolResetFlagBits{VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT=1,VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkMemoryHeapFlagBits{VK_MEMORY_HEAP_DEVICE_LOCAL_BIT=1,VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkStructureType{VK_STRUCTURE_TYPE_APPLICATION_INFO=0,VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO=1,VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO=2,VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO=3,VK_STRUCTURE_TYPE_SUBMIT_INFO=4,VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO=5,VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE=6,VK_STRUCTURE_TYPE_BIND_SPARSE_INFO=7,VK_STRUCTURE_TYPE_FENCE_CREATE_INFO=8,VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO=9,VK_STRUCTURE_TYPE_EVENT_CREATE_INFO=10,VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO=11,VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO=12,VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO=13,VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO=14,VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO=15,VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO=16,VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO=17,VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO=18,VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO=19,VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO=20,VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO=21,VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO=22,VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO=23,VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO=24,VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO=25,VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO=26,VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO=27,VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO=28,VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO=29,VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO=30,VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO=31,VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO=32,VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO=33,VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO=34,VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET=35,VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET=36,VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO=37,VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO=38,VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO=39,VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO=40,VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO=41,VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO=42,VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO=43,VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER=44,VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER=45,VK_STRUCTURE_TYPE_MEMORY_BARRIER=46,VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO=47,VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO=48,VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR=1000001000,VK_STRUCTURE_TYPE_PRESENT_INFO_KHR=1000001001,VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR=1000002000,VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR=1000002001,VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR=1000003000,VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR=1000004000,VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR=1000005000,VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR=1000006000,VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR=1000007000,VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR=1000008000,VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR=1000009000,VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT=1000011000,VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD=1000018000,VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT=1000022000,VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT=1000022001,VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT=1000022002,VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV=1000026000,VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV=1000026001,VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV=1000026002,VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV=1000056000,VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV=1000056001,VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV=1000057000,VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV=1000057001,VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV=1000058000,VK_STRUCTURE_TYPE_BEGIN_RANGE=0,VK_STRUCTURE_TYPE_END_RANGE=48,VK_STRUCTURE_TYPE_RANGE_SIZE=49,VK_STRUCTURE_TYPE_MAX_ENUM=2147483647};
typedef enum VkVertexInputRate{VK_VERTEX_INPUT_RATE_VERTEX=0,VK_VERTEX_INPUT_RATE_INSTANCE=1,VK_VERTEX_INPUT_RATE_BEGIN_RANGE=0,VK_VERTEX_INPUT_RATE_END_RANGE=1,VK_VERTEX_INPUT_RATE_RANGE_SIZE=2,VK_VERTEX_INPUT_RATE_MAX_ENUM=2147483647};
typedef enum VkCompositeAlphaFlagBitsKHR{VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR=1,VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR=2,VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR=4,VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR=8,VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR=2147483647};
typedef enum VkImageTiling{VK_IMAGE_TILING_OPTIMAL=0,VK_IMAGE_TILING_LINEAR=1,VK_IMAGE_TILING_BEGIN_RANGE=0,VK_IMAGE_TILING_END_RANGE=1,VK_IMAGE_TILING_RANGE_SIZE=2,VK_IMAGE_TILING_MAX_ENUM=2147483647};
typedef enum VkFormat{VK_FORMAT_UNDEFINED=0,VK_FORMAT_R4G4_UNORM_PACK8=1,VK_FORMAT_R4G4B4A4_UNORM_PACK16=2,VK_FORMAT_B4G4R4A4_UNORM_PACK16=3,VK_FORMAT_R5G6B5_UNORM_PACK16=4,VK_FORMAT_B5G6R5_UNORM_PACK16=5,VK_FORMAT_R5G5B5A1_UNORM_PACK16=6,VK_FORMAT_B5G5R5A1_UNORM_PACK16=7,VK_FORMAT_A1R5G5B5_UNORM_PACK16=8,VK_FORMAT_R8_UNORM=9,VK_FORMAT_R8_SNORM=10,VK_FORMAT_R8_USCALED=11,VK_FORMAT_R8_SSCALED=12,VK_FORMAT_R8_UINT=13,VK_FORMAT_R8_SINT=14,VK_FORMAT_R8_SRGB=15,VK_FORMAT_R8G8_UNORM=16,VK_FORMAT_R8G8_SNORM=17,VK_FORMAT_R8G8_USCALED=18,VK_FORMAT_R8G8_SSCALED=19,VK_FORMAT_R8G8_UINT=20,VK_FORMAT_R8G8_SINT=21,VK_FORMAT_R8G8_SRGB=22,VK_FORMAT_R8G8B8_UNORM=23,VK_FORMAT_R8G8B8_SNORM=24,VK_FORMAT_R8G8B8_USCALED=25,VK_FORMAT_R8G8B8_SSCALED=26,VK_FORMAT_R8G8B8_UINT=27,VK_FORMAT_R8G8B8_SINT=28,VK_FORMAT_R8G8B8_SRGB=29,VK_FORMAT_B8G8R8_UNORM=30,VK_FORMAT_B8G8R8_SNORM=31,VK_FORMAT_B8G8R8_USCALED=32,VK_FORMAT_B8G8R8_SSCALED=33,VK_FORMAT_B8G8R8_UINT=34,VK_FORMAT_B8G8R8_SINT=35,VK_FORMAT_B8G8R8_SRGB=36,VK_FORMAT_R8G8B8A8_UNORM=37,VK_FORMAT_R8G8B8A8_SNORM=38,VK_FORMAT_R8G8B8A8_USCALED=39,VK_FORMAT_R8G8B8A8_SSCALED=40,VK_FORMAT_R8G8B8A8_UINT=41,VK_FORMAT_R8G8B8A8_SINT=42,VK_FORMAT_R8G8B8A8_SRGB=43,VK_FORMAT_B8G8R8A8_UNORM=44,VK_FORMAT_B8G8R8A8_SNORM=45,VK_FORMAT_B8G8R8A8_USCALED=46,VK_FORMAT_B8G8R8A8_SSCALED=47,VK_FORMAT_B8G8R8A8_UINT=48,VK_FORMAT_B8G8R8A8_SINT=49,VK_FORMAT_B8G8R8A8_SRGB=50,VK_FORMAT_A8B8G8R8_UNORM_PACK32=51,VK_FORMAT_A8B8G8R8_SNORM_PACK32=52,VK_FORMAT_A8B8G8R8_USCALED_PACK32=53,VK_FORMAT_A8B8G8R8_SSCALED_PACK32=54,VK_FORMAT_A8B8G8R8_UINT_PACK32=55,VK_FORMAT_A8B8G8R8_SINT_PACK32=56,VK_FORMAT_A8B8G8R8_SRGB_PACK32=57,VK_FORMAT_A2R10G10B10_UNORM_PACK32=58,VK_FORMAT_A2R10G10B10_SNORM_PACK32=59,VK_FORMAT_A2R10G10B10_USCALED_PACK32=60,VK_FORMAT_A2R10G10B10_SSCALED_PACK32=61,VK_FORMAT_A2R10G10B10_UINT_PACK32=62,VK_FORMAT_A2R10G10B10_SINT_PACK32=63,VK_FORMAT_A2B10G10R10_UNORM_PACK32=64,VK_FORMAT_A2B10G10R10_SNORM_PACK32=65,VK_FORMAT_A2B10G10R10_USCALED_PACK32=66,VK_FORMAT_A2B10G10R10_SSCALED_PACK32=67,VK_FORMAT_A2B10G10R10_UINT_PACK32=68,VK_FORMAT_A2B10G10R10_SINT_PACK32=69,VK_FORMAT_R16_UNORM=70,VK_FORMAT_R16_SNORM=71,VK_FORMAT_R16_USCALED=72,VK_FORMAT_R16_SSCALED=73,VK_FORMAT_R16_UINT=74,VK_FORMAT_R16_SINT=75,VK_FORMAT_R16_SFLOAT=76,VK_FORMAT_R16G16_UNORM=77,VK_FORMAT_R16G16_SNORM=78,VK_FORMAT_R16G16_USCALED=79,VK_FORMAT_R16G16_SSCALED=80,VK_FORMAT_R16G16_UINT=81,VK_FORMAT_R16G16_SINT=82,VK_FORMAT_R16G16_SFLOAT=83,VK_FORMAT_R16G16B16_UNORM=84,VK_FORMAT_R16G16B16_SNORM=85,VK_FORMAT_R16G16B16_USCALED=86,VK_FORMAT_R16G16B16_SSCALED=87,VK_FORMAT_R16G16B16_UINT=88,VK_FORMAT_R16G16B16_SINT=89,VK_FORMAT_R16G16B16_SFLOAT=90,VK_FORMAT_R16G16B16A16_UNORM=91,VK_FORMAT_R16G16B16A16_SNORM=92,VK_FORMAT_R16G16B16A16_USCALED=93,VK_FORMAT_R16G16B16A16_SSCALED=94,VK_FORMAT_R16G16B16A16_UINT=95,VK_FORMAT_R16G16B16A16_SINT=96,VK_FORMAT_R16G16B16A16_SFLOAT=97,VK_FORMAT_R32_UINT=98,VK_FORMAT_R32_SINT=99,VK_FORMAT_R32_SFLOAT=100,VK_FORMAT_R32G32_UINT=101,VK_FORMAT_R32G32_SINT=102,VK_FORMAT_R32G32_SFLOAT=103,VK_FORMAT_R32G32B32_UINT=104,VK_FORMAT_R32G32B32_SINT=105,VK_FORMAT_R32G32B32_SFLOAT=106,VK_FORMAT_R32G32B32A32_UINT=107,VK_FORMAT_R32G32B32A32_SINT=108,VK_FORMAT_R32G32B32A32_SFLOAT=109,VK_FORMAT_R64_UINT=110,VK_FORMAT_R64_SINT=111,VK_FORMAT_R64_SFLOAT=112,VK_FORMAT_R64G64_UINT=113,VK_FORMAT_R64G64_SINT=114,VK_FORMAT_R64G64_SFLOAT=115,VK_FORMAT_R64G64B64_UINT=116,VK_FORMAT_R64G64B64_SINT=117,VK_FORMAT_R64G64B64_SFLOAT=118,VK_FORMAT_R64G64B64A64_UINT=119,VK_FORMAT_R64G64B64A64_SINT=120,VK_FORMAT_R64G64B64A64_SFLOAT=121,VK_FORMAT_B10G11R11_UFLOAT_PACK32=122,VK_FORMAT_E5B9G9R9_UFLOAT_PACK32=123,VK_FORMAT_D16_UNORM=124,VK_FORMAT_X8_D24_UNORM_PACK32=125,VK_FORMAT_D32_SFLOAT=126,VK_FORMAT_S8_UINT=127,VK_FORMAT_D16_UNORM_S8_UINT=128,VK_FORMAT_D24_UNORM_S8_UINT=129,VK_FORMAT_D32_SFLOAT_S8_UINT=130,VK_FORMAT_BC1_RGB_UNORM_BLOCK=131,VK_FORMAT_BC1_RGB_SRGB_BLOCK=132,VK_FORMAT_BC1_RGBA_UNORM_BLOCK=133,VK_FORMAT_BC1_RGBA_SRGB_BLOCK=134,VK_FORMAT_BC2_UNORM_BLOCK=135,VK_FORMAT_BC2_SRGB_BLOCK=136,VK_FORMAT_BC3_UNORM_BLOCK=137,VK_FORMAT_BC3_SRGB_BLOCK=138,VK_FORMAT_BC4_UNORM_BLOCK=139,VK_FORMAT_BC4_SNORM_BLOCK=140,VK_FORMAT_BC5_UNORM_BLOCK=141,VK_FORMAT_BC5_SNORM_BLOCK=142,VK_FORMAT_BC6H_UFLOAT_BLOCK=143,VK_FORMAT_BC6H_SFLOAT_BLOCK=144,VK_FORMAT_BC7_UNORM_BLOCK=145,VK_FORMAT_BC7_SRGB_BLOCK=146,VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK=147,VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK=148,VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK=149,VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK=150,VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK=151,VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK=152,VK_FORMAT_EAC_R11_UNORM_BLOCK=153,VK_FORMAT_EAC_R11_SNORM_BLOCK=154,VK_FORMAT_EAC_R11G11_UNORM_BLOCK=155,VK_FORMAT_EAC_R11G11_SNORM_BLOCK=156,VK_FORMAT_ASTC_4x4_UNORM_BLOCK=157,VK_FORMAT_ASTC_4x4_SRGB_BLOCK=158,VK_FORMAT_ASTC_5x4_UNORM_BLOCK=159,VK_FORMAT_ASTC_5x4_SRGB_BLOCK=160,VK_FORMAT_ASTC_5x5_UNORM_BLOCK=161,VK_FORMAT_ASTC_5x5_SRGB_BLOCK=162,VK_FORMAT_ASTC_6x5_UNORM_BLOCK=163,VK_FORMAT_ASTC_6x5_SRGB_BLOCK=164,VK_FORMAT_ASTC_6x6_UNORM_BLOCK=165,VK_FORMAT_ASTC_6x6_SRGB_BLOCK=166,VK_FORMAT_ASTC_8x5_UNORM_BLOCK=167,VK_FORMAT_ASTC_8x5_SRGB_BLOCK=168,VK_FORMAT_ASTC_8x6_UNORM_BLOCK=169,VK_FORMAT_ASTC_8x6_SRGB_BLOCK=170,VK_FORMAT_ASTC_8x8_UNORM_BLOCK=171,VK_FORMAT_ASTC_8x8_SRGB_BLOCK=172,VK_FORMAT_ASTC_10x5_UNORM_BLOCK=173,VK_FORMAT_ASTC_10x5_SRGB_BLOCK=174,VK_FORMAT_ASTC_10x6_UNORM_BLOCK=175,VK_FORMAT_ASTC_10x6_SRGB_BLOCK=176,VK_FORMAT_ASTC_10x8_UNORM_BLOCK=177,VK_FORMAT_ASTC_10x8_SRGB_BLOCK=178,VK_FORMAT_ASTC_10x10_UNORM_BLOCK=179,VK_FORMAT_ASTC_10x10_SRGB_BLOCK=180,VK_FORMAT_ASTC_12x10_UNORM_BLOCK=181,VK_FORMAT_ASTC_12x10_SRGB_BLOCK=182,VK_FORMAT_ASTC_12x12_UNORM_BLOCK=183,VK_FORMAT_ASTC_12x12_SRGB_BLOCK=184,VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG=1000054000,VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG=1000054001,VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG=1000054002,VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG=1000054003,VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG=1000054004,VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG=1000054005,VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG=1000054006,VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG=1000054007,VK_FORMAT_BEGIN_RANGE=0,VK_FORMAT_END_RANGE=184,VK_FORMAT_RANGE_SIZE=185,VK_FORMAT_MAX_ENUM=2147483647};
typedef enum VkAttachmentStoreOp{VK_ATTACHMENT_STORE_OP_STORE=0,VK_ATTACHMENT_STORE_OP_DONT_CARE=1,VK_ATTACHMENT_STORE_OP_BEGIN_RANGE=0,VK_ATTACHMENT_STORE_OP_END_RANGE=1,VK_ATTACHMENT_STORE_OP_RANGE_SIZE=2,VK_ATTACHMENT_STORE_OP_MAX_ENUM=2147483647};
typedef enum VkLogicOp{VK_LOGIC_OP_CLEAR=0,VK_LOGIC_OP_AND=1,VK_LOGIC_OP_AND_REVERSE=2,VK_LOGIC_OP_COPY=3,VK_LOGIC_OP_AND_INVERTED=4,VK_LOGIC_OP_NO_OP=5,VK_LOGIC_OP_XOR=6,VK_LOGIC_OP_OR=7,VK_LOGIC_OP_NOR=8,VK_LOGIC_OP_EQUIVALENT=9,VK_LOGIC_OP_INVERT=10,VK_LOGIC_OP_OR_REVERSE=11,VK_LOGIC_OP_COPY_INVERTED=12,VK_LOGIC_OP_OR_INVERTED=13,VK_LOGIC_OP_NAND=14,VK_LOGIC_OP_SET=15,VK_LOGIC_OP_BEGIN_RANGE=0,VK_LOGIC_OP_END_RANGE=15,VK_LOGIC_OP_RANGE_SIZE=16,VK_LOGIC_OP_MAX_ENUM=2147483647};
typedef enum VkAttachmentLoadOp{VK_ATTACHMENT_LOAD_OP_LOAD=0,VK_ATTACHMENT_LOAD_OP_CLEAR=1,VK_ATTACHMENT_LOAD_OP_DONT_CARE=2,VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE=0,VK_ATTACHMENT_LOAD_OP_END_RANGE=2,VK_ATTACHMENT_LOAD_OP_RANGE_SIZE=3,VK_ATTACHMENT_LOAD_OP_MAX_ENUM=2147483647};
typedef enum VkImageAspectFlagBits{VK_IMAGE_ASPECT_COLOR_BIT=1,VK_IMAGE_ASPECT_DEPTH_BIT=2,VK_IMAGE_ASPECT_STENCIL_BIT=4,VK_IMAGE_ASPECT_METADATA_BIT=8,VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkPolygonMode{VK_POLYGON_MODE_FILL=0,VK_POLYGON_MODE_LINE=1,VK_POLYGON_MODE_POINT=2,VK_POLYGON_MODE_BEGIN_RANGE=0,VK_POLYGON_MODE_END_RANGE=2,VK_POLYGON_MODE_RANGE_SIZE=3,VK_POLYGON_MODE_MAX_ENUM=2147483647};
typedef enum VkImageType{VK_IMAGE_TYPE_1D=0,VK_IMAGE_TYPE_2D=1,VK_IMAGE_TYPE_3D=2,VK_IMAGE_TYPE_BEGIN_RANGE=0,VK_IMAGE_TYPE_END_RANGE=2,VK_IMAGE_TYPE_RANGE_SIZE=3,VK_IMAGE_TYPE_MAX_ENUM=2147483647};
typedef enum VkSparseImageFormatFlagBits{VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT=1,VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT=2,VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT=4,VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkBorderColor{VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK=0,VK_BORDER_COLOR_INT_TRANSPARENT_BLACK=1,VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK=2,VK_BORDER_COLOR_INT_OPAQUE_BLACK=3,VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE=4,VK_BORDER_COLOR_INT_OPAQUE_WHITE=5,VK_BORDER_COLOR_BEGIN_RANGE=0,VK_BORDER_COLOR_END_RANGE=5,VK_BORDER_COLOR_RANGE_SIZE=6,VK_BORDER_COLOR_MAX_ENUM=2147483647};
typedef enum VkInternalAllocationType{VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE=0,VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE=0,VK_INTERNAL_ALLOCATION_TYPE_END_RANGE=0,VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE=1,VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM=2147483647};
typedef enum VkExternalMemoryHandleTypeFlagBitsNV{VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV=1,VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV=2,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV=4,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV=8,VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV=2147483647};
typedef enum VkRasterizationOrderAMD{VK_RASTERIZATION_ORDER_STRICT_AMD=0,VK_RASTERIZATION_ORDER_RELAXED_AMD=1,VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD=0,VK_RASTERIZATION_ORDER_END_RANGE_AMD=1,VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD=2,VK_RASTERIZATION_ORDER_MAX_ENUM_AMD=2147483647};
typedef enum VkDebugReportErrorEXT{VK_DEBUG_REPORT_ERROR_NONE_EXT=0,VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT=1,VK_DEBUG_REPORT_ERROR_BEGIN_RANGE_EXT=0,VK_DEBUG_REPORT_ERROR_END_RANGE_EXT=1,VK_DEBUG_REPORT_ERROR_RANGE_SIZE_EXT=2,VK_DEBUG_REPORT_ERROR_MAX_ENUM_EXT=2147483647};
typedef enum VkQueryPipelineStatisticFlagBits{VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT=1,VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT=2,VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT=4,VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT=8,VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT=16,VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT=32,VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT=64,VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT=128,VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT=256,VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT=512,VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT=1024,VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkColorSpaceKHR{VK_COLOR_SPACE_SRGB_NONLINEAR_KHR=0,VK_COLOR_SPACE_BEGIN_RANGE_KHR=0,VK_COLOR_SPACE_END_RANGE_KHR=0,VK_COLOR_SPACE_RANGE_SIZE_KHR=1,VK_COLOR_SPACE_MAX_ENUM_KHR=2147483647};
typedef enum VkFrontFace{VK_FRONT_FACE_COUNTER_CLOCKWISE=0,VK_FRONT_FACE_CLOCKWISE=1,VK_FRONT_FACE_BEGIN_RANGE=0,VK_FRONT_FACE_END_RANGE=1,VK_FRONT_FACE_RANGE_SIZE=2,VK_FRONT_FACE_MAX_ENUM=2147483647};
typedef enum VkStencilOp{VK_STENCIL_OP_KEEP=0,VK_STENCIL_OP_ZERO=1,VK_STENCIL_OP_REPLACE=2,VK_STENCIL_OP_INCREMENT_AND_CLAMP=3,VK_STENCIL_OP_DECREMENT_AND_CLAMP=4,VK_STENCIL_OP_INVERT=5,VK_STENCIL_OP_INCREMENT_AND_WRAP=6,VK_STENCIL_OP_DECREMENT_AND_WRAP=7,VK_STENCIL_OP_BEGIN_RANGE=0,VK_STENCIL_OP_END_RANGE=7,VK_STENCIL_OP_RANGE_SIZE=8,VK_STENCIL_OP_MAX_ENUM=2147483647};
typedef enum VkBlendOp{VK_BLEND_OP_ADD=0,VK_BLEND_OP_SUBTRACT=1,VK_BLEND_OP_REVERSE_SUBTRACT=2,VK_BLEND_OP_MIN=3,VK_BLEND_OP_MAX=4,VK_BLEND_OP_BEGIN_RANGE=0,VK_BLEND_OP_END_RANGE=4,VK_BLEND_OP_RANGE_SIZE=5,VK_BLEND_OP_MAX_ENUM=2147483647};
typedef enum VkBlendFactor{VK_BLEND_FACTOR_ZERO=0,VK_BLEND_FACTOR_ONE=1,VK_BLEND_FACTOR_SRC_COLOR=2,VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR=3,VK_BLEND_FACTOR_DST_COLOR=4,VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR=5,VK_BLEND_FACTOR_SRC_ALPHA=6,VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA=7,VK_BLEND_FACTOR_DST_ALPHA=8,VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA=9,VK_BLEND_FACTOR_CONSTANT_COLOR=10,VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR=11,VK_BLEND_FACTOR_CONSTANT_ALPHA=12,VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA=13,VK_BLEND_FACTOR_SRC_ALPHA_SATURATE=14,VK_BLEND_FACTOR_SRC1_COLOR=15,VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR=16,VK_BLEND_FACTOR_SRC1_ALPHA=17,VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA=18,VK_BLEND_FACTOR_BEGIN_RANGE=0,VK_BLEND_FACTOR_END_RANGE=18,VK_BLEND_FACTOR_RANGE_SIZE=19,VK_BLEND_FACTOR_MAX_ENUM=2147483647};
typedef enum VkPipelineBindPoint{VK_PIPELINE_BIND_POINT_GRAPHICS=0,VK_PIPELINE_BIND_POINT_COMPUTE=1,VK_PIPELINE_BIND_POINT_BEGIN_RANGE=0,VK_PIPELINE_BIND_POINT_END_RANGE=1,VK_PIPELINE_BIND_POINT_RANGE_SIZE=2,VK_PIPELINE_BIND_POINT_MAX_ENUM=2147483647};
typedef enum VkCommandBufferUsageFlagBits{VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT=1,VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT=2,VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT=4,VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkSamplerAddressMode{VK_SAMPLER_ADDRESS_MODE_REPEAT=0,VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT=1,VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE=2,VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER=3,VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE=4,VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE=0,VK_SAMPLER_ADDRESS_MODE_END_RANGE=3,VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE=4,VK_SAMPLER_ADDRESS_MODE_MAX_ENUM=2147483647};
typedef enum VkMemoryPropertyFlagBits{VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT=1,VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT=2,VK_MEMORY_PROPERTY_HOST_COHERENT_BIT=4,VK_MEMORY_PROPERTY_HOST_CACHED_BIT=8,VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT=16,VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkPhysicalDeviceType{VK_PHYSICAL_DEVICE_TYPE_OTHER=0,VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU=1,VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU=2,VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU=3,VK_PHYSICAL_DEVICE_TYPE_CPU=4,VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE=0,VK_PHYSICAL_DEVICE_TYPE_END_RANGE=4,VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE=5,VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM=2147483647};
typedef enum VkQueryType{VK_QUERY_TYPE_OCCLUSION=0,VK_QUERY_TYPE_PIPELINE_STATISTICS=1,VK_QUERY_TYPE_TIMESTAMP=2,VK_QUERY_TYPE_BEGIN_RANGE=0,VK_QUERY_TYPE_END_RANGE=2,VK_QUERY_TYPE_RANGE_SIZE=3,VK_QUERY_TYPE_MAX_ENUM=2147483647};
typedef enum VkSharingMode{VK_SHARING_MODE_EXCLUSIVE=0,VK_SHARING_MODE_CONCURRENT=1,VK_SHARING_MODE_BEGIN_RANGE=0,VK_SHARING_MODE_END_RANGE=1,VK_SHARING_MODE_RANGE_SIZE=2,VK_SHARING_MODE_MAX_ENUM=2147483647};
typedef enum VkSubpassContents{VK_SUBPASS_CONTENTS_INLINE=0,VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS=1,VK_SUBPASS_CONTENTS_BEGIN_RANGE=0,VK_SUBPASS_CONTENTS_END_RANGE=1,VK_SUBPASS_CONTENTS_RANGE_SIZE=2,VK_SUBPASS_CONTENTS_MAX_ENUM=2147483647};
typedef enum VkQueueFlagBits{VK_QUEUE_GRAPHICS_BIT=1,VK_QUEUE_COMPUTE_BIT=2,VK_QUEUE_TRANSFER_BIT=4,VK_QUEUE_SPARSE_BINDING_BIT=8,VK_QUEUE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkColorComponentFlagBits{VK_COLOR_COMPONENT_R_BIT=1,VK_COLOR_COMPONENT_G_BIT=2,VK_COLOR_COMPONENT_B_BIT=4,VK_COLOR_COMPONENT_A_BIT=8,VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkComponentSwizzle{VK_COMPONENT_SWIZZLE_IDENTITY=0,VK_COMPONENT_SWIZZLE_ZERO=1,VK_COMPONENT_SWIZZLE_ONE=2,VK_COMPONENT_SWIZZLE_R=3,VK_COMPONENT_SWIZZLE_G=4,VK_COMPONENT_SWIZZLE_B=5,VK_COMPONENT_SWIZZLE_A=6,VK_COMPONENT_SWIZZLE_BEGIN_RANGE=0,VK_COMPONENT_SWIZZLE_END_RANGE=6,VK_COMPONENT_SWIZZLE_RANGE_SIZE=7,VK_COMPONENT_SWIZZLE_MAX_ENUM=2147483647};
typedef enum VkCommandBufferResetFlagBits{VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT=1,VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkDescriptorType{VK_DESCRIPTOR_TYPE_SAMPLER=0,VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER=1,VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE=2,VK_DESCRIPTOR_TYPE_STORAGE_IMAGE=3,VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER=4,VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER=5,VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER=6,VK_DESCRIPTOR_TYPE_STORAGE_BUFFER=7,VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC=8,VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC=9,VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT=10,VK_DESCRIPTOR_TYPE_BEGIN_RANGE=0,VK_DESCRIPTOR_TYPE_END_RANGE=10,VK_DESCRIPTOR_TYPE_RANGE_SIZE=11,VK_DESCRIPTOR_TYPE_MAX_ENUM=2147483647};
typedef enum VkStencilFaceFlagBits{VK_STENCIL_FACE_FRONT_BIT=1,VK_STENCIL_FACE_BACK_BIT=2,VK_STENCIL_FRONT_AND_BACK=3,VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkBufferCreateFlagBits{VK_BUFFER_CREATE_SPARSE_BINDING_BIT=1,VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT=2,VK_BUFFER_CREATE_SPARSE_ALIASED_BIT=4,VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM=2147483647};
typedef enum VkCommandBufferLevel{VK_COMMAND_BUFFER_LEVEL_PRIMARY=0,VK_COMMAND_BUFFER_LEVEL_SECONDARY=1,VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE=0,VK_COMMAND_BUFFER_LEVEL_END_RANGE=1,VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE=2,VK_COMMAND_BUFFER_LEVEL_MAX_ENUM=2147483647};
typedef enum VkDescriptorPoolCreateFlagBits{VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT=1,VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM=2147483647};
struct VkInstance_T {};
struct VkPhysicalDevice_T {};
struct VkDevice_T {};
struct VkQueue_T {};
struct VkSemaphore_T {};
struct VkCommandBuffer_T {};
struct VkFence_T {};
struct VkDeviceMemory_T {};
struct VkBuffer_T {};
struct VkImage_T {};
struct VkEvent_T {};
struct VkQueryPool_T {};
struct VkBufferView_T {};
struct VkImageView_T {};
struct VkShaderModule_T {};
struct VkPipelineCache_T {};
struct VkPipelineLayout_T {};
struct VkRenderPass_T {};
struct VkPipeline_T {};
struct VkDescriptorSetLayout_T {};
struct VkSampler_T {};
struct VkDescriptorPool_T {};
struct VkDescriptorSet_T {};
struct VkFramebuffer_T {};
struct VkCommandPool_T {};
struct VkApplicationInfo {enum VkStructureType sType;const void*pNext;const char*pApplicationName;unsigned int applicationVersion;const char*pEngineName;unsigned int engineVersion;unsigned int apiVersion;};
struct VkInstanceCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;const struct VkApplicationInfo*pApplicationInfo;unsigned int enabledLayerCount;const char*const*ppEnabledLayerNames;unsigned int enabledExtensionCount;const char*const*ppEnabledExtensionNames;};
struct VkAllocationCallbacks {void*pUserData;void*(*pfnAllocation)(void*,unsigned long,unsigned long,enum VkSystemAllocationScope);void*(*pfnReallocation)(void*,void*,unsigned long,unsigned long,enum VkSystemAllocationScope);void(*pfnFree)(void*,void*);void(*pfnInternalAllocation)(void*,unsigned long,enum VkInternalAllocationType,enum VkSystemAllocationScope);void(*pfnInternalFree)(void*,unsigned long,enum VkInternalAllocationType,enum VkSystemAllocationScope);};
struct VkPhysicalDeviceFeatures {unsigned int robustBufferAccess;unsigned int fullDrawIndexUint32;unsigned int imageCubeArray;unsigned int independentBlend;unsigned int geometryShader;unsigned int tessellationShader;unsigned int sampleRateShading;unsigned int dualSrcBlend;unsigned int logicOp;unsigned int multiDrawIndirect;unsigned int drawIndirectFirstInstance;unsigned int depthClamp;unsigned int depthBiasClamp;unsigned int fillModeNonSolid;unsigned int depthBounds;unsigned int wideLines;unsigned int largePoints;unsigned int alphaToOne;unsigned int multiViewport;unsigned int samplerAnisotropy;unsigned int textureCompressionETC2;unsigned int textureCompressionASTC_LDR;unsigned int textureCompressionBC;unsigned int occlusionQueryPrecise;unsigned int pipelineStatisticsQuery;unsigned int vertexPipelineStoresAndAtomics;unsigned int fragmentStoresAndAtomics;unsigned int shaderTessellationAndGeometryPointSize;unsigned int shaderImageGatherExtended;unsigned int shaderStorageImageExtendedFormats;unsigned int shaderStorageImageMultisample;unsigned int shaderStorageImageReadWithoutFormat;unsigned int shaderStorageImageWriteWithoutFormat;unsigned int shaderUniformBufferArrayDynamicIndexing;unsigned int shaderSampledImageArrayDynamicIndexing;unsigned int shaderStorageBufferArrayDynamicIndexing;unsigned int shaderStorageImageArrayDynamicIndexing;unsigned int shaderClipDistance;unsigned int shaderCullDistance;unsigned int shaderFloat64;unsigned int shaderInt64;unsigned int shaderInt16;unsigned int shaderResourceResidency;unsigned int shaderResourceMinLod;unsigned int sparseBinding;unsigned int sparseResidencyBuffer;unsigned int sparseResidencyImage2D;unsigned int sparseResidencyImage3D;unsigned int sparseResidency2Samples;unsigned int sparseResidency4Samples;unsigned int sparseResidency8Samples;unsigned int sparseResidency16Samples;unsigned int sparseResidencyAliased;unsigned int variableMultisampleRate;unsigned int inheritedQueries;};
struct VkFormatProperties {unsigned int linearTilingFeatures;unsigned int optimalTilingFeatures;unsigned int bufferFeatures;};
struct VkExtent3D {unsigned int width;unsigned int height;unsigned int depth;};
struct VkImageFormatProperties {struct VkExtent3D maxExtent;unsigned int maxMipLevels;unsigned int maxArrayLayers;unsigned int sampleCounts;unsigned long maxResourceSize;};
struct VkPhysicalDeviceLimits {unsigned int maxImageDimension1D;unsigned int maxImageDimension2D;unsigned int maxImageDimension3D;unsigned int maxImageDimensionCube;unsigned int maxImageArrayLayers;unsigned int maxTexelBufferElements;unsigned int maxUniformBufferRange;unsigned int maxStorageBufferRange;unsigned int maxPushConstantsSize;unsigned int maxMemoryAllocationCount;unsigned int maxSamplerAllocationCount;unsigned long bufferImageGranularity;unsigned long sparseAddressSpaceSize;unsigned int maxBoundDescriptorSets;unsigned int maxPerStageDescriptorSamplers;unsigned int maxPerStageDescriptorUniformBuffers;unsigned int maxPerStageDescriptorStorageBuffers;unsigned int maxPerStageDescriptorSampledImages;unsigned int maxPerStageDescriptorStorageImages;unsigned int maxPerStageDescriptorInputAttachments;unsigned int maxPerStageResources;unsigned int maxDescriptorSetSamplers;unsigned int maxDescriptorSetUniformBuffers;unsigned int maxDescriptorSetUniformBuffersDynamic;unsigned int maxDescriptorSetStorageBuffers;unsigned int maxDescriptorSetStorageBuffersDynamic;unsigned int maxDescriptorSetSampledImages;unsigned int maxDescriptorSetStorageImages;unsigned int maxDescriptorSetInputAttachments;unsigned int maxVertexInputAttributes;unsigned int maxVertexInputBindings;unsigned int maxVertexInputAttributeOffset;unsigned int maxVertexInputBindingStride;unsigned int maxVertexOutputComponents;unsigned int maxTessellationGenerationLevel;unsigned int maxTessellationPatchSize;unsigned int maxTessellationControlPerVertexInputComponents;unsigned int maxTessellationControlPerVertexOutputComponents;unsigned int maxTessellationControlPerPatchOutputComponents;unsigned int maxTessellationControlTotalOutputComponents;unsigned int maxTessellationEvaluationInputComponents;unsigned int maxTessellationEvaluationOutputComponents;unsigned int maxGeometryShaderInvocations;unsigned int maxGeometryInputComponents;unsigned int maxGeometryOutputComponents;unsigned int maxGeometryOutputVertices;unsigned int maxGeometryTotalOutputComponents;unsigned int maxFragmentInputComponents;unsigned int maxFragmentOutputAttachments;unsigned int maxFragmentDualSrcAttachments;unsigned int maxFragmentCombinedOutputResources;unsigned int maxComputeSharedMemorySize;unsigned int maxComputeWorkGroupCount[3];unsigned int maxComputeWorkGroupInvocations;unsigned int maxComputeWorkGroupSize[3];unsigned int subPixelPrecisionBits;unsigned int subTexelPrecisionBits;unsigned int mipmapPrecisionBits;unsigned int maxDrawIndexedIndexValue;unsigned int maxDrawIndirectCount;float maxSamplerLodBias;float maxSamplerAnisotropy;unsigned int maxViewports;unsigned int maxViewportDimensions[2];float viewportBoundsRange[2];unsigned int viewportSubPixelBits;unsigned long minMemoryMapAlignment;unsigned long minTexelBufferOffsetAlignment;unsigned long minUniformBufferOffsetAlignment;unsigned long minStorageBufferOffsetAlignment;int minTexelOffset;unsigned int maxTexelOffset;int minTexelGatherOffset;unsigned int maxTexelGatherOffset;float minInterpolationOffset;float maxInterpolationOffset;unsigned int subPixelInterpolationOffsetBits;unsigned int maxFramebufferWidth;unsigned int maxFramebufferHeight;unsigned int maxFramebufferLayers;unsigned int framebufferColorSampleCounts;unsigned int framebufferDepthSampleCounts;unsigned int framebufferStencilSampleCounts;unsigned int framebufferNoAttachmentsSampleCounts;unsigned int maxColorAttachments;unsigned int sampledImageColorSampleCounts;unsigned int sampledImageIntegerSampleCounts;unsigned int sampledImageDepthSampleCounts;unsigned int sampledImageStencilSampleCounts;unsigned int storageImageSampleCounts;unsigned int maxSampleMaskWords;unsigned int timestampComputeAndGraphics;float timestampPeriod;unsigned int maxClipDistances;unsigned int maxCullDistances;unsigned int maxCombinedClipAndCullDistances;unsigned int discreteQueuePriorities;float pointSizeRange[2];float lineWidthRange[2];float pointSizeGranularity;float lineWidthGranularity;unsigned int strictLines;unsigned int standardSampleLocations;unsigned long optimalBufferCopyOffsetAlignment;unsigned long optimalBufferCopyRowPitchAlignment;unsigned long nonCoherentAtomSize;};
struct VkPhysicalDeviceSparseProperties {unsigned int residencyStandard2DBlockShape;unsigned int residencyStandard2DMultisampleBlockShape;unsigned int residencyStandard3DBlockShape;unsigned int residencyAlignedMipSize;unsigned int residencyNonResidentStrict;};
struct VkPhysicalDeviceProperties {unsigned int apiVersion;unsigned int driverVersion;unsigned int vendorID;unsigned int deviceID;enum VkPhysicalDeviceType deviceType;char deviceName[256];unsigned char pipelineCacheUUID[16];struct VkPhysicalDeviceLimits limits;struct VkPhysicalDeviceSparseProperties sparseProperties;};
struct VkQueueFamilyProperties {unsigned int queueFlags;unsigned int queueCount;unsigned int timestampValidBits;struct VkExtent3D minImageTransferGranularity;};
struct VkMemoryType {unsigned int propertyFlags;unsigned int heapIndex;};
struct VkMemoryHeap {unsigned long size;unsigned int flags;};
struct VkPhysicalDeviceMemoryProperties {unsigned int memoryTypeCount;struct VkMemoryType memoryTypes[32];unsigned int memoryHeapCount;struct VkMemoryHeap memoryHeaps[16];};
struct VkDeviceQueueCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int queueFamilyIndex;unsigned int queueCount;const float*pQueuePriorities;};
struct VkDeviceCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int queueCreateInfoCount;const struct VkDeviceQueueCreateInfo*pQueueCreateInfos;unsigned int enabledLayerCount;const char*const*ppEnabledLayerNames;unsigned int enabledExtensionCount;const char*const*ppEnabledExtensionNames;const struct VkPhysicalDeviceFeatures*pEnabledFeatures;};
struct VkExtensionProperties {char extensionName[256];unsigned int specVersion;};
struct VkLayerProperties {char layerName[256];unsigned int specVersion;unsigned int implementationVersion;char description[256];};
struct VkSubmitInfo {enum VkStructureType sType;const void*pNext;unsigned int waitSemaphoreCount;struct VkSemaphore_T*const*pWaitSemaphores;const unsigned int*pWaitDstStageMask;unsigned int commandBufferCount;struct VkCommandBuffer_T*const*pCommandBuffers;unsigned int signalSemaphoreCount;struct VkSemaphore_T*const*pSignalSemaphores;};
struct VkMemoryAllocateInfo {enum VkStructureType sType;const void*pNext;unsigned long allocationSize;unsigned int memoryTypeIndex;};
struct VkMappedMemoryRange {enum VkStructureType sType;const void*pNext;struct VkDeviceMemory_T*memory;unsigned long offset;unsigned long size;};
struct VkMemoryRequirements {unsigned long size;unsigned long alignment;unsigned int memoryTypeBits;};
struct VkSparseImageFormatProperties {unsigned int aspectMask;struct VkExtent3D imageGranularity;unsigned int flags;};
struct VkSparseImageMemoryRequirements {struct VkSparseImageFormatProperties formatProperties;unsigned int imageMipTailFirstLod;unsigned long imageMipTailSize;unsigned long imageMipTailOffset;unsigned long imageMipTailStride;};
struct VkSparseMemoryBind {unsigned long resourceOffset;unsigned long size;struct VkDeviceMemory_T*memory;unsigned long memoryOffset;unsigned int flags;};
struct VkSparseBufferMemoryBindInfo {struct VkBuffer_T*buffer;unsigned int bindCount;const struct VkSparseMemoryBind*pBinds;};
struct VkSparseImageOpaqueMemoryBindInfo {struct VkImage_T*image;unsigned int bindCount;const struct VkSparseMemoryBind*pBinds;};
struct VkImageSubresource {unsigned int aspectMask;unsigned int mipLevel;unsigned int arrayLayer;};
struct VkOffset3D {int x;int y;int z;};
struct VkSparseImageMemoryBind {struct VkImageSubresource subresource;struct VkOffset3D offset;struct VkExtent3D extent;struct VkDeviceMemory_T*memory;unsigned long memoryOffset;unsigned int flags;};
struct VkSparseImageMemoryBindInfo {struct VkImage_T*image;unsigned int bindCount;const struct VkSparseImageMemoryBind*pBinds;};
struct VkBindSparseInfo {enum VkStructureType sType;const void*pNext;unsigned int waitSemaphoreCount;struct VkSemaphore_T*const*pWaitSemaphores;unsigned int bufferBindCount;const struct VkSparseBufferMemoryBindInfo*pBufferBinds;unsigned int imageOpaqueBindCount;const struct VkSparseImageOpaqueMemoryBindInfo*pImageOpaqueBinds;unsigned int imageBindCount;const struct VkSparseImageMemoryBindInfo*pImageBinds;unsigned int signalSemaphoreCount;struct VkSemaphore_T*const*pSignalSemaphores;};
struct VkFenceCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;};
struct VkSemaphoreCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;};
struct VkEventCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;};
struct VkQueryPoolCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;enum VkQueryType queryType;unsigned int queryCount;unsigned int pipelineStatistics;};
struct VkBufferCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned long size;unsigned int usage;enum VkSharingMode sharingMode;unsigned int queueFamilyIndexCount;const unsigned int*pQueueFamilyIndices;};
struct VkBufferViewCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;struct VkBuffer_T*buffer;enum VkFormat format;unsigned long offset;unsigned long range;};
struct VkImageCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;enum VkImageType imageType;enum VkFormat format;struct VkExtent3D extent;unsigned int mipLevels;unsigned int arrayLayers;enum VkSampleCountFlagBits samples;enum VkImageTiling tiling;unsigned int usage;enum VkSharingMode sharingMode;unsigned int queueFamilyIndexCount;const unsigned int*pQueueFamilyIndices;enum VkImageLayout initialLayout;};
struct VkSubresourceLayout {unsigned long offset;unsigned long size;unsigned long rowPitch;unsigned long arrayPitch;unsigned long depthPitch;};
struct VkComponentMapping {enum VkComponentSwizzle r;enum VkComponentSwizzle g;enum VkComponentSwizzle b;enum VkComponentSwizzle a;};
struct VkImageSubresourceRange {unsigned int aspectMask;unsigned int baseMipLevel;unsigned int levelCount;unsigned int baseArrayLayer;unsigned int layerCount;};
struct VkImageViewCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;struct VkImage_T*image;enum VkImageViewType viewType;enum VkFormat format;struct VkComponentMapping components;struct VkImageSubresourceRange subresourceRange;};
struct VkShaderModuleCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned long codeSize;const unsigned int*pCode;};
struct VkPipelineCacheCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned long initialDataSize;const void*pInitialData;};
struct VkSpecializationMapEntry {unsigned int constantID;unsigned int offset;unsigned long size;};
struct VkSpecializationInfo {unsigned int mapEntryCount;const struct VkSpecializationMapEntry*pMapEntries;unsigned long dataSize;const void*pData;};
struct VkPipelineShaderStageCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;enum VkShaderStageFlagBits stage;struct VkShaderModule_T*module;const char*pName;const struct VkSpecializationInfo*pSpecializationInfo;};
struct VkVertexInputBindingDescription {unsigned int binding;unsigned int stride;enum VkVertexInputRate inputRate;};
struct VkVertexInputAttributeDescription {unsigned int location;unsigned int binding;enum VkFormat format;unsigned int offset;};
struct VkPipelineVertexInputStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int vertexBindingDescriptionCount;const struct VkVertexInputBindingDescription*pVertexBindingDescriptions;unsigned int vertexAttributeDescriptionCount;const struct VkVertexInputAttributeDescription*pVertexAttributeDescriptions;};
struct VkPipelineInputAssemblyStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;enum VkPrimitiveTopology topology;unsigned int primitiveRestartEnable;};
struct VkPipelineTessellationStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int patchControlPoints;};
struct VkViewport {float x;float y;float width;float height;float minDepth;float maxDepth;};
struct VkOffset2D {int x;int y;};
struct VkExtent2D {unsigned int width;unsigned int height;};
struct VkRect2D {struct VkOffset2D offset;struct VkExtent2D extent;};
struct VkPipelineViewportStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int viewportCount;const struct VkViewport*pViewports;unsigned int scissorCount;const struct VkRect2D*pScissors;};
struct VkPipelineRasterizationStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int depthClampEnable;unsigned int rasterizerDiscardEnable;enum VkPolygonMode polygonMode;unsigned int cullMode;enum VkFrontFace frontFace;unsigned int depthBiasEnable;float depthBiasConstantFactor;float depthBiasClamp;float depthBiasSlopeFactor;float lineWidth;};
struct VkPipelineMultisampleStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;enum VkSampleCountFlagBits rasterizationSamples;unsigned int sampleShadingEnable;float minSampleShading;const unsigned int*pSampleMask;unsigned int alphaToCoverageEnable;unsigned int alphaToOneEnable;};
struct VkStencilOpState {enum VkStencilOp failOp;enum VkStencilOp passOp;enum VkStencilOp depthFailOp;enum VkCompareOp compareOp;unsigned int compareMask;unsigned int writeMask;unsigned int reference;};
struct VkPipelineDepthStencilStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int depthTestEnable;unsigned int depthWriteEnable;enum VkCompareOp depthCompareOp;unsigned int depthBoundsTestEnable;unsigned int stencilTestEnable;struct VkStencilOpState front;struct VkStencilOpState back;float minDepthBounds;float maxDepthBounds;};
struct VkPipelineColorBlendAttachmentState {unsigned int blendEnable;enum VkBlendFactor srcColorBlendFactor;enum VkBlendFactor dstColorBlendFactor;enum VkBlendOp colorBlendOp;enum VkBlendFactor srcAlphaBlendFactor;enum VkBlendFactor dstAlphaBlendFactor;enum VkBlendOp alphaBlendOp;unsigned int colorWriteMask;};
struct VkPipelineColorBlendStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int logicOpEnable;enum VkLogicOp logicOp;unsigned int attachmentCount;const struct VkPipelineColorBlendAttachmentState*pAttachments;float blendConstants[4];};
struct VkPipelineDynamicStateCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int dynamicStateCount;const enum VkDynamicState*pDynamicStates;};
struct VkGraphicsPipelineCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int stageCount;const struct VkPipelineShaderStageCreateInfo*pStages;const struct VkPipelineVertexInputStateCreateInfo*pVertexInputState;const struct VkPipelineInputAssemblyStateCreateInfo*pInputAssemblyState;const struct VkPipelineTessellationStateCreateInfo*pTessellationState;const struct VkPipelineViewportStateCreateInfo*pViewportState;const struct VkPipelineRasterizationStateCreateInfo*pRasterizationState;const struct VkPipelineMultisampleStateCreateInfo*pMultisampleState;const struct VkPipelineDepthStencilStateCreateInfo*pDepthStencilState;const struct VkPipelineColorBlendStateCreateInfo*pColorBlendState;const struct VkPipelineDynamicStateCreateInfo*pDynamicState;struct VkPipelineLayout_T*layout;struct VkRenderPass_T*renderPass;unsigned int subpass;struct VkPipeline_T*basePipelineHandle;int basePipelineIndex;};
struct VkComputePipelineCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;struct VkPipelineShaderStageCreateInfo stage;struct VkPipelineLayout_T*layout;struct VkPipeline_T*basePipelineHandle;int basePipelineIndex;};
struct VkPushConstantRange {unsigned int stageFlags;unsigned int offset;unsigned int size;};
struct VkPipelineLayoutCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int setLayoutCount;struct VkDescriptorSetLayout_T*const*pSetLayouts;unsigned int pushConstantRangeCount;const struct VkPushConstantRange*pPushConstantRanges;};
struct VkSamplerCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;enum VkFilter magFilter;enum VkFilter minFilter;enum VkSamplerMipmapMode mipmapMode;enum VkSamplerAddressMode addressModeU;enum VkSamplerAddressMode addressModeV;enum VkSamplerAddressMode addressModeW;float mipLodBias;unsigned int anisotropyEnable;float maxAnisotropy;unsigned int compareEnable;enum VkCompareOp compareOp;float minLod;float maxLod;enum VkBorderColor borderColor;unsigned int unnormalizedCoordinates;};
struct VkDescriptorSetLayoutBinding {unsigned int binding;enum VkDescriptorType descriptorType;unsigned int descriptorCount;unsigned int stageFlags;struct VkSampler_T*const*pImmutableSamplers;};
struct VkDescriptorSetLayoutCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int bindingCount;const struct VkDescriptorSetLayoutBinding*pBindings;};
struct VkDescriptorPoolSize {enum VkDescriptorType type;unsigned int descriptorCount;};
struct VkDescriptorPoolCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int maxSets;unsigned int poolSizeCount;const struct VkDescriptorPoolSize*pPoolSizes;};
struct VkDescriptorSetAllocateInfo {enum VkStructureType sType;const void*pNext;struct VkDescriptorPool_T*descriptorPool;unsigned int descriptorSetCount;struct VkDescriptorSetLayout_T*const*pSetLayouts;};
struct VkDescriptorImageInfo {struct VkSampler_T*sampler;struct VkImageView_T*imageView;enum VkImageLayout imageLayout;};
struct VkDescriptorBufferInfo {struct VkBuffer_T*buffer;unsigned long offset;unsigned long range;};
struct VkWriteDescriptorSet {enum VkStructureType sType;const void*pNext;struct VkDescriptorSet_T*dstSet;unsigned int dstBinding;unsigned int dstArrayElement;unsigned int descriptorCount;enum VkDescriptorType descriptorType;const struct VkDescriptorImageInfo*pImageInfo;const struct VkDescriptorBufferInfo*pBufferInfo;struct VkBufferView_T*const*pTexelBufferView;};
struct VkCopyDescriptorSet {enum VkStructureType sType;const void*pNext;struct VkDescriptorSet_T*srcSet;unsigned int srcBinding;unsigned int srcArrayElement;struct VkDescriptorSet_T*dstSet;unsigned int dstBinding;unsigned int dstArrayElement;unsigned int descriptorCount;};
struct VkFramebufferCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;struct VkRenderPass_T*renderPass;unsigned int attachmentCount;struct VkImageView_T*const*pAttachments;unsigned int width;unsigned int height;unsigned int layers;};
struct VkAttachmentDescription {unsigned int flags;enum VkFormat format;enum VkSampleCountFlagBits samples;enum VkAttachmentLoadOp loadOp;enum VkAttachmentStoreOp storeOp;enum VkAttachmentLoadOp stencilLoadOp;enum VkAttachmentStoreOp stencilStoreOp;enum VkImageLayout initialLayout;enum VkImageLayout finalLayout;};
struct VkAttachmentReference {unsigned int attachment;enum VkImageLayout layout;};
struct VkSubpassDescription {unsigned int flags;enum VkPipelineBindPoint pipelineBindPoint;unsigned int inputAttachmentCount;const struct VkAttachmentReference*pInputAttachments;unsigned int colorAttachmentCount;const struct VkAttachmentReference*pColorAttachments;const struct VkAttachmentReference*pResolveAttachments;const struct VkAttachmentReference*pDepthStencilAttachment;unsigned int preserveAttachmentCount;const unsigned int*pPreserveAttachments;};
struct VkSubpassDependency {unsigned int srcSubpass;unsigned int dstSubpass;unsigned int srcStageMask;unsigned int dstStageMask;unsigned int srcAccessMask;unsigned int dstAccessMask;unsigned int dependencyFlags;};
struct VkRenderPassCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int attachmentCount;const struct VkAttachmentDescription*pAttachments;unsigned int subpassCount;const struct VkSubpassDescription*pSubpasses;unsigned int dependencyCount;const struct VkSubpassDependency*pDependencies;};
struct VkCommandPoolCreateInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int queueFamilyIndex;};
struct VkCommandBufferAllocateInfo {enum VkStructureType sType;const void*pNext;struct VkCommandPool_T*commandPool;enum VkCommandBufferLevel level;unsigned int commandBufferCount;};
struct VkCommandBufferInheritanceInfo {enum VkStructureType sType;const void*pNext;struct VkRenderPass_T*renderPass;unsigned int subpass;struct VkFramebuffer_T*framebuffer;unsigned int occlusionQueryEnable;unsigned int queryFlags;unsigned int pipelineStatistics;};
struct VkCommandBufferBeginInfo {enum VkStructureType sType;const void*pNext;unsigned int flags;const struct VkCommandBufferInheritanceInfo*pInheritanceInfo;};
struct VkBufferCopy {unsigned long srcOffset;unsigned long dstOffset;unsigned long size;};
struct VkImageSubresourceLayers {unsigned int aspectMask;unsigned int mipLevel;unsigned int baseArrayLayer;unsigned int layerCount;};
struct VkImageCopy {struct VkImageSubresourceLayers srcSubresource;struct VkOffset3D srcOffset;struct VkImageSubresourceLayers dstSubresource;struct VkOffset3D dstOffset;struct VkExtent3D extent;};
struct VkImageBlit {struct VkImageSubresourceLayers srcSubresource;struct VkOffset3D srcOffsets[2];struct VkImageSubresourceLayers dstSubresource;struct VkOffset3D dstOffsets[2];};
struct VkBufferImageCopy {unsigned long bufferOffset;unsigned int bufferRowLength;unsigned int bufferImageHeight;struct VkImageSubresourceLayers imageSubresource;struct VkOffset3D imageOffset;struct VkExtent3D imageExtent;};
union VkClearColorValue {float float32[4];int int32[4];unsigned int uint32[4];};
struct VkClearDepthStencilValue {float depth;unsigned int stencil;};
union VkClearValue {union VkClearColorValue color;struct VkClearDepthStencilValue depthStencil;};
struct VkClearAttachment {unsigned int aspectMask;unsigned int colorAttachment;union VkClearValue clearValue;};
struct VkClearRect {struct VkRect2D rect;unsigned int baseArrayLayer;unsigned int layerCount;};
struct VkImageResolve {struct VkImageSubresourceLayers srcSubresource;struct VkOffset3D srcOffset;struct VkImageSubresourceLayers dstSubresource;struct VkOffset3D dstOffset;struct VkExtent3D extent;};
struct VkMemoryBarrier {enum VkStructureType sType;const void*pNext;unsigned int srcAccessMask;unsigned int dstAccessMask;};
struct VkBufferMemoryBarrier {enum VkStructureType sType;const void*pNext;unsigned int srcAccessMask;unsigned int dstAccessMask;unsigned int srcQueueFamilyIndex;unsigned int dstQueueFamilyIndex;struct VkBuffer_T*buffer;unsigned long offset;unsigned long size;};
struct VkImageMemoryBarrier {enum VkStructureType sType;const void*pNext;unsigned int srcAccessMask;unsigned int dstAccessMask;enum VkImageLayout oldLayout;enum VkImageLayout newLayout;unsigned int srcQueueFamilyIndex;unsigned int dstQueueFamilyIndex;struct VkImage_T*image;struct VkImageSubresourceRange subresourceRange;};
struct VkRenderPassBeginInfo {enum VkStructureType sType;const void*pNext;struct VkRenderPass_T*renderPass;struct VkFramebuffer_T*framebuffer;struct VkRect2D renderArea;unsigned int clearValueCount;const union VkClearValue*pClearValues;};
struct VkSurfaceKHR_T {};
struct VkSurfaceCapabilitiesKHR {unsigned int minImageCount;unsigned int maxImageCount;struct VkExtent2D currentExtent;struct VkExtent2D minImageExtent;struct VkExtent2D maxImageExtent;unsigned int maxImageArrayLayers;unsigned int supportedTransforms;enum VkSurfaceTransformFlagBitsKHR currentTransform;unsigned int supportedCompositeAlpha;unsigned int supportedUsageFlags;};
struct VkSurfaceFormatKHR {enum VkFormat format;enum VkColorSpaceKHR colorSpace;};
struct VkSwapchainKHR_T {};
struct VkSwapchainCreateInfoKHR {enum VkStructureType sType;const void*pNext;unsigned int flags;struct VkSurfaceKHR_T*surface;unsigned int minImageCount;enum VkFormat imageFormat;enum VkColorSpaceKHR imageColorSpace;struct VkExtent2D imageExtent;unsigned int imageArrayLayers;unsigned int imageUsage;enum VkSharingMode imageSharingMode;unsigned int queueFamilyIndexCount;const unsigned int*pQueueFamilyIndices;enum VkSurfaceTransformFlagBitsKHR preTransform;enum VkCompositeAlphaFlagBitsKHR compositeAlpha;enum VkPresentModeKHR presentMode;unsigned int clipped;struct VkSwapchainKHR_T*oldSwapchain;};
struct VkPresentInfoKHR {enum VkStructureType sType;const void*pNext;unsigned int waitSemaphoreCount;struct VkSemaphore_T*const*pWaitSemaphores;unsigned int swapchainCount;struct VkSwapchainKHR_T*const*pSwapchains;const unsigned int*pImageIndices;enum VkResult*pResults;};
struct VkDisplayKHR_T {};
struct VkDisplayModeKHR_T {};
struct VkDisplayPropertiesKHR {struct VkDisplayKHR_T*display;const char*displayName;struct VkExtent2D physicalDimensions;struct VkExtent2D physicalResolution;unsigned int supportedTransforms;unsigned int planeReorderPossible;unsigned int persistentContent;};
struct VkDisplayModeParametersKHR {struct VkExtent2D visibleRegion;unsigned int refreshRate;};
struct VkDisplayModePropertiesKHR {struct VkDisplayModeKHR_T*displayMode;struct VkDisplayModeParametersKHR parameters;};
struct VkDisplayModeCreateInfoKHR {enum VkStructureType sType;const void*pNext;unsigned int flags;struct VkDisplayModeParametersKHR parameters;};
struct VkDisplayPlaneCapabilitiesKHR {unsigned int supportedAlpha;struct VkOffset2D minSrcPosition;struct VkOffset2D maxSrcPosition;struct VkExtent2D minSrcExtent;struct VkExtent2D maxSrcExtent;struct VkOffset2D minDstPosition;struct VkOffset2D maxDstPosition;struct VkExtent2D minDstExtent;struct VkExtent2D maxDstExtent;};
struct VkDisplayPlanePropertiesKHR {struct VkDisplayKHR_T*currentDisplay;unsigned int currentStackIndex;};
struct VkDisplaySurfaceCreateInfoKHR {enum VkStructureType sType;const void*pNext;unsigned int flags;struct VkDisplayModeKHR_T*displayMode;unsigned int planeIndex;unsigned int planeStackIndex;enum VkSurfaceTransformFlagBitsKHR transform;float globalAlpha;enum VkDisplayPlaneAlphaFlagBitsKHR alphaMode;struct VkExtent2D imageExtent;};
struct VkDebugReportCallbackEXT_T {};
struct VkDebugReportCallbackCreateInfoEXT {enum VkStructureType sType;const void*pNext;unsigned int flags;unsigned int(*pfnCallback)(unsigned int,enum VkDebugReportObjectTypeEXT,unsigned long,unsigned long,int,const char*,const char*,void*);void*pUserData;};
struct VkDebugMarkerObjectNameInfoEXT {enum VkStructureType sType;const void*pNext;enum VkDebugReportObjectTypeEXT objectType;unsigned long object;const char*pObjectName;};
struct VkDebugMarkerObjectTagInfoEXT {enum VkStructureType sType;const void*pNext;enum VkDebugReportObjectTypeEXT objectType;unsigned long object;unsigned long tagName;unsigned long tagSize;const void*pTag;};
struct VkDebugMarkerMarkerInfoEXT {enum VkStructureType sType;const void*pNext;const char*pMarkerName;float color[4];};
struct VkExternalImageFormatPropertiesNV {struct VkImageFormatProperties imageFormatProperties;unsigned int externalMemoryFeatures;unsigned int exportFromImportedHandleTypes;unsigned int compatibleHandleTypes;};
void(vkGetBufferMemoryRequirements)(struct VkDevice_T*,struct VkBuffer_T*,struct VkMemoryRequirements*);
enum VkResult(vkDeviceWaitIdle)(struct VkDevice_T*);
enum VkResult(vkCreateBufferView)(struct VkDevice_T*,const struct VkBufferViewCreateInfo*,const struct VkAllocationCallbacks*,struct VkBufferView_T**);
void(vkCmdCopyImageToBuffer)(struct VkCommandBuffer_T*,struct VkImage_T*,enum VkImageLayout,struct VkBuffer_T*,unsigned int,const struct VkBufferImageCopy*);
void(vkCmdResolveImage)(struct VkCommandBuffer_T*,struct VkImage_T*,enum VkImageLayout,struct VkImage_T*,enum VkImageLayout,unsigned int,const struct VkImageResolve*);
enum VkResult(vkCreateGraphicsPipelines)(struct VkDevice_T*,struct VkPipelineCache_T*,unsigned int,const struct VkGraphicsPipelineCreateInfo*,const struct VkAllocationCallbacks*,struct VkPipeline_T**);
void(vkCmdSetStencilCompareMask)(struct VkCommandBuffer_T*,unsigned int,unsigned int);
enum VkResult(vkGetPipelineCacheData)(struct VkDevice_T*,struct VkPipelineCache_T*,unsigned long*,void*);
void(vkGetRenderAreaGranularity)(struct VkDevice_T*,struct VkRenderPass_T*,struct VkExtent2D*);
void(vkDestroyInstance)(struct VkInstance_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkEnumerateInstanceLayerProperties)(unsigned int*,struct VkLayerProperties*);
enum VkResult(vkResetEvent)(struct VkDevice_T*,struct VkEvent_T*);
void(vkGetPhysicalDeviceQueueFamilyProperties)(struct VkPhysicalDevice_T*,unsigned int*,struct VkQueueFamilyProperties*);
enum VkResult(vkQueueWaitIdle)(struct VkQueue_T*);
enum VkResult(vkEnumeratePhysicalDevices)(struct VkInstance_T*,unsigned int*,struct VkPhysicalDevice_T**);
void(vkCmdWriteTimestamp)(struct VkCommandBuffer_T*,enum VkPipelineStageFlagBits,struct VkQueryPool_T*,unsigned int);
enum VkResult(vkCreateShaderModule)(struct VkDevice_T*,const struct VkShaderModuleCreateInfo*,const struct VkAllocationCallbacks*,struct VkShaderModule_T**);
void(vkDestroySurfaceKHR)(struct VkInstance_T*,struct VkSurfaceKHR_T*,const struct VkAllocationCallbacks*);
void(vkCmdCopyQueryPoolResults)(struct VkCommandBuffer_T*,struct VkQueryPool_T*,unsigned int,unsigned int,struct VkBuffer_T*,unsigned long,unsigned long,unsigned int);
enum VkResult(vkMergePipelineCaches)(struct VkDevice_T*,struct VkPipelineCache_T*,unsigned int,struct VkPipelineCache_T*const*);
void(vkCmdSetStencilWriteMask)(struct VkCommandBuffer_T*,unsigned int,unsigned int);
enum VkResult(vkCreateFramebuffer)(struct VkDevice_T*,const struct VkFramebufferCreateInfo*,const struct VkAllocationCallbacks*,struct VkFramebuffer_T**);
void(vkCmdResetEvent)(struct VkCommandBuffer_T*,struct VkEvent_T*,unsigned int);
enum VkResult(vkBindBufferMemory)(struct VkDevice_T*,struct VkBuffer_T*,struct VkDeviceMemory_T*,unsigned long);
void(vkCmdSetEvent)(struct VkCommandBuffer_T*,struct VkEvent_T*,unsigned int);
void(vkCmdBindDescriptorSets)(struct VkCommandBuffer_T*,enum VkPipelineBindPoint,struct VkPipelineLayout_T*,unsigned int,unsigned int,struct VkDescriptorSet_T*const*,unsigned int,const unsigned int*);
enum VkResult(vkEnumerateInstanceExtensionProperties)(const char*,unsigned int*,struct VkExtensionProperties*);
void(vkCmdSetDepthBounds)(struct VkCommandBuffer_T*,float,float);
void(vkCmdDispatchIndirect)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long);
void(vkDestroyEvent)(struct VkDevice_T*,struct VkEvent_T*,const struct VkAllocationCallbacks*);
void(vkCmdNextSubpass)(struct VkCommandBuffer_T*,enum VkSubpassContents);
void(vkCmdCopyBuffer)(struct VkCommandBuffer_T*,struct VkBuffer_T*,struct VkBuffer_T*,unsigned int,const struct VkBufferCopy*);
void(vkCmdDrawIndirectCountAMD)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long,struct VkBuffer_T*,unsigned long,unsigned int,unsigned int);
enum VkResult(vkGetDisplayPlaneSupportedDisplaysKHR)(struct VkPhysicalDevice_T*,unsigned int,unsigned int*,struct VkDisplayKHR_T**);
void(vkDestroyBuffer)(struct VkDevice_T*,struct VkBuffer_T*,const struct VkAllocationCallbacks*);
void(vkCmdCopyImage)(struct VkCommandBuffer_T*,struct VkImage_T*,enum VkImageLayout,struct VkImage_T*,enum VkImageLayout,unsigned int,const struct VkImageCopy*);
void(vkGetPhysicalDeviceSparseImageFormatProperties)(struct VkPhysicalDevice_T*,enum VkFormat,enum VkImageType,enum VkSampleCountFlagBits,unsigned int,enum VkImageTiling,unsigned int*,struct VkSparseImageFormatProperties*);
enum VkResult(vkCreateComputePipelines)(struct VkDevice_T*,struct VkPipelineCache_T*,unsigned int,const struct VkComputePipelineCreateInfo*,const struct VkAllocationCallbacks*,struct VkPipeline_T**);
enum VkResult(vkCreateDescriptorSetLayout)(struct VkDevice_T*,const struct VkDescriptorSetLayoutCreateInfo*,const struct VkAllocationCallbacks*,struct VkDescriptorSetLayout_T**);
enum VkResult(vkAllocateCommandBuffers)(struct VkDevice_T*,const struct VkCommandBufferAllocateInfo*,struct VkCommandBuffer_T**);
enum VkResult(vkGetPhysicalDeviceSurfaceFormatsKHR)(struct VkPhysicalDevice_T*,struct VkSurfaceKHR_T*,unsigned int*,struct VkSurfaceFormatKHR*);
void(vkDestroyQueryPool)(struct VkDevice_T*,struct VkQueryPool_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkCreateDescriptorPool)(struct VkDevice_T*,const struct VkDescriptorPoolCreateInfo*,const struct VkAllocationCallbacks*,struct VkDescriptorPool_T**);
void(vkGetImageSubresourceLayout)(struct VkDevice_T*,struct VkImage_T*,const struct VkImageSubresource*,struct VkSubresourceLayout*);
void(vkCmdUpdateBuffer)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long,unsigned long,const void*);
void(vkCmdSetStencilReference)(struct VkCommandBuffer_T*,unsigned int,unsigned int);
enum VkResult(vkCreateBuffer)(struct VkDevice_T*,const struct VkBufferCreateInfo*,const struct VkAllocationCallbacks*,struct VkBuffer_T**);
void(vkFreeCommandBuffers)(struct VkDevice_T*,struct VkCommandPool_T*,unsigned int,struct VkCommandBuffer_T*const*);
void(vkDestroyDebugReportCallbackEXT)(struct VkInstance_T*,struct VkDebugReportCallbackEXT_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkGetFenceStatus)(struct VkDevice_T*,struct VkFence_T*);
void(vkCmdBeginQuery)(struct VkCommandBuffer_T*,struct VkQueryPool_T*,unsigned int,unsigned int);
enum VkResult(vkGetPhysicalDeviceSurfaceCapabilitiesKHR)(struct VkPhysicalDevice_T*,struct VkSurfaceKHR_T*,struct VkSurfaceCapabilitiesKHR*);
void(vkDestroyPipeline)(struct VkDevice_T*,struct VkPipeline_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkQueueSubmit)(struct VkQueue_T*,unsigned int,const struct VkSubmitInfo*,struct VkFence_T*);
void(vkCmdBlitImage)(struct VkCommandBuffer_T*,struct VkImage_T*,enum VkImageLayout,struct VkImage_T*,enum VkImageLayout,unsigned int,const struct VkImageBlit*,enum VkFilter);
void(vkCmdDrawIndexedIndirect)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long,unsigned int,unsigned int);
void(vkCmdSetDepthBias)(struct VkCommandBuffer_T*,float,float,float);
enum VkResult(vkGetPhysicalDeviceSurfaceSupportKHR)(struct VkPhysicalDevice_T*,unsigned int,struct VkSurfaceKHR_T*,unsigned int*);
enum VkResult(vkCreateSemaphore)(struct VkDevice_T*,const struct VkSemaphoreCreateInfo*,const struct VkAllocationCallbacks*,struct VkSemaphore_T**);
void(vkDestroyShaderModule)(struct VkDevice_T*,struct VkShaderModule_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkCreatePipelineCache)(struct VkDevice_T*,const struct VkPipelineCacheCreateInfo*,const struct VkAllocationCallbacks*,struct VkPipelineCache_T**);
enum VkResult(vkCreateImageView)(struct VkDevice_T*,const struct VkImageViewCreateInfo*,const struct VkAllocationCallbacks*,struct VkImageView_T**);
void(vkGetPhysicalDeviceFeatures)(struct VkPhysicalDevice_T*,struct VkPhysicalDeviceFeatures*);
void(vkDestroyPipelineLayout)(struct VkDevice_T*,struct VkPipelineLayout_T*,const struct VkAllocationCallbacks*);
void(vkDestroySampler)(struct VkDevice_T*,struct VkSampler_T*,const struct VkAllocationCallbacks*);
void(vkFreeMemory)(struct VkDevice_T*,struct VkDeviceMemory_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkGetPhysicalDeviceImageFormatProperties)(struct VkPhysicalDevice_T*,enum VkFormat,enum VkImageType,enum VkImageTiling,unsigned int,unsigned int,struct VkImageFormatProperties*);
enum VkResult(vkMapMemory)(struct VkDevice_T*,struct VkDeviceMemory_T*,unsigned long,unsigned long,unsigned int,void**);
void(vkDestroyFramebuffer)(struct VkDevice_T*,struct VkFramebuffer_T*,const struct VkAllocationCallbacks*);
void(vkGetDeviceMemoryCommitment)(struct VkDevice_T*,struct VkDeviceMemory_T*,unsigned long*);
void(vkCmdCopyBufferToImage)(struct VkCommandBuffer_T*,struct VkBuffer_T*,struct VkImage_T*,enum VkImageLayout,unsigned int,const struct VkBufferImageCopy*);
void(vkCmdBindVertexBuffers)(struct VkCommandBuffer_T*,unsigned int,unsigned int,struct VkBuffer_T*const*,const unsigned long*);
void(vkDestroyCommandPool)(struct VkDevice_T*,struct VkCommandPool_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkInvalidateMappedMemoryRanges)(struct VkDevice_T*,unsigned int,const struct VkMappedMemoryRange*);
enum VkResult(vkGetDisplayPlaneCapabilitiesKHR)(struct VkPhysicalDevice_T*,struct VkDisplayModeKHR_T*,unsigned int,struct VkDisplayPlaneCapabilitiesKHR*);
void(vkCmdBindPipeline)(struct VkCommandBuffer_T*,enum VkPipelineBindPoint,struct VkPipeline_T*);
void(vkDestroyBufferView)(struct VkDevice_T*,struct VkBufferView_T*,const struct VkAllocationCallbacks*);
void(vkGetImageSparseMemoryRequirements)(struct VkDevice_T*,struct VkImage_T*,unsigned int*,struct VkSparseImageMemoryRequirements*);
void(vkDestroyImageView)(struct VkDevice_T*,struct VkImageView_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkResetCommandBuffer)(struct VkCommandBuffer_T*,unsigned int);
void(vkCmdDrawIndirect)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long,unsigned int,unsigned int);
enum VkResult(vkGetPhysicalDeviceExternalImageFormatPropertiesNV)(struct VkPhysicalDevice_T*,enum VkFormat,enum VkImageType,enum VkImageTiling,unsigned int,unsigned int,unsigned int,struct VkExternalImageFormatPropertiesNV*);
void(vkDestroySwapchainKHR)(struct VkDevice_T*,struct VkSwapchainKHR_T*,const struct VkAllocationCallbacks*);
void(*vkGetInstanceProcAddr(struct VkInstance_T*,const char*))();
void(vkGetImageMemoryRequirements)(struct VkDevice_T*,struct VkImage_T*,struct VkMemoryRequirements*);
void(vkDebugReportMessageEXT)(struct VkInstance_T*,unsigned int,enum VkDebugReportObjectTypeEXT,unsigned long,unsigned long,int,const char*,const char*);
enum VkResult(vkSetEvent)(struct VkDevice_T*,struct VkEvent_T*);
void(vkCmdDebugMarkerEndEXT)(struct VkCommandBuffer_T*);
enum VkResult(vkGetEventStatus)(struct VkDevice_T*,struct VkEvent_T*);
void(vkCmdDebugMarkerBeginEXT)(struct VkCommandBuffer_T*,struct VkDebugMarkerMarkerInfoEXT*);
enum VkResult(vkCreateDevice)(struct VkPhysicalDevice_T*,const struct VkDeviceCreateInfo*,const struct VkAllocationCallbacks*,struct VkDevice_T**);
enum VkResult(vkCreateInstance)(const struct VkInstanceCreateInfo*,const struct VkAllocationCallbacks*,struct VkInstance_T**);
void(vkCmdClearDepthStencilImage)(struct VkCommandBuffer_T*,struct VkImage_T*,enum VkImageLayout,const struct VkClearDepthStencilValue*,unsigned int,const struct VkImageSubresourceRange*);
void(vkCmdResetQueryPool)(struct VkCommandBuffer_T*,struct VkQueryPool_T*,unsigned int,unsigned int);
enum VkResult(vkBeginCommandBuffer)(struct VkCommandBuffer_T*,const struct VkCommandBufferBeginInfo*);
enum VkResult(vkDebugMarkerSetObjectTagEXT)(struct VkDevice_T*,struct VkDebugMarkerObjectTagInfoEXT*);
void(vkCmdDrawIndexed)(struct VkCommandBuffer_T*,unsigned int,unsigned int,unsigned int,int,unsigned int);
void(vkCmdDebugMarkerInsertEXT)(struct VkCommandBuffer_T*,struct VkDebugMarkerMarkerInfoEXT*);
enum VkResult(vkGetPhysicalDeviceDisplayPlanePropertiesKHR)(struct VkPhysicalDevice_T*,unsigned int*,struct VkDisplayPlanePropertiesKHR*);
void(vkCmdFillBuffer)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long,unsigned long,unsigned int);
enum VkResult(vkCreateDebugReportCallbackEXT)(struct VkInstance_T*,const struct VkDebugReportCallbackCreateInfoEXT*,const struct VkAllocationCallbacks*,struct VkDebugReportCallbackEXT_T**);
void(vkGetDeviceQueue)(struct VkDevice_T*,unsigned int,unsigned int,struct VkQueue_T**);
enum VkResult(vkCreateSharedSwapchainsKHR)(struct VkDevice_T*,unsigned int,const struct VkSwapchainCreateInfoKHR*,const struct VkAllocationCallbacks*,struct VkSwapchainKHR_T**);
enum VkResult(vkCreateDisplayPlaneSurfaceKHR)(struct VkInstance_T*,const struct VkDisplaySurfaceCreateInfoKHR*,const struct VkAllocationCallbacks*,struct VkSurfaceKHR_T**);
void(vkCmdWaitEvents)(struct VkCommandBuffer_T*,unsigned int,struct VkEvent_T*const*,unsigned int,unsigned int,unsigned int,const struct VkMemoryBarrier*,unsigned int,const struct VkBufferMemoryBarrier*,unsigned int,const struct VkImageMemoryBarrier*);
void(vkCmdEndRenderPass)(struct VkCommandBuffer_T*);
void(vkCmdDrawIndexedIndirectCountAMD)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long,struct VkBuffer_T*,unsigned long,unsigned int,unsigned int);
enum VkResult(vkGetPhysicalDeviceDisplayPropertiesKHR)(struct VkPhysicalDevice_T*,unsigned int*,struct VkDisplayPropertiesKHR*);
enum VkResult(vkQueuePresentKHR)(struct VkQueue_T*,const struct VkPresentInfoKHR*);
enum VkResult(vkAcquireNextImageKHR)(struct VkDevice_T*,struct VkSwapchainKHR_T*,unsigned long,struct VkSemaphore_T*,struct VkFence_T*,unsigned int*);
void(vkDestroyFence)(struct VkDevice_T*,struct VkFence_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkGetSwapchainImagesKHR)(struct VkDevice_T*,struct VkSwapchainKHR_T*,unsigned int*,struct VkImage_T**);
enum VkResult(vkCreateImage)(struct VkDevice_T*,const struct VkImageCreateInfo*,const struct VkAllocationCallbacks*,struct VkImage_T**);
enum VkResult(vkGetDisplayModePropertiesKHR)(struct VkPhysicalDevice_T*,struct VkDisplayKHR_T*,unsigned int*,struct VkDisplayModePropertiesKHR*);
enum VkResult(vkCreateSwapchainKHR)(struct VkDevice_T*,const struct VkSwapchainCreateInfoKHR*,const struct VkAllocationCallbacks*,struct VkSwapchainKHR_T**);
enum VkResult(vkGetPhysicalDeviceSurfacePresentModesKHR)(struct VkPhysicalDevice_T*,struct VkSurfaceKHR_T*,unsigned int*,enum VkPresentModeKHR*);
enum VkResult(vkAllocateMemory)(struct VkDevice_T*,const struct VkMemoryAllocateInfo*,const struct VkAllocationCallbacks*,struct VkDeviceMemory_T**);
void(vkCmdClearColorImage)(struct VkCommandBuffer_T*,struct VkImage_T*,enum VkImageLayout,const union VkClearColorValue*,unsigned int,const struct VkImageSubresourceRange*);
void(vkCmdExecuteCommands)(struct VkCommandBuffer_T*,unsigned int,struct VkCommandBuffer_T*const*);
enum VkResult(vkCreateDisplayModeKHR)(struct VkPhysicalDevice_T*,struct VkDisplayKHR_T*,const struct VkDisplayModeCreateInfoKHR*,const struct VkAllocationCallbacks*,struct VkDisplayModeKHR_T**);
void(vkCmdBeginRenderPass)(struct VkCommandBuffer_T*,const struct VkRenderPassBeginInfo*,enum VkSubpassContents);
void(vkCmdClearAttachments)(struct VkCommandBuffer_T*,unsigned int,const struct VkClearAttachment*,unsigned int,const struct VkClearRect*);
void(vkCmdPushConstants)(struct VkCommandBuffer_T*,struct VkPipelineLayout_T*,unsigned int,unsigned int,unsigned int,const void*);
enum VkResult(vkDebugMarkerSetObjectNameEXT)(struct VkDevice_T*,struct VkDebugMarkerObjectNameInfoEXT*);
void(vkCmdEndQuery)(struct VkCommandBuffer_T*,struct VkQueryPool_T*,unsigned int);
enum VkResult(vkCreateFence)(struct VkDevice_T*,const struct VkFenceCreateInfo*,const struct VkAllocationCallbacks*,struct VkFence_T**);
void(vkCmdBindIndexBuffer)(struct VkCommandBuffer_T*,struct VkBuffer_T*,unsigned long,enum VkIndexType);
enum VkResult(vkEndCommandBuffer)(struct VkCommandBuffer_T*);
enum VkResult(vkCreateRenderPass)(struct VkDevice_T*,const struct VkRenderPassCreateInfo*,const struct VkAllocationCallbacks*,struct VkRenderPass_T**);
void(vkDestroyImage)(struct VkDevice_T*,struct VkImage_T*,const struct VkAllocationCallbacks*);
void(vkDestroySemaphore)(struct VkDevice_T*,struct VkSemaphore_T*,const struct VkAllocationCallbacks*);
void(vkCmdSetBlendConstants)(struct VkCommandBuffer_T*,const float);
enum VkResult(vkEnumerateDeviceLayerProperties)(struct VkPhysicalDevice_T*,unsigned int*,struct VkLayerProperties*);
void(vkDestroyPipelineCache)(struct VkDevice_T*,struct VkPipelineCache_T*,const struct VkAllocationCallbacks*);
void(*vkGetDeviceProcAddr(struct VkDevice_T*,const char*))();
enum VkResult(vkBindImageMemory)(struct VkDevice_T*,struct VkImage_T*,struct VkDeviceMemory_T*,unsigned long);
void(vkDestroyRenderPass)(struct VkDevice_T*,struct VkRenderPass_T*,const struct VkAllocationCallbacks*);
void(vkUnmapMemory)(struct VkDevice_T*,struct VkDeviceMemory_T*);
void(vkDestroyDescriptorPool)(struct VkDevice_T*,struct VkDescriptorPool_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkEnumerateDeviceExtensionProperties)(struct VkPhysicalDevice_T*,const char*,unsigned int*,struct VkExtensionProperties*);
void(vkGetPhysicalDeviceProperties)(struct VkPhysicalDevice_T*,struct VkPhysicalDeviceProperties*);
enum VkResult(vkCreateQueryPool)(struct VkDevice_T*,const struct VkQueryPoolCreateInfo*,const struct VkAllocationCallbacks*,struct VkQueryPool_T**);
void(vkCmdDispatch)(struct VkCommandBuffer_T*,unsigned int,unsigned int,unsigned int);
void(vkGetPhysicalDeviceFormatProperties)(struct VkPhysicalDevice_T*,enum VkFormat,struct VkFormatProperties*);
enum VkResult(vkResetDescriptorPool)(struct VkDevice_T*,struct VkDescriptorPool_T*,unsigned int);
enum VkResult(vkWaitForFences)(struct VkDevice_T*,unsigned int,struct VkFence_T*const*,unsigned int,unsigned long);
void(vkCmdSetLineWidth)(struct VkCommandBuffer_T*,float);
enum VkResult(vkResetFences)(struct VkDevice_T*,unsigned int,struct VkFence_T*const*);
enum VkResult(vkCreateSampler)(struct VkDevice_T*,const struct VkSamplerCreateInfo*,const struct VkAllocationCallbacks*,struct VkSampler_T**);
void(vkDestroyDescriptorSetLayout)(struct VkDevice_T*,struct VkDescriptorSetLayout_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkFlushMappedMemoryRanges)(struct VkDevice_T*,unsigned int,const struct VkMappedMemoryRange*);
void(vkDestroyDevice)(struct VkDevice_T*,const struct VkAllocationCallbacks*);
enum VkResult(vkFreeDescriptorSets)(struct VkDevice_T*,struct VkDescriptorPool_T*,unsigned int,struct VkDescriptorSet_T*const*);
void(vkCmdDraw)(struct VkCommandBuffer_T*,unsigned int,unsigned int,unsigned int,unsigned int);
enum VkResult(vkCreateCommandPool)(struct VkDevice_T*,const struct VkCommandPoolCreateInfo*,const struct VkAllocationCallbacks*,struct VkCommandPool_T**);
enum VkResult(vkCreateEvent)(struct VkDevice_T*,const struct VkEventCreateInfo*,const struct VkAllocationCallbacks*,struct VkEvent_T**);
void(vkGetPhysicalDeviceMemoryProperties)(struct VkPhysicalDevice_T*,struct VkPhysicalDeviceMemoryProperties*);
enum VkResult(vkAllocateDescriptorSets)(struct VkDevice_T*,const struct VkDescriptorSetAllocateInfo*,struct VkDescriptorSet_T**);
void(vkCmdSetScissor)(struct VkCommandBuffer_T*,unsigned int,unsigned int,const struct VkRect2D*);
enum VkResult(vkCreatePipelineLayout)(struct VkDevice_T*,const struct VkPipelineLayoutCreateInfo*,const struct VkAllocationCallbacks*,struct VkPipelineLayout_T**);
enum VkResult(vkQueueBindSparse)(struct VkQueue_T*,unsigned int,const struct VkBindSparseInfo*,struct VkFence_T*);
void(vkUpdateDescriptorSets)(struct VkDevice_T*,unsigned int,const struct VkWriteDescriptorSet*,unsigned int,const struct VkCopyDescriptorSet*);
enum VkResult(vkGetQueryPoolResults)(struct VkDevice_T*,struct VkQueryPool_T*,unsigned int,unsigned int,unsigned long,void*,unsigned long,unsigned int);
void(vkCmdPipelineBarrier)(struct VkCommandBuffer_T*,unsigned int,unsigned int,unsigned int,unsigned int,const struct VkMemoryBarrier*,unsigned int,const struct VkBufferMemoryBarrier*,unsigned int,const struct VkImageMemoryBarrier*);
enum VkResult(vkResetCommandPool)(struct VkDevice_T*,struct VkCommandPool_T*,unsigned int);
void(vkCmdSetViewport)(struct VkCommandBuffer_T*,unsigned int,unsigned int,const struct VkViewport*);
]])
local CLIB = ffi.load(_G.FFI_LIB or "vulkan")
local library = {}
library = {
	GetBufferMemoryRequirements = CLIB.vkGetBufferMemoryRequirements,
	DeviceWaitIdle = CLIB.vkDeviceWaitIdle,
	CreateBufferView = CLIB.vkCreateBufferView,
	CmdCopyImageToBuffer = CLIB.vkCmdCopyImageToBuffer,
	CmdResolveImage = CLIB.vkCmdResolveImage,
	CreateGraphicsPipelines = CLIB.vkCreateGraphicsPipelines,
	CmdSetStencilCompareMask = CLIB.vkCmdSetStencilCompareMask,
	GetPipelineCacheData = CLIB.vkGetPipelineCacheData,
	GetRenderAreaGranularity = CLIB.vkGetRenderAreaGranularity,
	DestroyInstance = CLIB.vkDestroyInstance,
	EnumerateInstanceLayerProperties = CLIB.vkEnumerateInstanceLayerProperties,
	ResetEvent = CLIB.vkResetEvent,
	GetPhysicalDeviceQueueFamilyProperties = CLIB.vkGetPhysicalDeviceQueueFamilyProperties,
	QueueWaitIdle = CLIB.vkQueueWaitIdle,
	EnumeratePhysicalDevices = CLIB.vkEnumeratePhysicalDevices,
	CmdWriteTimestamp = CLIB.vkCmdWriteTimestamp,
	CreateShaderModule = CLIB.vkCreateShaderModule,
	CmdCopyQueryPoolResults = CLIB.vkCmdCopyQueryPoolResults,
	MergePipelineCaches = CLIB.vkMergePipelineCaches,
	CmdSetStencilWriteMask = CLIB.vkCmdSetStencilWriteMask,
	CreateFramebuffer = CLIB.vkCreateFramebuffer,
	CmdResetEvent = CLIB.vkCmdResetEvent,
	BindBufferMemory = CLIB.vkBindBufferMemory,
	CmdSetEvent = CLIB.vkCmdSetEvent,
	CmdBindDescriptorSets = CLIB.vkCmdBindDescriptorSets,
	EnumerateInstanceExtensionProperties = CLIB.vkEnumerateInstanceExtensionProperties,
	CmdSetDepthBounds = CLIB.vkCmdSetDepthBounds,
	CmdDispatchIndirect = CLIB.vkCmdDispatchIndirect,
	DestroyEvent = CLIB.vkDestroyEvent,
	CmdNextSubpass = CLIB.vkCmdNextSubpass,
	CmdCopyBuffer = CLIB.vkCmdCopyBuffer,
	DestroyBuffer = CLIB.vkDestroyBuffer,
	CmdCopyImage = CLIB.vkCmdCopyImage,
	GetPhysicalDeviceSparseImageFormatProperties = CLIB.vkGetPhysicalDeviceSparseImageFormatProperties,
	CreateComputePipelines = CLIB.vkCreateComputePipelines,
	CreateDescriptorSetLayout = CLIB.vkCreateDescriptorSetLayout,
	AllocateCommandBuffers = CLIB.vkAllocateCommandBuffers,
	DestroyQueryPool = CLIB.vkDestroyQueryPool,
	CreateDescriptorPool = CLIB.vkCreateDescriptorPool,
	GetImageSubresourceLayout = CLIB.vkGetImageSubresourceLayout,
	CmdUpdateBuffer = CLIB.vkCmdUpdateBuffer,
	CmdSetStencilReference = CLIB.vkCmdSetStencilReference,
	CreateBuffer = CLIB.vkCreateBuffer,
	FreeCommandBuffers = CLIB.vkFreeCommandBuffers,
	GetFenceStatus = CLIB.vkGetFenceStatus,
	CmdBeginQuery = CLIB.vkCmdBeginQuery,
	DestroyPipeline = CLIB.vkDestroyPipeline,
	QueueSubmit = CLIB.vkQueueSubmit,
	CmdBlitImage = CLIB.vkCmdBlitImage,
	CmdDrawIndexedIndirect = CLIB.vkCmdDrawIndexedIndirect,
	CmdSetDepthBias = CLIB.vkCmdSetDepthBias,
	CreateSemaphore = CLIB.vkCreateSemaphore,
	DestroyShaderModule = CLIB.vkDestroyShaderModule,
	CreatePipelineCache = CLIB.vkCreatePipelineCache,
	CreateImageView = CLIB.vkCreateImageView,
	GetPhysicalDeviceFeatures = CLIB.vkGetPhysicalDeviceFeatures,
	DestroyPipelineLayout = CLIB.vkDestroyPipelineLayout,
	DestroySampler = CLIB.vkDestroySampler,
	FreeMemory = CLIB.vkFreeMemory,
	GetPhysicalDeviceImageFormatProperties = CLIB.vkGetPhysicalDeviceImageFormatProperties,
	MapMemory = CLIB.vkMapMemory,
	DestroyFramebuffer = CLIB.vkDestroyFramebuffer,
	GetDeviceMemoryCommitment = CLIB.vkGetDeviceMemoryCommitment,
	CmdCopyBufferToImage = CLIB.vkCmdCopyBufferToImage,
	CmdBindVertexBuffers = CLIB.vkCmdBindVertexBuffers,
	DestroyCommandPool = CLIB.vkDestroyCommandPool,
	InvalidateMappedMemoryRanges = CLIB.vkInvalidateMappedMemoryRanges,
	CmdBindPipeline = CLIB.vkCmdBindPipeline,
	DestroyBufferView = CLIB.vkDestroyBufferView,
	GetImageSparseMemoryRequirements = CLIB.vkGetImageSparseMemoryRequirements,
	DestroyImageView = CLIB.vkDestroyImageView,
	ResetCommandBuffer = CLIB.vkResetCommandBuffer,
	CmdDrawIndirect = CLIB.vkCmdDrawIndirect,
	GetInstanceProcAddr = CLIB.vkGetInstanceProcAddr,
	GetImageMemoryRequirements = CLIB.vkGetImageMemoryRequirements,
	SetEvent = CLIB.vkSetEvent,
	GetEventStatus = CLIB.vkGetEventStatus,
	CreateDevice = CLIB.vkCreateDevice,
	CreateInstance = CLIB.vkCreateInstance,
	CmdClearDepthStencilImage = CLIB.vkCmdClearDepthStencilImage,
	CmdResetQueryPool = CLIB.vkCmdResetQueryPool,
	BeginCommandBuffer = CLIB.vkBeginCommandBuffer,
	CmdDrawIndexed = CLIB.vkCmdDrawIndexed,
	CmdFillBuffer = CLIB.vkCmdFillBuffer,
	GetDeviceQueue = CLIB.vkGetDeviceQueue,
	CmdWaitEvents = CLIB.vkCmdWaitEvents,
	CmdEndRenderPass = CLIB.vkCmdEndRenderPass,
	DestroyFence = CLIB.vkDestroyFence,
	CreateImage = CLIB.vkCreateImage,
	AllocateMemory = CLIB.vkAllocateMemory,
	CmdClearColorImage = CLIB.vkCmdClearColorImage,
	CmdExecuteCommands = CLIB.vkCmdExecuteCommands,
	CmdBeginRenderPass = CLIB.vkCmdBeginRenderPass,
	CmdClearAttachments = CLIB.vkCmdClearAttachments,
	CmdPushConstants = CLIB.vkCmdPushConstants,
	CmdEndQuery = CLIB.vkCmdEndQuery,
	CreateFence = CLIB.vkCreateFence,
	CmdBindIndexBuffer = CLIB.vkCmdBindIndexBuffer,
	EndCommandBuffer = CLIB.vkEndCommandBuffer,
	CreateRenderPass = CLIB.vkCreateRenderPass,
	DestroyImage = CLIB.vkDestroyImage,
	DestroySemaphore = CLIB.vkDestroySemaphore,
	CmdSetBlendConstants = CLIB.vkCmdSetBlendConstants,
	EnumerateDeviceLayerProperties = CLIB.vkEnumerateDeviceLayerProperties,
	DestroyPipelineCache = CLIB.vkDestroyPipelineCache,
	GetDeviceProcAddr = CLIB.vkGetDeviceProcAddr,
	BindImageMemory = CLIB.vkBindImageMemory,
	DestroyRenderPass = CLIB.vkDestroyRenderPass,
	UnmapMemory = CLIB.vkUnmapMemory,
	DestroyDescriptorPool = CLIB.vkDestroyDescriptorPool,
	EnumerateDeviceExtensionProperties = CLIB.vkEnumerateDeviceExtensionProperties,
	GetPhysicalDeviceProperties = CLIB.vkGetPhysicalDeviceProperties,
	CreateQueryPool = CLIB.vkCreateQueryPool,
	CmdDispatch = CLIB.vkCmdDispatch,
	GetPhysicalDeviceFormatProperties = CLIB.vkGetPhysicalDeviceFormatProperties,
	ResetDescriptorPool = CLIB.vkResetDescriptorPool,
	WaitForFences = CLIB.vkWaitForFences,
	CmdSetLineWidth = CLIB.vkCmdSetLineWidth,
	ResetFences = CLIB.vkResetFences,
	CreateSampler = CLIB.vkCreateSampler,
	DestroyDescriptorSetLayout = CLIB.vkDestroyDescriptorSetLayout,
	FlushMappedMemoryRanges = CLIB.vkFlushMappedMemoryRanges,
	DestroyDevice = CLIB.vkDestroyDevice,
	FreeDescriptorSets = CLIB.vkFreeDescriptorSets,
	CmdDraw = CLIB.vkCmdDraw,
	CreateCommandPool = CLIB.vkCreateCommandPool,
	CreateEvent = CLIB.vkCreateEvent,
	GetPhysicalDeviceMemoryProperties = CLIB.vkGetPhysicalDeviceMemoryProperties,
	AllocateDescriptorSets = CLIB.vkAllocateDescriptorSets,
	CmdSetScissor = CLIB.vkCmdSetScissor,
	CreatePipelineLayout = CLIB.vkCreatePipelineLayout,
	QueueBindSparse = CLIB.vkQueueBindSparse,
	UpdateDescriptorSets = CLIB.vkUpdateDescriptorSets,
	GetQueryPoolResults = CLIB.vkGetQueryPoolResults,
	CmdPipelineBarrier = CLIB.vkCmdPipelineBarrier,
	ResetCommandPool = CLIB.vkResetCommandPool,
	CmdSetViewport = CLIB.vkCmdSetViewport,
}
library.util = {}
function library.util.StringList(tbl)
	return ffi.new("const char * const ["..#tbl.."]", tbl), #tbl
end
function library.util.GLSLToSpirV(type, glsl)
	local glsl_name = os.tmpname() .. "." .. type
	local spirv_name = os.tmpname()

	local temp

	temp = io.open(glsl_name, "wb")
	temp:write(glsl)
	temp:close()

	local msg = io.popen("glslangValidator -V -o " .. spirv_name .. " " .. glsl_name):read("*all")

	temp = io.open(spirv_name, "rb")
	local spirv = temp:read("*all")
	temp:close()

	if msg:find("ERROR") then
		error(msg, 2)
	end

	return {pCode = ffi.cast("uint32_t *", spirv), codeSize = #spirv}
end
function library.e(str_enum)
	return ffi.cast("enum GLFWenum", str_enum)
end
library.struct_gc = setmetatable({},{__mode = "k"})
library.macros = {}
library.macros.MAKE_VERSION = function(major, minor, patch) return bit.bor(bit.lshift(major, 22), bit.lshift(minor, 12) , patch) end
local extensions = {}
extensions.vkDestroySurfaceKHR = {ctype = ffi.typeof("void(* )( struct VkInstance_T * , struct VkSurfaceKHR_T * , const struct VkAllocationCallbacks * )")}
extensions.vkCmdDrawIndirectCountAMD = {ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * , struct VkBuffer_T * , unsigned long , struct VkBuffer_T * , unsigned long , unsigned int , unsigned int )")}
extensions.vkGetDisplayPlaneSupportedDisplaysKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , unsigned int , unsigned int * , struct VkDisplayKHR_T * * )")}
extensions.vkGetPhysicalDeviceSurfaceFormatsKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkSurfaceKHR_T * , unsigned int * , struct VkSurfaceFormatKHR * )")}
extensions.vkDestroyDebugReportCallbackEXT = {ctype = ffi.typeof("void(* )( struct VkInstance_T * , struct VkDebugReportCallbackEXT_T * , const struct VkAllocationCallbacks * )")}
extensions.vkGetPhysicalDeviceSurfaceCapabilitiesKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkSurfaceKHR_T * , struct VkSurfaceCapabilitiesKHR * )")}
extensions.vkGetPhysicalDeviceSurfaceSupportKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , unsigned int , struct VkSurfaceKHR_T * , unsigned int * )")}
extensions.vkGetDisplayPlaneCapabilitiesKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkDisplayModeKHR_T * , unsigned int , struct VkDisplayPlaneCapabilitiesKHR * )")}
extensions.vkGetPhysicalDeviceExternalImageFormatPropertiesNV = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , enum VkFormat , enum VkImageType , enum VkImageTiling , unsigned int , unsigned int , unsigned int , struct VkExternalImageFormatPropertiesNV * )")}
extensions.vkDestroySwapchainKHR = {ctype = ffi.typeof("void(* )( struct VkDevice_T * , struct VkSwapchainKHR_T * , const struct VkAllocationCallbacks * )")}
extensions.vkDebugReportMessageEXT = {ctype = ffi.typeof("void(* )( struct VkInstance_T * , unsigned int , enum VkDebugReportObjectTypeEXT , unsigned long , unsigned long , int , const char * , const char * )")}
extensions.vkCmdDebugMarkerEndEXT = {ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * )")}
extensions.vkCmdDebugMarkerBeginEXT = {ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * , struct VkDebugMarkerMarkerInfoEXT * )")}
extensions.vkDebugMarkerSetObjectTagEXT = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , struct VkDebugMarkerObjectTagInfoEXT * )")}
extensions.vkCmdDebugMarkerInsertEXT = {ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * , struct VkDebugMarkerMarkerInfoEXT * )")}
extensions.vkGetPhysicalDeviceDisplayPlanePropertiesKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , unsigned int * , struct VkDisplayPlanePropertiesKHR * )")}
extensions.vkCreateDebugReportCallbackEXT = {ctype = ffi.typeof("enum VkResult(* )( struct VkInstance_T * , const struct VkDebugReportCallbackCreateInfoEXT * , const struct VkAllocationCallbacks * , struct VkDebugReportCallbackEXT_T * * )")}
extensions.vkCreateSharedSwapchainsKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , unsigned int , const struct VkSwapchainCreateInfoKHR * , const struct VkAllocationCallbacks * , struct VkSwapchainKHR_T * * )")}
extensions.vkCreateDisplayPlaneSurfaceKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkInstance_T * , const struct VkDisplaySurfaceCreateInfoKHR * , const struct VkAllocationCallbacks * , struct VkSurfaceKHR_T * * )")}
extensions.vkCmdDrawIndexedIndirectCountAMD = {ctype = ffi.typeof("void(* )( struct VkCommandBuffer_T * , struct VkBuffer_T * , unsigned long , struct VkBuffer_T * , unsigned long , unsigned int , unsigned int )")}
extensions.vkGetPhysicalDeviceDisplayPropertiesKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , unsigned int * , struct VkDisplayPropertiesKHR * )")}
extensions.vkQueuePresentKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkQueue_T * , const struct VkPresentInfoKHR * )")}
extensions.vkAcquireNextImageKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , struct VkSwapchainKHR_T * , unsigned long , struct VkSemaphore_T * , struct VkFence_T * , unsigned int * )")}
extensions.vkGetSwapchainImagesKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , struct VkSwapchainKHR_T * , unsigned int * , struct VkImage_T * * )")}
extensions.vkGetDisplayModePropertiesKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkDisplayKHR_T * , unsigned int * , struct VkDisplayModePropertiesKHR * )")}
extensions.vkCreateSwapchainKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , const struct VkSwapchainCreateInfoKHR * , const struct VkAllocationCallbacks * , struct VkSwapchainKHR_T * * )")}
extensions.vkGetPhysicalDeviceSurfacePresentModesKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkSurfaceKHR_T * , unsigned int * , enum VkPresentModeKHR * )")}
extensions.vkCreateDisplayModeKHR = {ctype = ffi.typeof("enum VkResult(* )( struct VkPhysicalDevice_T * , struct VkDisplayKHR_T * , const struct VkDisplayModeCreateInfoKHR * , const struct VkAllocationCallbacks * , struct VkDisplayModeKHR_T * * )")}
extensions.vkDebugMarkerSetObjectNameEXT = {ctype = ffi.typeof("enum VkResult(* )( struct VkDevice_T * , struct VkDebugMarkerObjectNameInfoEXT * )")}
local function load(func, ptr, ext, decl, name)
	if extensions[ext] and not decl and not name then
		decl = extensions[ext].ctype
	end

	local ptr = func(ptr, ext)

	if ptr ~= nil then
		name = name or ext:match("^vk(.+)")

		local func = ffi.cast(decl, ptr)

		library[name] = func

		return func
	end
end

library.util.LoadInstanceProcAddr = function(...) return load(CLIB.vkGetInstanceProcAddr, ...) end
library.util.LoadDeviceProcAddr = function(...) return load(CLIB.vkGetDeviceProcAddr, ...) end
library.e = {
	LOD_CLAMP_NONE = 1000.0,
	REMAINING_MIP_LEVELS = 0xFFFFFFFF,
	REMAINING_ARRAY_LAYERS = 0xFFFFFFFF,
	WHOLE_SIZE = 0xFFFFFFFFFFFFFFFFULL,
	ATTACHMENT_UNUSED = 0xFFFFFFFF,
	TRUE = 1,
	FALSE = 0,
	QUEUE_FAMILY_IGNORED = 0xFFFFFFFF,
	SUBPASS_EXTERNAL = 0xFFFFFFFF,
	MAX_PHYSICAL_DEVICE_NAME_SIZE = 256,
	UUID_SIZE = 16,
	MAX_MEMORY_TYPES = 32,
	MAX_MEMORY_HEAPS = 16,
	MAX_EXTENSION_NAME_SIZE = 256,
	MAX_DESCRIPTION_SIZE = 256,
	DYNAMIC_STATE_VIEWPORT = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_VIEWPORT"),
	DYNAMIC_STATE_SCISSOR = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_SCISSOR"),
	DYNAMIC_STATE_LINE_WIDTH = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_LINE_WIDTH"),
	DYNAMIC_STATE_DEPTH_BIAS = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_DEPTH_BIAS"),
	DYNAMIC_STATE_BLEND_CONSTANTS = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_BLEND_CONSTANTS"),
	DYNAMIC_STATE_DEPTH_BOUNDS = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_DEPTH_BOUNDS"),
	DYNAMIC_STATE_STENCIL_COMPARE_MASK = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK"),
	DYNAMIC_STATE_STENCIL_WRITE_MASK = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK"),
	DYNAMIC_STATE_STENCIL_REFERENCE = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_STENCIL_REFERENCE"),
	DYNAMIC_STATE_BEGIN_RANGE = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_BEGIN_RANGE"),
	DYNAMIC_STATE_END_RANGE = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_END_RANGE"),
	DYNAMIC_STATE_RANGE_SIZE = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_RANGE_SIZE"),
	DYNAMIC_STATE_MAX_ENUM = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_MAX_ENUM"),
	IMAGE_LAYOUT_UNDEFINED = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_UNDEFINED"),
	IMAGE_LAYOUT_GENERAL = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_GENERAL"),
	IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL"),
	IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL"),
	IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL"),
	IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL"),
	IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL"),
	IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),
	IMAGE_LAYOUT_PREINITIALIZED = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_PREINITIALIZED"),
	IMAGE_LAYOUT_PRESENT_SRC_KHR = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR"),
	IMAGE_LAYOUT_BEGIN_RANGE = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_BEGIN_RANGE"),
	IMAGE_LAYOUT_END_RANGE = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_END_RANGE"),
	IMAGE_LAYOUT_RANGE_SIZE = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_RANGE_SIZE"),
	IMAGE_LAYOUT_MAX_ENUM = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_MAX_ENUM"),
	SAMPLER_MIPMAP_MODE_NEAREST = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_NEAREST"),
	SAMPLER_MIPMAP_MODE_LINEAR = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_LINEAR"),
	SAMPLER_MIPMAP_MODE_BEGIN_RANGE = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE"),
	SAMPLER_MIPMAP_MODE_END_RANGE = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_END_RANGE"),
	SAMPLER_MIPMAP_MODE_RANGE_SIZE = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE"),
	SAMPLER_MIPMAP_MODE_MAX_ENUM = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_MAX_ENUM"),
	INDEX_TYPE_UINT16 = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_UINT16"),
	INDEX_TYPE_UINT32 = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_UINT32"),
	INDEX_TYPE_BEGIN_RANGE = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_BEGIN_RANGE"),
	INDEX_TYPE_END_RANGE = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_END_RANGE"),
	INDEX_TYPE_RANGE_SIZE = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_RANGE_SIZE"),
	INDEX_TYPE_MAX_ENUM = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_MAX_ENUM"),
	CULL_MODE_NONE = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_NONE"),
	CULL_MODE_FRONT_BIT = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_FRONT_BIT"),
	CULL_MODE_BACK_BIT = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_BACK_BIT"),
	CULL_MODE_FRONT_AND_BACK = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_FRONT_AND_BACK"),
	CULL_MODE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_FLAG_BITS_MAX_ENUM"),
	PIPELINE_STAGE_TOP_OF_PIPE_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT"),
	PIPELINE_STAGE_DRAW_INDIRECT_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT"),
	PIPELINE_STAGE_VERTEX_INPUT_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT"),
	PIPELINE_STAGE_VERTEX_SHADER_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT"),
	PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT"),
	PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"),
	PIPELINE_STAGE_GEOMETRY_SHADER_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"),
	PIPELINE_STAGE_FRAGMENT_SHADER_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT"),
	PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT"),
	PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT"),
	PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT"),
	PIPELINE_STAGE_COMPUTE_SHADER_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT"),
	PIPELINE_STAGE_TRANSFER_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_TRANSFER_BIT"),
	PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT"),
	PIPELINE_STAGE_HOST_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_HOST_BIT"),
	PIPELINE_STAGE_ALL_GRAPHICS_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT"),
	PIPELINE_STAGE_ALL_COMMANDS_BIT = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT"),
	PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM"),
	IMAGE_USAGE_TRANSFER_SRC_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_TRANSFER_SRC_BIT"),
	IMAGE_USAGE_TRANSFER_DST_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_TRANSFER_DST_BIT"),
	IMAGE_USAGE_SAMPLED_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_SAMPLED_BIT"),
	IMAGE_USAGE_STORAGE_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_STORAGE_BIT"),
	IMAGE_USAGE_COLOR_ATTACHMENT_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT"),
	IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT"),
	IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT"),
	IMAGE_USAGE_INPUT_ATTACHMENT_BIT = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT"),
	IMAGE_USAGE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM"),
	COMMAND_POOL_CREATE_TRANSIENT_BIT = ffi.cast("enum VkCommandPoolCreateFlagBits", "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT"),
	COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = ffi.cast("enum VkCommandPoolCreateFlagBits", "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"),
	COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkCommandPoolCreateFlagBits", "VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM"),
	DEPENDENCY_BY_REGION_BIT = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_BY_REGION_BIT"),
	DEPENDENCY_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_FLAG_BITS_MAX_ENUM"),
	SYSTEM_ALLOCATION_SCOPE_COMMAND = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND"),
	SYSTEM_ALLOCATION_SCOPE_OBJECT = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT"),
	SYSTEM_ALLOCATION_SCOPE_CACHE = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_CACHE"),
	SYSTEM_ALLOCATION_SCOPE_DEVICE = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE"),
	SYSTEM_ALLOCATION_SCOPE_INSTANCE = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE"),
	SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE"),
	SYSTEM_ALLOCATION_SCOPE_END_RANGE = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE"),
	SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE"),
	SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM"),
	FILTER_NEAREST = ffi.cast("enum VkFilter", "VK_FILTER_NEAREST"),
	FILTER_LINEAR = ffi.cast("enum VkFilter", "VK_FILTER_LINEAR"),
	FILTER_CUBIC_IMG = ffi.cast("enum VkFilter", "VK_FILTER_CUBIC_IMG"),
	FILTER_BEGIN_RANGE = ffi.cast("enum VkFilter", "VK_FILTER_BEGIN_RANGE"),
	FILTER_END_RANGE = ffi.cast("enum VkFilter", "VK_FILTER_END_RANGE"),
	FILTER_RANGE_SIZE = ffi.cast("enum VkFilter", "VK_FILTER_RANGE_SIZE"),
	FILTER_MAX_ENUM = ffi.cast("enum VkFilter", "VK_FILTER_MAX_ENUM"),
	BUFFER_USAGE_TRANSFER_SRC_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_TRANSFER_SRC_BIT"),
	BUFFER_USAGE_TRANSFER_DST_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_TRANSFER_DST_BIT"),
	BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT"),
	BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT"),
	BUFFER_USAGE_UNIFORM_BUFFER_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT"),
	BUFFER_USAGE_STORAGE_BUFFER_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT"),
	BUFFER_USAGE_INDEX_BUFFER_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_INDEX_BUFFER_BIT"),
	BUFFER_USAGE_VERTEX_BUFFER_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT"),
	BUFFER_USAGE_INDIRECT_BUFFER_BIT = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT"),
	BUFFER_USAGE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM"),
	DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR"),
	DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR"),
	DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR"),
	DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR"),
	DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR"),
	PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT"),
	PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT"),
	PIPELINE_CREATE_DERIVATIVE_BIT = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_DERIVATIVE_BIT"),
	PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM"),
	DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT"),
	DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT"),
	IMAGE_VIEW_TYPE_1D = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_1D"),
	IMAGE_VIEW_TYPE_2D = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_2D"),
	IMAGE_VIEW_TYPE_3D = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_3D"),
	IMAGE_VIEW_TYPE_CUBE = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_CUBE"),
	IMAGE_VIEW_TYPE_1D_ARRAY = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_1D_ARRAY"),
	IMAGE_VIEW_TYPE_2D_ARRAY = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_2D_ARRAY"),
	IMAGE_VIEW_TYPE_CUBE_ARRAY = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"),
	IMAGE_VIEW_TYPE_BEGIN_RANGE = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_BEGIN_RANGE"),
	IMAGE_VIEW_TYPE_END_RANGE = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_END_RANGE"),
	IMAGE_VIEW_TYPE_RANGE_SIZE = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_RANGE_SIZE"),
	IMAGE_VIEW_TYPE_MAX_ENUM = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_MAX_ENUM"),
	QUERY_CONTROL_PRECISE_BIT = ffi.cast("enum VkQueryControlFlagBits", "VK_QUERY_CONTROL_PRECISE_BIT"),
	QUERY_CONTROL_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkQueryControlFlagBits", "VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM"),
	ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = ffi.cast("enum VkAttachmentDescriptionFlagBits", "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT"),
	ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkAttachmentDescriptionFlagBits", "VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM"),
	PIPELINE_CACHE_HEADER_VERSION_ONE = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_ONE"),
	PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE"),
	PIPELINE_CACHE_HEADER_VERSION_END_RANGE = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE"),
	PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE"),
	PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM"),
	DEBUG_REPORT_INFORMATION_BIT_EXT = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_INFORMATION_BIT_EXT"),
	DEBUG_REPORT_WARNING_BIT_EXT = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_WARNING_BIT_EXT"),
	DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT"),
	DEBUG_REPORT_ERROR_BIT_EXT = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_ERROR_BIT_EXT"),
	DEBUG_REPORT_DEBUG_BIT_EXT = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_DEBUG_BIT_EXT"),
	DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT"),
	PRIMITIVE_TOPOLOGY_POINT_LIST = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_POINT_LIST"),
	PRIMITIVE_TOPOLOGY_LINE_LIST = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_LIST"),
	PRIMITIVE_TOPOLOGY_LINE_STRIP = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP"),
	PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST"),
	PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP"),
	PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN"),
	PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY"),
	PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY"),
	PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY"),
	PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY"),
	PRIMITIVE_TOPOLOGY_PATCH_LIST = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST"),
	PRIMITIVE_TOPOLOGY_BEGIN_RANGE = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE"),
	PRIMITIVE_TOPOLOGY_END_RANGE = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_END_RANGE"),
	PRIMITIVE_TOPOLOGY_RANGE_SIZE = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE"),
	PRIMITIVE_TOPOLOGY_MAX_ENUM = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_MAX_ENUM"),
	SPARSE_MEMORY_BIND_METADATA_BIT = ffi.cast("enum VkSparseMemoryBindFlagBits", "VK_SPARSE_MEMORY_BIND_METADATA_BIT"),
	SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkSparseMemoryBindFlagBits", "VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM"),
	SURFACE_TRANSFORM_IDENTITY_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR"),
	SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR"),
	SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR"),
	SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR"),
	SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR"),
	SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR"),
	SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR"),
	SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR"),
	SURFACE_TRANSFORM_INHERIT_BIT_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR"),
	SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR"),
	COMPARE_OP_NEVER = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_NEVER"),
	COMPARE_OP_LESS = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_LESS"),
	COMPARE_OP_EQUAL = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_EQUAL"),
	COMPARE_OP_LESS_OR_EQUAL = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_LESS_OR_EQUAL"),
	COMPARE_OP_GREATER = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_GREATER"),
	COMPARE_OP_NOT_EQUAL = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_NOT_EQUAL"),
	COMPARE_OP_GREATER_OR_EQUAL = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_GREATER_OR_EQUAL"),
	COMPARE_OP_ALWAYS = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_ALWAYS"),
	COMPARE_OP_BEGIN_RANGE = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_BEGIN_RANGE"),
	COMPARE_OP_END_RANGE = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_END_RANGE"),
	COMPARE_OP_RANGE_SIZE = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_RANGE_SIZE"),
	COMPARE_OP_MAX_ENUM = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_MAX_ENUM"),
	SHADER_STAGE_VERTEX_BIT = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_VERTEX_BIT"),
	SHADER_STAGE_TESSELLATION_CONTROL_BIT = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT"),
	SHADER_STAGE_TESSELLATION_EVALUATION_BIT = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT"),
	SHADER_STAGE_GEOMETRY_BIT = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_GEOMETRY_BIT"),
	SHADER_STAGE_FRAGMENT_BIT = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_FRAGMENT_BIT"),
	SHADER_STAGE_COMPUTE_BIT = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_COMPUTE_BIT"),
	SHADER_STAGE_ALL_GRAPHICS = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_ALL_GRAPHICS"),
	SHADER_STAGE_ALL = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_ALL"),
	SHADER_STAGE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM"),
	SUCCESS = ffi.cast("enum VkResult", "VK_SUCCESS"),
	NOT_READY = ffi.cast("enum VkResult", "VK_NOT_READY"),
	TIMEOUT = ffi.cast("enum VkResult", "VK_TIMEOUT"),
	EVENT_SET = ffi.cast("enum VkResult", "VK_EVENT_SET"),
	EVENT_RESET = ffi.cast("enum VkResult", "VK_EVENT_RESET"),
	INCOMPLETE = ffi.cast("enum VkResult", "VK_INCOMPLETE"),
	ERROR_OUT_OF_HOST_MEMORY = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_HOST_MEMORY"),
	ERROR_OUT_OF_DEVICE_MEMORY = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_DEVICE_MEMORY"),
	ERROR_INITIALIZATION_FAILED = ffi.cast("enum VkResult", "VK_ERROR_INITIALIZATION_FAILED"),
	ERROR_DEVICE_LOST = ffi.cast("enum VkResult", "VK_ERROR_DEVICE_LOST"),
	ERROR_MEMORY_MAP_FAILED = ffi.cast("enum VkResult", "VK_ERROR_MEMORY_MAP_FAILED"),
	ERROR_LAYER_NOT_PRESENT = ffi.cast("enum VkResult", "VK_ERROR_LAYER_NOT_PRESENT"),
	ERROR_EXTENSION_NOT_PRESENT = ffi.cast("enum VkResult", "VK_ERROR_EXTENSION_NOT_PRESENT"),
	ERROR_FEATURE_NOT_PRESENT = ffi.cast("enum VkResult", "VK_ERROR_FEATURE_NOT_PRESENT"),
	ERROR_INCOMPATIBLE_DRIVER = ffi.cast("enum VkResult", "VK_ERROR_INCOMPATIBLE_DRIVER"),
	ERROR_TOO_MANY_OBJECTS = ffi.cast("enum VkResult", "VK_ERROR_TOO_MANY_OBJECTS"),
	ERROR_FORMAT_NOT_SUPPORTED = ffi.cast("enum VkResult", "VK_ERROR_FORMAT_NOT_SUPPORTED"),
	ERROR_FRAGMENTED_POOL = ffi.cast("enum VkResult", "VK_ERROR_FRAGMENTED_POOL"),
	ERROR_SURFACE_LOST_KHR = ffi.cast("enum VkResult", "VK_ERROR_SURFACE_LOST_KHR"),
	ERROR_NATIVE_WINDOW_IN_USE_KHR = ffi.cast("enum VkResult", "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR"),
	SUBOPTIMAL_KHR = ffi.cast("enum VkResult", "VK_SUBOPTIMAL_KHR"),
	ERROR_OUT_OF_DATE_KHR = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_DATE_KHR"),
	ERROR_INCOMPATIBLE_DISPLAY_KHR = ffi.cast("enum VkResult", "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR"),
	ERROR_VALIDATION_FAILED_EXT = ffi.cast("enum VkResult", "VK_ERROR_VALIDATION_FAILED_EXT"),
	ERROR_INVALID_SHADER_NV = ffi.cast("enum VkResult", "VK_ERROR_INVALID_SHADER_NV"),
	RESULT_BEGIN_RANGE = ffi.cast("enum VkResult", "VK_RESULT_BEGIN_RANGE"),
	RESULT_END_RANGE = ffi.cast("enum VkResult", "VK_RESULT_END_RANGE"),
	RESULT_RANGE_SIZE = ffi.cast("enum VkResult", "VK_RESULT_RANGE_SIZE"),
	RESULT_MAX_ENUM = ffi.cast("enum VkResult", "VK_RESULT_MAX_ENUM"),
	FENCE_CREATE_SIGNALED_BIT = ffi.cast("enum VkFenceCreateFlagBits", "VK_FENCE_CREATE_SIGNALED_BIT"),
	FENCE_CREATE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkFenceCreateFlagBits", "VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM"),
	IMAGE_CREATE_SPARSE_BINDING_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_SPARSE_BINDING_BIT"),
	IMAGE_CREATE_SPARSE_RESIDENCY_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"),
	IMAGE_CREATE_SPARSE_ALIASED_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT"),
	IMAGE_CREATE_MUTABLE_FORMAT_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT"),
	IMAGE_CREATE_CUBE_COMPATIBLE_BIT = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT"),
	IMAGE_CREATE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM"),
	SAMPLE_COUNT_1_BIT = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_1_BIT"),
	SAMPLE_COUNT_2_BIT = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_2_BIT"),
	SAMPLE_COUNT_4_BIT = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_4_BIT"),
	SAMPLE_COUNT_8_BIT = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_8_BIT"),
	SAMPLE_COUNT_16_BIT = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_16_BIT"),
	SAMPLE_COUNT_32_BIT = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_32_BIT"),
	SAMPLE_COUNT_64_BIT = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_64_BIT"),
	SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM"),
	QUERY_RESULT_64_BIT = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_64_BIT"),
	QUERY_RESULT_WAIT_BIT = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_WAIT_BIT"),
	QUERY_RESULT_WITH_AVAILABILITY_BIT = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT"),
	QUERY_RESULT_PARTIAL_BIT = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_PARTIAL_BIT"),
	QUERY_RESULT_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM"),
	PRESENT_MODE_IMMEDIATE_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_IMMEDIATE_KHR"),
	PRESENT_MODE_MAILBOX_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_MAILBOX_KHR"),
	PRESENT_MODE_FIFO_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_FIFO_KHR"),
	PRESENT_MODE_FIFO_RELAXED_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_FIFO_RELAXED_KHR"),
	PRESENT_MODE_BEGIN_RANGE_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_BEGIN_RANGE_KHR"),
	PRESENT_MODE_END_RANGE_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_END_RANGE_KHR"),
	PRESENT_MODE_RANGE_SIZE_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_RANGE_SIZE_KHR"),
	PRESENT_MODE_MAX_ENUM_KHR = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_MAX_ENUM_KHR"),
	ACCESS_INDIRECT_COMMAND_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_INDIRECT_COMMAND_READ_BIT"),
	ACCESS_INDEX_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_INDEX_READ_BIT"),
	ACCESS_VERTEX_ATTRIBUTE_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT"),
	ACCESS_UNIFORM_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_UNIFORM_READ_BIT"),
	ACCESS_INPUT_ATTACHMENT_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT"),
	ACCESS_SHADER_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_SHADER_READ_BIT"),
	ACCESS_SHADER_WRITE_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_SHADER_WRITE_BIT"),
	ACCESS_COLOR_ATTACHMENT_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT"),
	ACCESS_COLOR_ATTACHMENT_WRITE_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT"),
	ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT"),
	ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"),
	ACCESS_TRANSFER_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_TRANSFER_READ_BIT"),
	ACCESS_TRANSFER_WRITE_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_TRANSFER_WRITE_BIT"),
	ACCESS_HOST_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_HOST_READ_BIT"),
	ACCESS_HOST_WRITE_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_HOST_WRITE_BIT"),
	ACCESS_MEMORY_READ_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_MEMORY_READ_BIT"),
	ACCESS_MEMORY_WRITE_BIT = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_MEMORY_WRITE_BIT"),
	ACCESS_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_FLAG_BITS_MAX_ENUM"),
	EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = ffi.cast("enum VkExternalMemoryFeatureFlagBitsNV", "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV"),
	EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = ffi.cast("enum VkExternalMemoryFeatureFlagBitsNV", "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV"),
	EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = ffi.cast("enum VkExternalMemoryFeatureFlagBitsNV", "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV"),
	EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV = ffi.cast("enum VkExternalMemoryFeatureFlagBitsNV", "VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV"),
	FORMAT_FEATURE_SAMPLED_IMAGE_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT"),
	FORMAT_FEATURE_STORAGE_IMAGE_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT"),
	FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT"),
	FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT"),
	FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT"),
	FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT"),
	FORMAT_FEATURE_VERTEX_BUFFER_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT"),
	FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT"),
	FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT"),
	FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT"),
	FORMAT_FEATURE_BLIT_SRC_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_BLIT_SRC_BIT"),
	FORMAT_FEATURE_BLIT_DST_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_BLIT_DST_BIT"),
	FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT"),
	FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG"),
	FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM"),
	COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = ffi.cast("enum VkCommandPoolResetFlagBits", "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT"),
	COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkCommandPoolResetFlagBits", "VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM"),
	MEMORY_HEAP_DEVICE_LOCAL_BIT = ffi.cast("enum VkMemoryHeapFlagBits", "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT"),
	MEMORY_HEAP_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkMemoryHeapFlagBits", "VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM"),
	STRUCTURE_TYPE_APPLICATION_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_APPLICATION_INFO"),
	STRUCTURE_TYPE_INSTANCE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"),
	STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"),
	STRUCTURE_TYPE_DEVICE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"),
	STRUCTURE_TYPE_SUBMIT_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SUBMIT_INFO"),
	STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"),
	STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"),
	STRUCTURE_TYPE_BIND_SPARSE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"),
	STRUCTURE_TYPE_FENCE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"),
	STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"),
	STRUCTURE_TYPE_EVENT_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"),
	STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"),
	STRUCTURE_TYPE_BUFFER_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"),
	STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"),
	STRUCTURE_TYPE_IMAGE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"),
	STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"),
	STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"),
	STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"),
	STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"),
	STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"),
	STRUCTURE_TYPE_SAMPLER_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"),
	STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"),
	STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"),
	STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"),
	STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"),
	STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"),
	STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"),
	STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"),
	STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"),
	STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"),
	STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"),
	STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"),
	STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"),
	STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"),
	STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"),
	STRUCTURE_TYPE_MEMORY_BARRIER = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_BARRIER"),
	STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO"),
	STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO"),
	STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_PRESENT_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"),
	STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"),
	STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR"),
	STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"),
	STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"),
	STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"),
	STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"),
	STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"),
	STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"),
	STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"),
	STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"),
	STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV"),
	STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV"),
	STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV"),
	STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV"),
	STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV"),
	STRUCTURE_TYPE_BEGIN_RANGE = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BEGIN_RANGE"),
	STRUCTURE_TYPE_END_RANGE = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_END_RANGE"),
	STRUCTURE_TYPE_RANGE_SIZE = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RANGE_SIZE"),
	STRUCTURE_TYPE_MAX_ENUM = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MAX_ENUM"),
	VERTEX_INPUT_RATE_VERTEX = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_VERTEX"),
	VERTEX_INPUT_RATE_INSTANCE = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_INSTANCE"),
	VERTEX_INPUT_RATE_BEGIN_RANGE = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_BEGIN_RANGE"),
	VERTEX_INPUT_RATE_END_RANGE = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_END_RANGE"),
	VERTEX_INPUT_RATE_RANGE_SIZE = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_RANGE_SIZE"),
	VERTEX_INPUT_RATE_MAX_ENUM = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_MAX_ENUM"),
	COMPOSITE_ALPHA_OPAQUE_BIT_KHR = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR"),
	COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR"),
	COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR"),
	COMPOSITE_ALPHA_INHERIT_BIT_KHR = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR"),
	COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR"),
	IMAGE_TILING_OPTIMAL = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_OPTIMAL"),
	IMAGE_TILING_LINEAR = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_LINEAR"),
	IMAGE_TILING_BEGIN_RANGE = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_BEGIN_RANGE"),
	IMAGE_TILING_END_RANGE = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_END_RANGE"),
	IMAGE_TILING_RANGE_SIZE = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_RANGE_SIZE"),
	IMAGE_TILING_MAX_ENUM = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_MAX_ENUM"),
	FORMAT_UNDEFINED = ffi.cast("enum VkFormat", "VK_FORMAT_UNDEFINED"),
	FORMAT_R4G4_UNORM_PACK8 = ffi.cast("enum VkFormat", "VK_FORMAT_R4G4_UNORM_PACK8"),
	FORMAT_R4G4B4A4_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_R4G4B4A4_UNORM_PACK16"),
	FORMAT_B4G4R4A4_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_B4G4R4A4_UNORM_PACK16"),
	FORMAT_R5G6B5_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_R5G6B5_UNORM_PACK16"),
	FORMAT_B5G6R5_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_B5G6R5_UNORM_PACK16"),
	FORMAT_R5G5B5A1_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_R5G5B5A1_UNORM_PACK16"),
	FORMAT_B5G5R5A1_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_B5G5R5A1_UNORM_PACK16"),
	FORMAT_A1R5G5B5_UNORM_PACK16 = ffi.cast("enum VkFormat", "VK_FORMAT_A1R5G5B5_UNORM_PACK16"),
	FORMAT_R8_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8_UNORM"),
	FORMAT_R8_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SNORM"),
	FORMAT_R8_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8_USCALED"),
	FORMAT_R8_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SSCALED"),
	FORMAT_R8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8_UINT"),
	FORMAT_R8_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SINT"),
	FORMAT_R8_SRGB = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SRGB"),
	FORMAT_R8G8_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_UNORM"),
	FORMAT_R8G8_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SNORM"),
	FORMAT_R8G8_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_USCALED"),
	FORMAT_R8G8_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SSCALED"),
	FORMAT_R8G8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_UINT"),
	FORMAT_R8G8_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SINT"),
	FORMAT_R8G8_SRGB = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SRGB"),
	FORMAT_R8G8B8_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_UNORM"),
	FORMAT_R8G8B8_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SNORM"),
	FORMAT_R8G8B8_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_USCALED"),
	FORMAT_R8G8B8_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SSCALED"),
	FORMAT_R8G8B8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_UINT"),
	FORMAT_R8G8B8_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SINT"),
	FORMAT_R8G8B8_SRGB = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SRGB"),
	FORMAT_B8G8R8_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_UNORM"),
	FORMAT_B8G8R8_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SNORM"),
	FORMAT_B8G8R8_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_USCALED"),
	FORMAT_B8G8R8_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SSCALED"),
	FORMAT_B8G8R8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_UINT"),
	FORMAT_B8G8R8_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SINT"),
	FORMAT_B8G8R8_SRGB = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SRGB"),
	FORMAT_R8G8B8A8_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_UNORM"),
	FORMAT_R8G8B8A8_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SNORM"),
	FORMAT_R8G8B8A8_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_USCALED"),
	FORMAT_R8G8B8A8_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SSCALED"),
	FORMAT_R8G8B8A8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_UINT"),
	FORMAT_R8G8B8A8_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SINT"),
	FORMAT_R8G8B8A8_SRGB = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SRGB"),
	FORMAT_B8G8R8A8_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_UNORM"),
	FORMAT_B8G8R8A8_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SNORM"),
	FORMAT_B8G8R8A8_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_USCALED"),
	FORMAT_B8G8R8A8_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SSCALED"),
	FORMAT_B8G8R8A8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_UINT"),
	FORMAT_B8G8R8A8_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SINT"),
	FORMAT_B8G8R8A8_SRGB = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SRGB"),
	FORMAT_A8B8G8R8_UNORM_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_UNORM_PACK32"),
	FORMAT_A8B8G8R8_SNORM_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SNORM_PACK32"),
	FORMAT_A8B8G8R8_USCALED_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_USCALED_PACK32"),
	FORMAT_A8B8G8R8_SSCALED_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SSCALED_PACK32"),
	FORMAT_A8B8G8R8_UINT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_UINT_PACK32"),
	FORMAT_A8B8G8R8_SINT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SINT_PACK32"),
	FORMAT_A8B8G8R8_SRGB_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SRGB_PACK32"),
	FORMAT_A2R10G10B10_UNORM_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_UNORM_PACK32"),
	FORMAT_A2R10G10B10_SNORM_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_SNORM_PACK32"),
	FORMAT_A2R10G10B10_USCALED_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_USCALED_PACK32"),
	FORMAT_A2R10G10B10_SSCALED_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_SSCALED_PACK32"),
	FORMAT_A2R10G10B10_UINT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_UINT_PACK32"),
	FORMAT_A2R10G10B10_SINT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_SINT_PACK32"),
	FORMAT_A2B10G10R10_UNORM_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_UNORM_PACK32"),
	FORMAT_A2B10G10R10_SNORM_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_SNORM_PACK32"),
	FORMAT_A2B10G10R10_USCALED_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_USCALED_PACK32"),
	FORMAT_A2B10G10R10_SSCALED_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_SSCALED_PACK32"),
	FORMAT_A2B10G10R10_UINT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_UINT_PACK32"),
	FORMAT_A2B10G10R10_SINT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_SINT_PACK32"),
	FORMAT_R16_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16_UNORM"),
	FORMAT_R16_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SNORM"),
	FORMAT_R16_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16_USCALED"),
	FORMAT_R16_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SSCALED"),
	FORMAT_R16_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16_UINT"),
	FORMAT_R16_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SINT"),
	FORMAT_R16_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SFLOAT"),
	FORMAT_R16G16_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_UNORM"),
	FORMAT_R16G16_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SNORM"),
	FORMAT_R16G16_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_USCALED"),
	FORMAT_R16G16_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SSCALED"),
	FORMAT_R16G16_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_UINT"),
	FORMAT_R16G16_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SINT"),
	FORMAT_R16G16_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SFLOAT"),
	FORMAT_R16G16B16_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_UNORM"),
	FORMAT_R16G16B16_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SNORM"),
	FORMAT_R16G16B16_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_USCALED"),
	FORMAT_R16G16B16_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SSCALED"),
	FORMAT_R16G16B16_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_UINT"),
	FORMAT_R16G16B16_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SINT"),
	FORMAT_R16G16B16_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SFLOAT"),
	FORMAT_R16G16B16A16_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_UNORM"),
	FORMAT_R16G16B16A16_SNORM = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SNORM"),
	FORMAT_R16G16B16A16_USCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_USCALED"),
	FORMAT_R16G16B16A16_SSCALED = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SSCALED"),
	FORMAT_R16G16B16A16_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_UINT"),
	FORMAT_R16G16B16A16_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SINT"),
	FORMAT_R16G16B16A16_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SFLOAT"),
	FORMAT_R32_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32_UINT"),
	FORMAT_R32_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32_SINT"),
	FORMAT_R32_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R32_SFLOAT"),
	FORMAT_R32G32_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32_UINT"),
	FORMAT_R32G32_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32_SINT"),
	FORMAT_R32G32_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32_SFLOAT"),
	FORMAT_R32G32B32_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32_UINT"),
	FORMAT_R32G32B32_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32_SINT"),
	FORMAT_R32G32B32_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32_SFLOAT"),
	FORMAT_R32G32B32A32_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32A32_UINT"),
	FORMAT_R32G32B32A32_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32A32_SINT"),
	FORMAT_R32G32B32A32_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32A32_SFLOAT"),
	FORMAT_R64_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64_UINT"),
	FORMAT_R64_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64_SINT"),
	FORMAT_R64_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R64_SFLOAT"),
	FORMAT_R64G64_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64_UINT"),
	FORMAT_R64G64_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64_SINT"),
	FORMAT_R64G64_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64_SFLOAT"),
	FORMAT_R64G64B64_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64_UINT"),
	FORMAT_R64G64B64_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64_SINT"),
	FORMAT_R64G64B64_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64_SFLOAT"),
	FORMAT_R64G64B64A64_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64A64_UINT"),
	FORMAT_R64G64B64A64_SINT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64A64_SINT"),
	FORMAT_R64G64B64A64_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64A64_SFLOAT"),
	FORMAT_B10G11R11_UFLOAT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_B10G11R11_UFLOAT_PACK32"),
	FORMAT_E5B9G9R9_UFLOAT_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32"),
	FORMAT_D16_UNORM = ffi.cast("enum VkFormat", "VK_FORMAT_D16_UNORM"),
	FORMAT_X8_D24_UNORM_PACK32 = ffi.cast("enum VkFormat", "VK_FORMAT_X8_D24_UNORM_PACK32"),
	FORMAT_D32_SFLOAT = ffi.cast("enum VkFormat", "VK_FORMAT_D32_SFLOAT"),
	FORMAT_S8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_S8_UINT"),
	FORMAT_D16_UNORM_S8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_D16_UNORM_S8_UINT"),
	FORMAT_D24_UNORM_S8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_D24_UNORM_S8_UINT"),
	FORMAT_D32_SFLOAT_S8_UINT = ffi.cast("enum VkFormat", "VK_FORMAT_D32_SFLOAT_S8_UINT"),
	FORMAT_BC1_RGB_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGB_UNORM_BLOCK"),
	FORMAT_BC1_RGB_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGB_SRGB_BLOCK"),
	FORMAT_BC1_RGBA_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGBA_UNORM_BLOCK"),
	FORMAT_BC1_RGBA_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGBA_SRGB_BLOCK"),
	FORMAT_BC2_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC2_UNORM_BLOCK"),
	FORMAT_BC2_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC2_SRGB_BLOCK"),
	FORMAT_BC3_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC3_UNORM_BLOCK"),
	FORMAT_BC3_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC3_SRGB_BLOCK"),
	FORMAT_BC4_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC4_UNORM_BLOCK"),
	FORMAT_BC4_SNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC4_SNORM_BLOCK"),
	FORMAT_BC5_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC5_UNORM_BLOCK"),
	FORMAT_BC5_SNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC5_SNORM_BLOCK"),
	FORMAT_BC6H_UFLOAT_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC6H_UFLOAT_BLOCK"),
	FORMAT_BC6H_SFLOAT_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC6H_SFLOAT_BLOCK"),
	FORMAT_BC7_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC7_UNORM_BLOCK"),
	FORMAT_BC7_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_BC7_SRGB_BLOCK"),
	FORMAT_ETC2_R8G8B8_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK"),
	FORMAT_ETC2_R8G8B8_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK"),
	FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK"),
	FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK"),
	FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK"),
	FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK"),
	FORMAT_EAC_R11_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11_UNORM_BLOCK"),
	FORMAT_EAC_R11_SNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11_SNORM_BLOCK"),
	FORMAT_EAC_R11G11_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11G11_UNORM_BLOCK"),
	FORMAT_EAC_R11G11_SNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11G11_SNORM_BLOCK"),
	FORMAT_ASTC_4x4_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_4x4_UNORM_BLOCK"),
	FORMAT_ASTC_4x4_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_4x4_SRGB_BLOCK"),
	FORMAT_ASTC_5x4_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x4_UNORM_BLOCK"),
	FORMAT_ASTC_5x4_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x4_SRGB_BLOCK"),
	FORMAT_ASTC_5x5_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x5_UNORM_BLOCK"),
	FORMAT_ASTC_5x5_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x5_SRGB_BLOCK"),
	FORMAT_ASTC_6x5_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x5_UNORM_BLOCK"),
	FORMAT_ASTC_6x5_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x5_SRGB_BLOCK"),
	FORMAT_ASTC_6x6_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x6_UNORM_BLOCK"),
	FORMAT_ASTC_6x6_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x6_SRGB_BLOCK"),
	FORMAT_ASTC_8x5_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x5_UNORM_BLOCK"),
	FORMAT_ASTC_8x5_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x5_SRGB_BLOCK"),
	FORMAT_ASTC_8x6_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x6_UNORM_BLOCK"),
	FORMAT_ASTC_8x6_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x6_SRGB_BLOCK"),
	FORMAT_ASTC_8x8_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x8_UNORM_BLOCK"),
	FORMAT_ASTC_8x8_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x8_SRGB_BLOCK"),
	FORMAT_ASTC_10x5_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x5_UNORM_BLOCK"),
	FORMAT_ASTC_10x5_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x5_SRGB_BLOCK"),
	FORMAT_ASTC_10x6_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x6_UNORM_BLOCK"),
	FORMAT_ASTC_10x6_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x6_SRGB_BLOCK"),
	FORMAT_ASTC_10x8_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x8_UNORM_BLOCK"),
	FORMAT_ASTC_10x8_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x8_SRGB_BLOCK"),
	FORMAT_ASTC_10x10_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x10_UNORM_BLOCK"),
	FORMAT_ASTC_10x10_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x10_SRGB_BLOCK"),
	FORMAT_ASTC_12x10_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x10_UNORM_BLOCK"),
	FORMAT_ASTC_12x10_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x10_SRGB_BLOCK"),
	FORMAT_ASTC_12x12_UNORM_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x12_UNORM_BLOCK"),
	FORMAT_ASTC_12x12_SRGB_BLOCK = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x12_SRGB_BLOCK"),
	FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG"),
	FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG"),
	FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG"),
	FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG"),
	FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG"),
	FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG"),
	FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG"),
	FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG"),
	FORMAT_BEGIN_RANGE = ffi.cast("enum VkFormat", "VK_FORMAT_BEGIN_RANGE"),
	FORMAT_END_RANGE = ffi.cast("enum VkFormat", "VK_FORMAT_END_RANGE"),
	FORMAT_RANGE_SIZE = ffi.cast("enum VkFormat", "VK_FORMAT_RANGE_SIZE"),
	FORMAT_MAX_ENUM = ffi.cast("enum VkFormat", "VK_FORMAT_MAX_ENUM"),
	ATTACHMENT_STORE_OP_STORE = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_STORE"),
	ATTACHMENT_STORE_OP_DONT_CARE = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_DONT_CARE"),
	ATTACHMENT_STORE_OP_BEGIN_RANGE = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_BEGIN_RANGE"),
	ATTACHMENT_STORE_OP_END_RANGE = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_END_RANGE"),
	ATTACHMENT_STORE_OP_RANGE_SIZE = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_RANGE_SIZE"),
	ATTACHMENT_STORE_OP_MAX_ENUM = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_MAX_ENUM"),
	LOGIC_OP_CLEAR = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_CLEAR"),
	LOGIC_OP_AND = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_AND"),
	LOGIC_OP_AND_REVERSE = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_AND_REVERSE"),
	LOGIC_OP_COPY = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_COPY"),
	LOGIC_OP_AND_INVERTED = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_AND_INVERTED"),
	LOGIC_OP_NO_OP = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_NO_OP"),
	LOGIC_OP_XOR = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_XOR"),
	LOGIC_OP_OR = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_OR"),
	LOGIC_OP_NOR = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_NOR"),
	LOGIC_OP_EQUIVALENT = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_EQUIVALENT"),
	LOGIC_OP_INVERT = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_INVERT"),
	LOGIC_OP_OR_REVERSE = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_OR_REVERSE"),
	LOGIC_OP_COPY_INVERTED = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_COPY_INVERTED"),
	LOGIC_OP_OR_INVERTED = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_OR_INVERTED"),
	LOGIC_OP_NAND = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_NAND"),
	LOGIC_OP_SET = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_SET"),
	LOGIC_OP_BEGIN_RANGE = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_BEGIN_RANGE"),
	LOGIC_OP_END_RANGE = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_END_RANGE"),
	LOGIC_OP_RANGE_SIZE = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_RANGE_SIZE"),
	LOGIC_OP_MAX_ENUM = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_MAX_ENUM"),
	ATTACHMENT_LOAD_OP_LOAD = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_LOAD"),
	ATTACHMENT_LOAD_OP_CLEAR = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_CLEAR"),
	ATTACHMENT_LOAD_OP_DONT_CARE = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_DONT_CARE"),
	ATTACHMENT_LOAD_OP_BEGIN_RANGE = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE"),
	ATTACHMENT_LOAD_OP_END_RANGE = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_END_RANGE"),
	ATTACHMENT_LOAD_OP_RANGE_SIZE = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_RANGE_SIZE"),
	ATTACHMENT_LOAD_OP_MAX_ENUM = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_MAX_ENUM"),
	IMAGE_ASPECT_COLOR_BIT = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_COLOR_BIT"),
	IMAGE_ASPECT_DEPTH_BIT = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_DEPTH_BIT"),
	IMAGE_ASPECT_STENCIL_BIT = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_STENCIL_BIT"),
	IMAGE_ASPECT_METADATA_BIT = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_METADATA_BIT"),
	IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM"),
	POLYGON_MODE_FILL = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_FILL"),
	POLYGON_MODE_LINE = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_LINE"),
	POLYGON_MODE_POINT = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_POINT"),
	POLYGON_MODE_BEGIN_RANGE = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_BEGIN_RANGE"),
	POLYGON_MODE_END_RANGE = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_END_RANGE"),
	POLYGON_MODE_RANGE_SIZE = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_RANGE_SIZE"),
	POLYGON_MODE_MAX_ENUM = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_MAX_ENUM"),
	IMAGE_TYPE_1D = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_1D"),
	IMAGE_TYPE_2D = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_2D"),
	IMAGE_TYPE_3D = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_3D"),
	IMAGE_TYPE_BEGIN_RANGE = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_BEGIN_RANGE"),
	IMAGE_TYPE_END_RANGE = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_END_RANGE"),
	IMAGE_TYPE_RANGE_SIZE = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_RANGE_SIZE"),
	IMAGE_TYPE_MAX_ENUM = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_MAX_ENUM"),
	SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT"),
	SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT"),
	SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT"),
	SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM"),
	BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK"),
	BORDER_COLOR_INT_TRANSPARENT_BLACK = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK"),
	BORDER_COLOR_FLOAT_OPAQUE_BLACK = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK"),
	BORDER_COLOR_INT_OPAQUE_BLACK = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_INT_OPAQUE_BLACK"),
	BORDER_COLOR_FLOAT_OPAQUE_WHITE = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE"),
	BORDER_COLOR_INT_OPAQUE_WHITE = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_INT_OPAQUE_WHITE"),
	BORDER_COLOR_BEGIN_RANGE = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_BEGIN_RANGE"),
	BORDER_COLOR_END_RANGE = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_END_RANGE"),
	BORDER_COLOR_RANGE_SIZE = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_RANGE_SIZE"),
	BORDER_COLOR_MAX_ENUM = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_MAX_ENUM"),
	INTERNAL_ALLOCATION_TYPE_EXECUTABLE = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE"),
	INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE"),
	INTERNAL_ALLOCATION_TYPE_END_RANGE = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_END_RANGE"),
	INTERNAL_ALLOCATION_TYPE_RANGE_SIZE = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE"),
	INTERNAL_ALLOCATION_TYPE_MAX_ENUM = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM"),
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsNV", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV"),
	EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsNV", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV"),
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsNV", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV"),
	EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsNV", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV"),
	EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsNV", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV"),
	RASTERIZATION_ORDER_STRICT_AMD = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_STRICT_AMD"),
	RASTERIZATION_ORDER_RELAXED_AMD = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_RELAXED_AMD"),
	RASTERIZATION_ORDER_BEGIN_RANGE_AMD = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD"),
	RASTERIZATION_ORDER_END_RANGE_AMD = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_END_RANGE_AMD"),
	RASTERIZATION_ORDER_RANGE_SIZE_AMD = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD"),
	RASTERIZATION_ORDER_MAX_ENUM_AMD = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_MAX_ENUM_AMD"),
	DEBUG_REPORT_ERROR_NONE_EXT = ffi.cast("enum VkDebugReportErrorEXT", "VK_DEBUG_REPORT_ERROR_NONE_EXT"),
	DEBUG_REPORT_ERROR_CALLBACK_REF_EXT = ffi.cast("enum VkDebugReportErrorEXT", "VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT"),
	DEBUG_REPORT_ERROR_BEGIN_RANGE_EXT = ffi.cast("enum VkDebugReportErrorEXT", "VK_DEBUG_REPORT_ERROR_BEGIN_RANGE_EXT"),
	DEBUG_REPORT_ERROR_END_RANGE_EXT = ffi.cast("enum VkDebugReportErrorEXT", "VK_DEBUG_REPORT_ERROR_END_RANGE_EXT"),
	DEBUG_REPORT_ERROR_RANGE_SIZE_EXT = ffi.cast("enum VkDebugReportErrorEXT", "VK_DEBUG_REPORT_ERROR_RANGE_SIZE_EXT"),
	DEBUG_REPORT_ERROR_MAX_ENUM_EXT = ffi.cast("enum VkDebugReportErrorEXT", "VK_DEBUG_REPORT_ERROR_MAX_ENUM_EXT"),
	QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT"),
	QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT"),
	QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT"),
	QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT"),
	QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT"),
	QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT"),
	QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT"),
	QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT"),
	QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT"),
	QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT"),
	QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT"),
	QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM"),
	COLOR_SPACE_SRGB_NONLINEAR_KHR = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR"),
	COLOR_SPACE_BEGIN_RANGE_KHR = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_BEGIN_RANGE_KHR"),
	COLOR_SPACE_END_RANGE_KHR = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_END_RANGE_KHR"),
	COLOR_SPACE_RANGE_SIZE_KHR = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_RANGE_SIZE_KHR"),
	COLOR_SPACE_MAX_ENUM_KHR = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_MAX_ENUM_KHR"),
	FRONT_FACE_COUNTER_CLOCKWISE = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_COUNTER_CLOCKWISE"),
	FRONT_FACE_CLOCKWISE = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_CLOCKWISE"),
	FRONT_FACE_BEGIN_RANGE = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_BEGIN_RANGE"),
	FRONT_FACE_END_RANGE = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_END_RANGE"),
	FRONT_FACE_RANGE_SIZE = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_RANGE_SIZE"),
	FRONT_FACE_MAX_ENUM = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_MAX_ENUM"),
	STENCIL_OP_KEEP = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_KEEP"),
	STENCIL_OP_ZERO = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_ZERO"),
	STENCIL_OP_REPLACE = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_REPLACE"),
	STENCIL_OP_INCREMENT_AND_CLAMP = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_INCREMENT_AND_CLAMP"),
	STENCIL_OP_DECREMENT_AND_CLAMP = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_DECREMENT_AND_CLAMP"),
	STENCIL_OP_INVERT = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_INVERT"),
	STENCIL_OP_INCREMENT_AND_WRAP = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_INCREMENT_AND_WRAP"),
	STENCIL_OP_DECREMENT_AND_WRAP = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_DECREMENT_AND_WRAP"),
	STENCIL_OP_BEGIN_RANGE = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_BEGIN_RANGE"),
	STENCIL_OP_END_RANGE = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_END_RANGE"),
	STENCIL_OP_RANGE_SIZE = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_RANGE_SIZE"),
	STENCIL_OP_MAX_ENUM = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_MAX_ENUM"),
	BLEND_OP_ADD = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_ADD"),
	BLEND_OP_SUBTRACT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SUBTRACT"),
	BLEND_OP_REVERSE_SUBTRACT = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_REVERSE_SUBTRACT"),
	BLEND_OP_MIN = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MIN"),
	BLEND_OP_MAX = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MAX"),
	BLEND_OP_BEGIN_RANGE = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_BEGIN_RANGE"),
	BLEND_OP_END_RANGE = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_END_RANGE"),
	BLEND_OP_RANGE_SIZE = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_RANGE_SIZE"),
	BLEND_OP_MAX_ENUM = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MAX_ENUM"),
	BLEND_FACTOR_ZERO = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ZERO"),
	BLEND_FACTOR_ONE = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE"),
	BLEND_FACTOR_SRC_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC_COLOR"),
	BLEND_FACTOR_ONE_MINUS_SRC_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR"),
	BLEND_FACTOR_DST_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_DST_COLOR"),
	BLEND_FACTOR_ONE_MINUS_DST_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR"),
	BLEND_FACTOR_SRC_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC_ALPHA"),
	BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA"),
	BLEND_FACTOR_DST_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_DST_ALPHA"),
	BLEND_FACTOR_ONE_MINUS_DST_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA"),
	BLEND_FACTOR_CONSTANT_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_CONSTANT_COLOR"),
	BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR"),
	BLEND_FACTOR_CONSTANT_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_CONSTANT_ALPHA"),
	BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA"),
	BLEND_FACTOR_SRC_ALPHA_SATURATE = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE"),
	BLEND_FACTOR_SRC1_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC1_COLOR"),
	BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR"),
	BLEND_FACTOR_SRC1_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC1_ALPHA"),
	BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA"),
	BLEND_FACTOR_BEGIN_RANGE = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_BEGIN_RANGE"),
	BLEND_FACTOR_END_RANGE = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_END_RANGE"),
	BLEND_FACTOR_RANGE_SIZE = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_RANGE_SIZE"),
	BLEND_FACTOR_MAX_ENUM = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_MAX_ENUM"),
	PIPELINE_BIND_POINT_GRAPHICS = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_GRAPHICS"),
	PIPELINE_BIND_POINT_COMPUTE = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_COMPUTE"),
	PIPELINE_BIND_POINT_BEGIN_RANGE = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_BEGIN_RANGE"),
	PIPELINE_BIND_POINT_END_RANGE = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_END_RANGE"),
	PIPELINE_BIND_POINT_RANGE_SIZE = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_RANGE_SIZE"),
	PIPELINE_BIND_POINT_MAX_ENUM = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_MAX_ENUM"),
	COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = ffi.cast("enum VkCommandBufferUsageFlagBits", "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT"),
	COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = ffi.cast("enum VkCommandBufferUsageFlagBits", "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT"),
	COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = ffi.cast("enum VkCommandBufferUsageFlagBits", "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT"),
	COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkCommandBufferUsageFlagBits", "VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM"),
	SAMPLER_ADDRESS_MODE_REPEAT = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_REPEAT"),
	SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT"),
	SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE"),
	SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"),
	SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE"),
	SAMPLER_ADDRESS_MODE_BEGIN_RANGE = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE"),
	SAMPLER_ADDRESS_MODE_END_RANGE = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_END_RANGE"),
	SAMPLER_ADDRESS_MODE_RANGE_SIZE = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE"),
	SAMPLER_ADDRESS_MODE_MAX_ENUM = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_MAX_ENUM"),
	MEMORY_PROPERTY_DEVICE_LOCAL_BIT = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT"),
	MEMORY_PROPERTY_HOST_VISIBLE_BIT = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT"),
	MEMORY_PROPERTY_HOST_COHERENT_BIT = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"),
	MEMORY_PROPERTY_HOST_CACHED_BIT = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_HOST_CACHED_BIT"),
	MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT"),
	MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM"),
	PHYSICAL_DEVICE_TYPE_OTHER = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_OTHER"),
	PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU"),
	PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU"),
	PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU"),
	PHYSICAL_DEVICE_TYPE_CPU = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_CPU"),
	PHYSICAL_DEVICE_TYPE_BEGIN_RANGE = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE"),
	PHYSICAL_DEVICE_TYPE_END_RANGE = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_END_RANGE"),
	PHYSICAL_DEVICE_TYPE_RANGE_SIZE = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE"),
	PHYSICAL_DEVICE_TYPE_MAX_ENUM = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM"),
	QUERY_TYPE_OCCLUSION = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_OCCLUSION"),
	QUERY_TYPE_PIPELINE_STATISTICS = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_PIPELINE_STATISTICS"),
	QUERY_TYPE_TIMESTAMP = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_TIMESTAMP"),
	QUERY_TYPE_BEGIN_RANGE = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_BEGIN_RANGE"),
	QUERY_TYPE_END_RANGE = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_END_RANGE"),
	QUERY_TYPE_RANGE_SIZE = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_RANGE_SIZE"),
	QUERY_TYPE_MAX_ENUM = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_MAX_ENUM"),
	SHARING_MODE_EXCLUSIVE = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_EXCLUSIVE"),
	SHARING_MODE_CONCURRENT = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_CONCURRENT"),
	SHARING_MODE_BEGIN_RANGE = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_BEGIN_RANGE"),
	SHARING_MODE_END_RANGE = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_END_RANGE"),
	SHARING_MODE_RANGE_SIZE = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_RANGE_SIZE"),
	SHARING_MODE_MAX_ENUM = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_MAX_ENUM"),
	SUBPASS_CONTENTS_INLINE = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_INLINE"),
	SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS"),
	SUBPASS_CONTENTS_BEGIN_RANGE = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_BEGIN_RANGE"),
	SUBPASS_CONTENTS_END_RANGE = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_END_RANGE"),
	SUBPASS_CONTENTS_RANGE_SIZE = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_RANGE_SIZE"),
	SUBPASS_CONTENTS_MAX_ENUM = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_MAX_ENUM"),
	QUEUE_GRAPHICS_BIT = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_GRAPHICS_BIT"),
	QUEUE_COMPUTE_BIT = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_COMPUTE_BIT"),
	QUEUE_TRANSFER_BIT = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_TRANSFER_BIT"),
	QUEUE_SPARSE_BINDING_BIT = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_SPARSE_BINDING_BIT"),
	QUEUE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_FLAG_BITS_MAX_ENUM"),
	COLOR_COMPONENT_R_BIT = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_R_BIT"),
	COLOR_COMPONENT_G_BIT = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_G_BIT"),
	COLOR_COMPONENT_B_BIT = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_B_BIT"),
	COLOR_COMPONENT_A_BIT = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_A_BIT"),
	COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM"),
	COMPONENT_SWIZZLE_IDENTITY = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_IDENTITY"),
	COMPONENT_SWIZZLE_ZERO = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_ZERO"),
	COMPONENT_SWIZZLE_ONE = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_ONE"),
	COMPONENT_SWIZZLE_R = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_R"),
	COMPONENT_SWIZZLE_G = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_G"),
	COMPONENT_SWIZZLE_B = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_B"),
	COMPONENT_SWIZZLE_A = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_A"),
	COMPONENT_SWIZZLE_BEGIN_RANGE = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_BEGIN_RANGE"),
	COMPONENT_SWIZZLE_END_RANGE = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_END_RANGE"),
	COMPONENT_SWIZZLE_RANGE_SIZE = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_RANGE_SIZE"),
	COMPONENT_SWIZZLE_MAX_ENUM = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_MAX_ENUM"),
	COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = ffi.cast("enum VkCommandBufferResetFlagBits", "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT"),
	COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkCommandBufferResetFlagBits", "VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM"),
	DESCRIPTOR_TYPE_SAMPLER = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_SAMPLER"),
	DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"),
	DESCRIPTOR_TYPE_SAMPLED_IMAGE = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE"),
	DESCRIPTOR_TYPE_STORAGE_IMAGE = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE"),
	DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER"),
	DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER"),
	DESCRIPTOR_TYPE_UNIFORM_BUFFER = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER"),
	DESCRIPTOR_TYPE_STORAGE_BUFFER = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER"),
	DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC"),
	DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC"),
	DESCRIPTOR_TYPE_INPUT_ATTACHMENT = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT"),
	DESCRIPTOR_TYPE_BEGIN_RANGE = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_BEGIN_RANGE"),
	DESCRIPTOR_TYPE_END_RANGE = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_END_RANGE"),
	DESCRIPTOR_TYPE_RANGE_SIZE = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_RANGE_SIZE"),
	DESCRIPTOR_TYPE_MAX_ENUM = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_MAX_ENUM"),
	STENCIL_FACE_FRONT_BIT = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FACE_FRONT_BIT"),
	STENCIL_FACE_BACK_BIT = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FACE_BACK_BIT"),
	STENCIL_FRONT_AND_BACK = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FRONT_AND_BACK"),
	STENCIL_FACE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM"),
	BUFFER_CREATE_SPARSE_BINDING_BIT = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_SPARSE_BINDING_BIT"),
	BUFFER_CREATE_SPARSE_RESIDENCY_BIT = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT"),
	BUFFER_CREATE_SPARSE_ALIASED_BIT = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT"),
	BUFFER_CREATE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM"),
	COMMAND_BUFFER_LEVEL_PRIMARY = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_PRIMARY"),
	COMMAND_BUFFER_LEVEL_SECONDARY = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_SECONDARY"),
	COMMAND_BUFFER_LEVEL_BEGIN_RANGE = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE"),
	COMMAND_BUFFER_LEVEL_END_RANGE = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_END_RANGE"),
	COMMAND_BUFFER_LEVEL_RANGE_SIZE = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE"),
	COMMAND_BUFFER_LEVEL_MAX_ENUM = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_MAX_ENUM"),
	DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = ffi.cast("enum VkDescriptorPoolCreateFlagBits", "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT"),
	DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = ffi.cast("enum VkDescriptorPoolCreateFlagBits", "VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM"),
	query_pipeline_statistic = {
		clipping_primitives = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT"),
		fragment_shader_invocations = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT"),
		geometry_shader_primitives = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT"),
		input_assembly_primitives = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT"),
		compute_shader_invocations = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM"),
		tessellation_evaluation_shader_invocations = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT"),
		tessellation_control_shader_patches = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT"),
		vertex_shader_invocations = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT"),
		clipping_invocations = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.query_pipeline_statistic[v] end return bit.bor(unpack(flags)) end,
		geometry_shader_invocations = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT"),
		input_assembly_vertices = ffi.cast("enum VkQueryPipelineStatisticFlagBits", "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT"),
	},
	front_face = {
		counter_clockwise = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_COUNTER_CLOCKWISE"),
		end_range = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_END_RANGE"),
		max_enum = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_MAX_ENUM"),
		begin_range = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_RANGE_SIZE"),
		clockwise = ffi.cast("enum VkFrontFace", "VK_FRONT_FACE_CLOCKWISE"),
	},
	display_plane_alpha = {
		flag_bits_max_enum = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR"),
		per_pixel = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR"),
		global = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.display_plane_alpha[v] end return bit.bor(unpack(flags)) end,
		per_pixel_premultiplied = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR"),
		opaque = ffi.cast("enum VkDisplayPlaneAlphaFlagBitsKHR", "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR"),
	},
	attachment_store_op = {
		end_range = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_END_RANGE"),
		max_enum = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_MAX_ENUM"),
		range_size = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_RANGE_SIZE"),
		begin_range = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_BEGIN_RANGE"),
		dont_care = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_DONT_CARE"),
		store = ffi.cast("enum VkAttachmentStoreOp", "VK_ATTACHMENT_STORE_OP_STORE"),
	},
	command_buffer_reset = {
		flag_bits_max_enum = ffi.cast("enum VkCommandBufferResetFlagBits", "VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.command_buffer_reset[v] end return bit.bor(unpack(flags)) end,
		release_resources = ffi.cast("enum VkCommandBufferResetFlagBits", "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT"),
	},
	access = {
		color_attachment_write = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT"),
		transfer_write = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_TRANSFER_WRITE_BIT"),
		memory_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_MEMORY_READ_BIT"),
		shader_write = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_SHADER_WRITE_BIT"),
		uniform_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_UNIFORM_READ_BIT"),
		host_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_HOST_READ_BIT"),
		host_write = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_HOST_WRITE_BIT"),
		color_attachment_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT"),
		shader_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_SHADER_READ_BIT"),
		depth_stencil_attachment_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT"),
		memory_write = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_MEMORY_WRITE_BIT"),
		vertex_attribute_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT"),
		depth_stencil_attachment_write = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"),
		input_attachment_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT"),
		index_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_INDEX_READ_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.access[v] end return bit.bor(unpack(flags)) end,
		indirect_command_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_INDIRECT_COMMAND_READ_BIT"),
		transfer_read = ffi.cast("enum VkAccessFlagBits", "VK_ACCESS_TRANSFER_READ_BIT"),
	},
	internal_allocation_type = {
		end_range = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_END_RANGE"),
		max_enum = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM"),
		executable = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE"),
		begin_range = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkInternalAllocationType", "VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE"),
	},
	pipeline_create = {
		flag_bits_max_enum = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM"),
		disable_optimization = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT"),
		derivative = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_DERIVATIVE_BIT"),
		allow_derivatives = ffi.cast("enum VkPipelineCreateFlagBits", "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.pipeline_create[v] end return bit.bor(unpack(flags)) end,
	},
	stencil_face = {
		front_and_back = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FRONT_AND_BACK"),
		back = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FACE_BACK_BIT"),
		front = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FACE_FRONT_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.stencil_face[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkStencilFaceFlagBits", "VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM"),
	},
	blend_factor = {
		src_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC_ALPHA"),
		max_enum = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_MAX_ENUM"),
		one_minus_dst_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR"),
		one_minus_src_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR"),
		constant_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_CONSTANT_COLOR"),
		one_minus_constant_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA"),
		one_minus_src1_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR"),
		zero = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ZERO"),
		range_size = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_RANGE_SIZE"),
		one_minus_dst_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA"),
		one_minus_src_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA"),
		src_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC_COLOR"),
		dst_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_DST_ALPHA"),
		src1_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC1_COLOR"),
		dst_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_DST_COLOR"),
		one_minus_constant_color = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR"),
		end_range = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_END_RANGE"),
		src_alpha_saturate = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE"),
		constant_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_CONSTANT_ALPHA"),
		begin_range = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_BEGIN_RANGE"),
		src1_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_SRC1_ALPHA"),
		one_minus_src1_alpha = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA"),
		one = ffi.cast("enum VkBlendFactor", "VK_BLEND_FACTOR_ONE"),
	},
	command_buffer_level = {
		end_range = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_END_RANGE"),
		secondary = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_SECONDARY"),
		max_enum = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_MAX_ENUM"),
		begin_range = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE"),
		primary = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_PRIMARY"),
		range_size = ffi.cast("enum VkCommandBufferLevel", "VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE"),
	},
	pipeline_bind_point = {
		end_range = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_END_RANGE"),
		max_enum = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_MAX_ENUM"),
		compute = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_COMPUTE"),
		begin_range = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_RANGE_SIZE"),
		graphics = ffi.cast("enum VkPipelineBindPoint", "VK_PIPELINE_BIND_POINT_GRAPHICS"),
	},
	structure_type = {
		pipeline_input_assembly_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"),
		pipeline_dynamic_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"),
		display_present_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"),
		command_buffer_inheritance_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"),
		descriptor_set_allocate_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"),
		begin_range = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BEGIN_RANGE"),
		display_surface_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"),
		compute_pipeline_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"),
		present_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"),
		sampler_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"),
		win32_keyed_mutex_acquire_release_info_nv = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV"),
		pipeline_rasterization_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"),
		loader_instance_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO"),
		import_memory_win32_handle_info_nv = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV"),
		buffer_view_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"),
		command_buffer_allocate_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"),
		write_descriptor_set = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"),
		image_view_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"),
		max_enum = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MAX_ENUM"),
		shader_module_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"),
		debug_marker_object_name_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"),
		command_buffer_begin_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"),
		mir_surface_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR"),
		graphics_pipeline_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"),
		event_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"),
		instance_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"),
		pipeline_vertex_input_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"),
		debug_marker_object_tag_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"),
		debug_marker_marker_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"),
		command_pool_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"),
		pipeline_rasterization_state_rasterization_order_amd = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"),
		image_memory_barrier = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"),
		buffer_memory_barrier = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"),
		application_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_APPLICATION_INFO"),
		bind_sparse_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"),
		pipeline_multisample_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"),
		device_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"),
		mapped_memory_range = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"),
		render_pass_begin_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"),
		debug_report_callback_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"),
		end_range = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_END_RANGE"),
		device_queue_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"),
		memory_barrier = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_BARRIER"),
		wayland_surface_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR"),
		image_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"),
		swapchain_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"),
		pipeline_layout_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"),
		fence_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"),
		copy_descriptor_set = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"),
		query_pool_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"),
		framebuffer_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"),
		buffer_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"),
		pipeline_shader_stage_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"),
		pipeline_tessellation_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"),
		range_size = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RANGE_SIZE"),
		export_memory_allocate_info_nv = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV"),
		export_memory_win32_handle_info_nv = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV"),
		external_memory_image_create_info_nv = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV"),
		pipeline_color_blend_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"),
		dedicated_allocation_memory_allocate_info_nv = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"),
		win32_surface_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR"),
		memory_allocate_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"),
		dedicated_allocation_image_create_info_nv = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"),
		display_mode_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"),
		dedicated_allocation_buffer_create_info_nv = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"),
		pipeline_viewport_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"),
		submit_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SUBMIT_INFO"),
		semaphore_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"),
		descriptor_set_layout_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"),
		descriptor_pool_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"),
		render_pass_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"),
		xcb_surface_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR"),
		pipeline_depth_stencil_state_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"),
		loader_device_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO"),
		xlib_surface_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR"),
		pipeline_cache_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"),
		android_surface_create_info = ffi.cast("enum VkStructureType", "VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR"),
	},
	system_allocation_scope = {
		object = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT"),
		end_range = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE"),
		max_enum = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM"),
		cache = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_CACHE"),
		command = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND"),
		device = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE"),
		begin_range = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE"),
		instance = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE"),
		range_size = ffi.cast("enum VkSystemAllocationScope", "VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE"),
	},
	format_feature = {
		blit_src = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_BLIT_SRC_BIT"),
		color_attachment_blend = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT"),
		sampled_image_filter_cubic_bit_img = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG"),
		storage_image_atomic = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT"),
		sampled_image = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT"),
		sampled_image_filter_linear = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT"),
		blit_dst = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_BLIT_DST_BIT"),
		depth_stencil_attachment = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM"),
		uniform_texel_buffer = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT"),
		storage_texel_buffer_atomic = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT"),
		vertex_buffer = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT"),
		color_attachment = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.format_feature[v] end return bit.bor(unpack(flags)) end,
		storage_image = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT"),
		storage_texel_buffer = ffi.cast("enum VkFormatFeatureFlagBits", "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT"),
	},
	command_buffer_usage = {
		render_pass_continue = ffi.cast("enum VkCommandBufferUsageFlagBits", "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT"),
		simultaneous_use = ffi.cast("enum VkCommandBufferUsageFlagBits", "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.command_buffer_usage[v] end return bit.bor(unpack(flags)) end,
		one_time_submit = ffi.cast("enum VkCommandBufferUsageFlagBits", "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkCommandBufferUsageFlagBits", "VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM"),
	},
	query_control = {
		flag_bits_max_enum = ffi.cast("enum VkQueryControlFlagBits", "VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.query_control[v] end return bit.bor(unpack(flags)) end,
		precise = ffi.cast("enum VkQueryControlFlagBits", "VK_QUERY_CONTROL_PRECISE_BIT"),
	},
	logic_op = {
		["or"] = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_OR"),
		invert = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_INVERT"),
		max_enum = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_MAX_ENUM"),
		or_reverse = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_OR_REVERSE"),
		nor = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_NOR"),
		nand = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_NAND"),
		begin_range = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_RANGE_SIZE"),
		end_range = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_END_RANGE"),
		set = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_SET"),
		and_reverse = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_AND_REVERSE"),
		["and"] = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_AND"),
		or_inverted = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_OR_INVERTED"),
		copy_inverted = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_COPY_INVERTED"),
		no_op = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_NO_OP"),
		copy = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_COPY"),
		and_inverted = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_AND_INVERTED"),
		equivalent = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_EQUIVALENT"),
		clear = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_CLEAR"),
		xor = ffi.cast("enum VkLogicOp", "VK_LOGIC_OP_XOR"),
	},
	command_pool_create = {
		transient = ffi.cast("enum VkCommandPoolCreateFlagBits", "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.command_pool_create[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkCommandPoolCreateFlagBits", "VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM"),
		reset_command_buffer = ffi.cast("enum VkCommandPoolCreateFlagBits", "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"),
	},
	primitive_topology = {
		line_list = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_LIST"),
		triangle_list_with_adjacency = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY"),
		end_range = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_END_RANGE"),
		triangle_fan = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN"),
		max_enum = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_MAX_ENUM"),
		line_list_with_adjacency = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY"),
		range_size = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE"),
		point_list = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_POINT_LIST"),
		line_strip = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP"),
		line_strip_with_adjacency = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY"),
		triangle_strip_with_adjacency = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY"),
		triangle_strip = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP"),
		begin_range = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE"),
		triangle_list = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST"),
		patch_list = ffi.cast("enum VkPrimitiveTopology", "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST"),
	},
	present_mode = {
		fifo = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_FIFO_KHR"),
		mailbox = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_MAILBOX_KHR"),
		fifo_relaxed = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_FIFO_RELAXED_KHR"),
		max_enum = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_MAX_ENUM_KHR"),
		immediate = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_IMMEDIATE_KHR"),
		begin_range = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_BEGIN_RANGE_KHR"),
		end_range = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_END_RANGE_KHR"),
		range_size = ffi.cast("enum VkPresentModeKHR", "VK_PRESENT_MODE_RANGE_SIZE_KHR"),
	},
	physical_device_type = {
		integrated_gpu = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU"),
		end_range = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_END_RANGE"),
		other = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_OTHER"),
		max_enum = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM"),
		virtual_gpu = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU"),
		discrete_gpu = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU"),
		cpu = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_CPU"),
		begin_range = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkPhysicalDeviceType", "VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE"),
	},
	sampler_address_mode = {
		end_range = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_END_RANGE"),
		["repeat"] = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_REPEAT"),
		clamp_to_border = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"),
		mirrored_repeat = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT"),
		max_enum = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_MAX_ENUM"),
		clamp_to_edge = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE"),
		begin_range = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE"),
		mirror_clamp_to_edge = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE"),
		range_size = ffi.cast("enum VkSamplerAddressMode", "VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE"),
	},
	debug_report = {
		warning = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_WARNING_BIT_EXT"),
		flag_bits_max_enum = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT"),
		performance_warning = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT"),
		debug = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_DEBUG_BIT_EXT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.debug_report[v] end return bit.bor(unpack(flags)) end,
		error = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_ERROR_BIT_EXT"),
		information = ffi.cast("enum VkDebugReportFlagBitsEXT", "VK_DEBUG_REPORT_INFORMATION_BIT_EXT"),
	},
	image_create = {
		flag_bits_max_enum = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM"),
		sparse_aliased = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT"),
		cube_compatible = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT"),
		mutable_format = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.image_create[v] end return bit.bor(unpack(flags)) end,
		sparse_binding = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_SPARSE_BINDING_BIT"),
		sparse_residency = ffi.cast("enum VkImageCreateFlagBits", "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"),
	},
	filter = {
		linear = ffi.cast("enum VkFilter", "VK_FILTER_LINEAR"),
		nearest = ffi.cast("enum VkFilter", "VK_FILTER_NEAREST"),
		max_enum = ffi.cast("enum VkFilter", "VK_FILTER_MAX_ENUM"),
		cubic_img = ffi.cast("enum VkFilter", "VK_FILTER_CUBIC_IMG"),
		begin_range = ffi.cast("enum VkFilter", "VK_FILTER_BEGIN_RANGE"),
		end_range = ffi.cast("enum VkFilter", "VK_FILTER_END_RANGE"),
		range_size = ffi.cast("enum VkFilter", "VK_FILTER_RANGE_SIZE"),
	},
	image_tiling = {
		linear = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_LINEAR"),
		end_range = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_END_RANGE"),
		max_enum = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_MAX_ENUM"),
		begin_range = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_RANGE_SIZE"),
		optimal = ffi.cast("enum VkImageTiling", "VK_IMAGE_TILING_OPTIMAL"),
	},
	composite_alpha = {
		flag_bits_max_enum = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR"),
		opaque = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.composite_alpha[v] end return bit.bor(unpack(flags)) end,
		post_multiplied = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR"),
		inherit = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR"),
		pre_multiplied = ffi.cast("enum VkCompositeAlphaFlagBitsKHR", "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR"),
	},
	attachment_description = {
		flag_bits_max_enum = ffi.cast("enum VkAttachmentDescriptionFlagBits", "VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.attachment_description[v] end return bit.bor(unpack(flags)) end,
		may_alias = ffi.cast("enum VkAttachmentDescriptionFlagBits", "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT"),
	},
	command_pool_reset = {
		flag_bits_max_enum = ffi.cast("enum VkCommandPoolResetFlagBits", "VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.command_pool_reset[v] end return bit.bor(unpack(flags)) end,
		release_resources = ffi.cast("enum VkCommandPoolResetFlagBits", "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT"),
	},
	format = {
		r64g64b64_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64_SINT"),
		b8g8r8_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_USCALED"),
		r8g8_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SNORM"),
		r8g8b8a8_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SINT"),
		r64g64_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64_SINT"),
		astc_5x4_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x4_SRGB_BLOCK"),
		begin_range = ffi.cast("enum VkFormat", "VK_FORMAT_BEGIN_RANGE"),
		r8g8_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_USCALED"),
		eac_r11g11_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11G11_UNORM_BLOCK"),
		astc_10x10_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x10_UNORM_BLOCK"),
		a2r10g10b10_sint_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_SINT_PACK32"),
		d32_sfloat_s8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_D32_SFLOAT_S8_UINT"),
		astc_12x12_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x12_SRGB_BLOCK"),
		r64g64b64a64_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64A64_SINT"),
		b8g8r8a8_srgb = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SRGB"),
		d16_unorm_s8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_D16_UNORM_S8_UINT"),
		r8g8_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SINT"),
		r64g64_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64_UINT"),
		range_size = ffi.cast("enum VkFormat", "VK_FORMAT_RANGE_SIZE"),
		r16g16b16_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SINT"),
		r8g8b8_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SINT"),
		d24_unorm_s8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_D24_UNORM_S8_UINT"),
		a2b10g10r10_unorm_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_UNORM_PACK32"),
		astc_12x12_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x12_UNORM_BLOCK"),
		r16g16_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SSCALED"),
		s8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_S8_UINT"),
		r16g16b16a16_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SFLOAT"),
		r8g8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_UINT"),
		pvrtc2_2bpp_srgb_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG"),
		pvrtc1_4bpp_srgb_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG"),
		pvrtc2_4bpp_srgb_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG"),
		r64g64b64a64_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64A64_SFLOAT"),
		r64g64b64a64_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64A64_UINT"),
		a2r10g10b10_unorm_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_UNORM_PACK32"),
		r16g16b16_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SFLOAT"),
		r16_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16_UNORM"),
		r8g8b8a8_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SSCALED"),
		r16g16b16_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SSCALED"),
		r32_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R32_SINT"),
		r16_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R16_UINT"),
		bc1_rgba_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGBA_UNORM_BLOCK"),
		r16_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16_USCALED"),
		a8b8g8r8_snorm_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SNORM_PACK32"),
		b8g8r8a8_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SSCALED"),
		b10g11r11_ufloat_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_B10G11R11_UFLOAT_PACK32"),
		bc1_rgba_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGBA_SRGB_BLOCK"),
		r8g8b8a8_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_UNORM"),
		r16g16b16a16_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_USCALED"),
		etc2_r8g8b8a8_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK"),
		r8g8b8a8_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_USCALED"),
		pvrtc1_2bpp_srgb_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG"),
		bc4_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC4_UNORM_BLOCK"),
		pvrtc2_4bpp_unorm_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG"),
		bc5_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC5_UNORM_BLOCK"),
		astc_10x5_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x5_SRGB_BLOCK"),
		r8g8b8_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SSCALED"),
		etc2_r8g8b8a1_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK"),
		pvrtc1_4bpp_unorm_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG"),
		a8b8g8r8_uint_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_UINT_PACK32"),
		r8g8_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SSCALED"),
		r32g32b32_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32_SFLOAT"),
		bc7_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC7_UNORM_BLOCK"),
		pvrtc1_2bpp_unorm_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG"),
		astc_12x10_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x10_SRGB_BLOCK"),
		etc2_r8g8b8a8_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK"),
		eac_r11_snorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11_SNORM_BLOCK"),
		astc_12x10_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_12x10_UNORM_BLOCK"),
		astc_10x10_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x10_SRGB_BLOCK"),
		r5g6b5_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_R5G6B5_UNORM_PACK16"),
		r32g32b32_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32_UINT"),
		r64_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R64_UINT"),
		astc_10x8_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x8_SRGB_BLOCK"),
		r32g32b32_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32_SINT"),
		bc1_rgb_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGB_UNORM_BLOCK"),
		r64g64b64_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64_SFLOAT"),
		etc2_r8g8b8_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK"),
		a2b10g10r10_uscaled_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_USCALED_PACK32"),
		r4g4_unorm_pack8 = ffi.cast("enum VkFormat", "VK_FORMAT_R4G4_UNORM_PACK8"),
		astc_10x6_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x6_SRGB_BLOCK"),
		e5b9g9r9_ufloat_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32"),
		astc_10x5_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x5_UNORM_BLOCK"),
		r16g16_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_UINT"),
		r32g32b32a32_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32A32_UINT"),
		astc_8x8_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x8_UNORM_BLOCK"),
		astc_8x6_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x6_SRGB_BLOCK"),
		astc_8x6_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x6_UNORM_BLOCK"),
		a8b8g8r8_srgb_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SRGB_PACK32"),
		b8g8r8_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SSCALED"),
		r16g16_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SFLOAT"),
		astc_5x5_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x5_SRGB_BLOCK"),
		astc_6x5_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x5_SRGB_BLOCK"),
		astc_8x5_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x5_SRGB_BLOCK"),
		a8b8g8r8_unorm_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_UNORM_PACK32"),
		astc_8x5_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x5_UNORM_BLOCK"),
		r8g8_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_UNORM"),
		r32g32_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32_SFLOAT"),
		astc_6x6_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x6_SRGB_BLOCK"),
		astc_6x6_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x6_UNORM_BLOCK"),
		r16g16b16_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_UNORM"),
		astc_6x5_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_6x5_UNORM_BLOCK"),
		astc_5x5_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x5_UNORM_BLOCK"),
		r32g32_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32_SINT"),
		astc_5x4_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_5x4_UNORM_BLOCK"),
		a8b8g8r8_uscaled_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_USCALED_PACK32"),
		r64_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R64_SFLOAT"),
		astc_4x4_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_4x4_SRGB_BLOCK"),
		max_enum = ffi.cast("enum VkFormat", "VK_FORMAT_MAX_ENUM"),
		a2b10g10r10_snorm_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_SNORM_PACK32"),
		eac_r11g11_snorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11G11_SNORM_BLOCK"),
		a8b8g8r8_sscaled_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SSCALED_PACK32"),
		a2b10g10r10_uint_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_UINT_PACK32"),
		bc2_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC2_SRGB_BLOCK"),
		x8_d24_unorm_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_X8_D24_UNORM_PACK32"),
		r8_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SSCALED"),
		b8g8r8_srgb = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SRGB"),
		a1r5g5b5_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_A1R5G5B5_UNORM_PACK16"),
		b5g6r5_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_B5G6R5_UNORM_PACK16"),
		r16_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SFLOAT"),
		b8g8r8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_UINT"),
		undefined = ffi.cast("enum VkFormat", "VK_FORMAT_UNDEFINED"),
		eac_r11_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_EAC_R11_UNORM_BLOCK"),
		etc2_r8g8b8a1_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK"),
		r16_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SSCALED"),
		a2r10g10b10_snorm_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_SNORM_PACK32"),
		pvrtc2_2bpp_unorm_block_img = ffi.cast("enum VkFormat", "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG"),
		r16g16b16_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_UINT"),
		r16g16b16a16_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SINT"),
		bc3_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC3_SRGB_BLOCK"),
		b8g8r8_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_UNORM"),
		b8g8r8a8_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_USCALED"),
		etc2_r8g8b8_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK"),
		bc7_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC7_SRGB_BLOCK"),
		r16g16b16_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_USCALED"),
		d32_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_D32_SFLOAT"),
		bc6h_ufloat_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC6H_UFLOAT_BLOCK"),
		r64_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R64_SINT"),
		bc5_snorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC5_SNORM_BLOCK"),
		r8_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SNORM"),
		bc4_snorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC4_SNORM_BLOCK"),
		r16_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SNORM"),
		bc3_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC3_UNORM_BLOCK"),
		bc2_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC2_UNORM_BLOCK"),
		r32g32_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32_UINT"),
		bc1_rgb_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC1_RGB_SRGB_BLOCK"),
		astc_10x6_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x6_UNORM_BLOCK"),
		r8_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8_USCALED"),
		b8g8r8a8_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SNORM"),
		r8g8b8a8_srgb = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SRGB"),
		astc_4x4_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_4x4_UNORM_BLOCK"),
		r8g8b8_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_UNORM"),
		a2r10g10b10_uscaled_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_USCALED_PACK32"),
		end_range = ffi.cast("enum VkFormat", "VK_FORMAT_END_RANGE"),
		b8g8r8a8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_UINT"),
		b5g5r5a1_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_B5G5R5A1_UNORM_PACK16"),
		astc_10x8_unorm_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_10x8_UNORM_BLOCK"),
		astc_8x8_srgb_block = ffi.cast("enum VkFormat", "VK_FORMAT_ASTC_8x8_SRGB_BLOCK"),
		r16g16b16_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16_SNORM"),
		b4g4r4a4_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_B4G4R4A4_UNORM_PACK16"),
		a2r10g10b10_uint_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_UINT_PACK32"),
		r16g16_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SNORM"),
		r8_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SINT"),
		r16g16_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_SINT"),
		r8g8b8a8_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_SNORM"),
		a8b8g8r8_sint_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A8B8G8R8_SINT_PACK32"),
		b8g8r8a8_sint = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_SINT"),
		r8_srgb = ffi.cast("enum VkFormat", "VK_FORMAT_R8_SRGB"),
		r8g8b8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_UINT"),
		r8g8b8_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_USCALED"),
		r8g8b8a8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8A8_UINT"),
		b8g8r8a8_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8A8_UNORM"),
		r8g8b8_srgb = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SRGB"),
		r8g8b8_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8B8_SNORM"),
		r64g64_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64_SFLOAT"),
		a2b10g10r10_sint_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_SINT_PACK32"),
		r64g64b64_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R64G64B64_UINT"),
		r16_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R16_SINT"),
		a2r10g10b10_sscaled_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2R10G10B10_SSCALED_PACK32"),
		a2b10g10r10_sscaled_pack32 = ffi.cast("enum VkFormat", "VK_FORMAT_A2B10G10R10_SSCALED_PACK32"),
		r16g16_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_UNORM"),
		r4g4b4a4_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_R4G4B4A4_UNORM_PACK16"),
		r16g16_uscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16_USCALED"),
		bc6h_sfloat_block = ffi.cast("enum VkFormat", "VK_FORMAT_BC6H_SFLOAT_BLOCK"),
		b8g8r8_sint = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SINT"),
		r5g5b5a1_unorm_pack16 = ffi.cast("enum VkFormat", "VK_FORMAT_R5G5B5A1_UNORM_PACK16"),
		r8g8_srgb = ffi.cast("enum VkFormat", "VK_FORMAT_R8G8_SRGB"),
		r16g16b16a16_sscaled = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SSCALED"),
		r8_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R8_UNORM"),
		r16g16b16a16_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_UNORM"),
		r8_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R8_UINT"),
		r16g16b16a16_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_UINT"),
		r16g16b16a16_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_R16G16B16A16_SNORM"),
		d16_unorm = ffi.cast("enum VkFormat", "VK_FORMAT_D16_UNORM"),
		b8g8r8_snorm = ffi.cast("enum VkFormat", "VK_FORMAT_B8G8R8_SNORM"),
		r32_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R32_SFLOAT"),
		r32g32b32a32_sfloat = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32A32_SFLOAT"),
		r32g32b32a32_sint = ffi.cast("enum VkFormat", "VK_FORMAT_R32G32B32A32_SINT"),
		r32_uint = ffi.cast("enum VkFormat", "VK_FORMAT_R32_UINT"),
	},
	vertex_input_rate = {
		end_range = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_END_RANGE"),
		max_enum = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_MAX_ENUM"),
		vertex = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_VERTEX"),
		instance = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_INSTANCE"),
		begin_range = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkVertexInputRate", "VK_VERTEX_INPUT_RATE_RANGE_SIZE"),
	},
	dynamic_state = {
		blend_constants = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_BLEND_CONSTANTS"),
		stencil_write_mask = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK"),
		end_range = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_END_RANGE"),
		viewport = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_VIEWPORT"),
		depth_bias = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_DEPTH_BIAS"),
		line_width = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_LINE_WIDTH"),
		max_enum = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_MAX_ENUM"),
		stencil_compare_mask = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK"),
		begin_range = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_BEGIN_RANGE"),
		depth_bounds = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_DEPTH_BOUNDS"),
		scissor = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_SCISSOR"),
		stencil_reference = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_STENCIL_REFERENCE"),
		range_size = ffi.cast("enum VkDynamicState", "VK_DYNAMIC_STATE_RANGE_SIZE"),
	},
	polygon_mode = {
		line = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_LINE"),
		end_range = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_END_RANGE"),
		max_enum = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_MAX_ENUM"),
		begin_range = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_BEGIN_RANGE"),
		point = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_POINT"),
		fill = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_FILL"),
		range_size = ffi.cast("enum VkPolygonMode", "VK_POLYGON_MODE_RANGE_SIZE"),
	},
	image_type = {
		["1d"] = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_1D"),
		end_range = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_END_RANGE"),
		["3d"] = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_3D"),
		max_enum = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_MAX_ENUM"),
		begin_range = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_BEGIN_RANGE"),
		["2d"] = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_2D"),
		range_size = ffi.cast("enum VkImageType", "VK_IMAGE_TYPE_RANGE_SIZE"),
	},
	cull_mode = {
		none = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_NONE"),
		back = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_BACK_BIT"),
		front = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_FRONT_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.cull_mode[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_FLAG_BITS_MAX_ENUM"),
		front_and_back = ffi.cast("enum VkCullModeFlagBits", "VK_CULL_MODE_FRONT_AND_BACK"),
	},
	buffer_create = {
		flag_bits_max_enum = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM"),
		sparse_aliased = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.buffer_create[v] end return bit.bor(unpack(flags)) end,
		sparse_binding = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_SPARSE_BINDING_BIT"),
		sparse_residency = ffi.cast("enum VkBufferCreateFlagBits", "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT"),
	},
	queue = {
		flag_bits_max_enum = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_FLAG_BITS_MAX_ENUM"),
		sparse_binding = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_SPARSE_BINDING_BIT"),
		compute = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_COMPUTE_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.queue[v] end return bit.bor(unpack(flags)) end,
		graphics = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_GRAPHICS_BIT"),
		transfer = ffi.cast("enum VkQueueFlagBits", "VK_QUEUE_TRANSFER_BIT"),
	},
	image_usage = {
		sampled = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_SAMPLED_BIT"),
		color_attachment = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT"),
		transfer_src = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_TRANSFER_SRC_BIT"),
		input_attachment = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT"),
		transfer_dst = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_TRANSFER_DST_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM"),
		depth_stencil_attachment = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.image_usage[v] end return bit.bor(unpack(flags)) end,
		transient_attachment = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT"),
		storage = ffi.cast("enum VkImageUsageFlagBits", "VK_IMAGE_USAGE_STORAGE_BIT"),
	},
	stencil_op = {
		invert = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_INVERT"),
		max_enum = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_MAX_ENUM"),
		decrement_and_clamp = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_DECREMENT_AND_CLAMP"),
		increment_and_wrap = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_INCREMENT_AND_WRAP"),
		end_range = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_END_RANGE"),
		begin_range = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_BEGIN_RANGE"),
		replace = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_REPLACE"),
		decrement_and_wrap = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_DECREMENT_AND_WRAP"),
		zero = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_ZERO"),
		increment_and_clamp = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_INCREMENT_AND_CLAMP"),
		keep = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_KEEP"),
		range_size = ffi.cast("enum VkStencilOp", "VK_STENCIL_OP_RANGE_SIZE"),
	},
	shader_stage = {
		compute = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_COMPUTE_BIT"),
		fragment = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_FRAGMENT_BIT"),
		all = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_ALL"),
		flag_bits_max_enum = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM"),
		geometry = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_GEOMETRY_BIT"),
		all_graphics = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_ALL_GRAPHICS"),
		vertex = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_VERTEX_BIT"),
		tessellation_control = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT"),
		tessellation_evaluation = ffi.cast("enum VkShaderStageFlagBits", "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.shader_stage[v] end return bit.bor(unpack(flags)) end,
	},
	sparse_memory_bind = {
		metadata = ffi.cast("enum VkSparseMemoryBindFlagBits", "VK_SPARSE_MEMORY_BIND_METADATA_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.sparse_memory_bind[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkSparseMemoryBindFlagBits", "VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM"),
	},
	image_layout = {
		present_src = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR"),
		transfer_dst_optimal = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"),
		preinitialized = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_PREINITIALIZED"),
		general = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_GENERAL"),
		max_enum = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_MAX_ENUM"),
		transfer_src_optimal = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL"),
		undefined = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_UNDEFINED"),
		depth_stencil_attachment_optimal = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL"),
		shader_read_only_optimal = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL"),
		end_range = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_END_RANGE"),
		depth_stencil_read_only_optimal = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL"),
		begin_range = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_BEGIN_RANGE"),
		color_attachment_optimal = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL"),
		range_size = ffi.cast("enum VkImageLayout", "VK_IMAGE_LAYOUT_RANGE_SIZE"),
	},
	debug_report_error = {
		none = ffi.cast("enum VkDebugReportErrorEXT", "VK_DEBUG_REPORT_ERROR_NONE_EXT"),
		end_range = ffi.cast("enum VkDebugReportErrorEXT", "VK_DEBUG_REPORT_ERROR_END_RANGE_EXT"),
		callback_ref = ffi.cast("enum VkDebugReportErrorEXT", "VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT"),
		begin_range = ffi.cast("enum VkDebugReportErrorEXT", "VK_DEBUG_REPORT_ERROR_BEGIN_RANGE_EXT"),
		max_enum = ffi.cast("enum VkDebugReportErrorEXT", "VK_DEBUG_REPORT_ERROR_MAX_ENUM_EXT"),
		range_size = ffi.cast("enum VkDebugReportErrorEXT", "VK_DEBUG_REPORT_ERROR_RANGE_SIZE_EXT"),
	},
	query_result = {
		flag_bits_max_enum = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM"),
		["64"] = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_64_BIT"),
		with_availability = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.query_result[v] end return bit.bor(unpack(flags)) end,
		partial = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_PARTIAL_BIT"),
		wait = ffi.cast("enum VkQueryResultFlagBits", "VK_QUERY_RESULT_WAIT_BIT"),
	},
	surface_transform = {
		identity = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR"),
		rotate_90 = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR"),
		rotate_180 = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR"),
		horizontal_mirror_rotate_180 = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR"),
		horizontal_mirror_rotate_270 = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR"),
		rotate_270 = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR"),
		horizontal_mirror = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR"),
		flag_bits_max_enum = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.surface_transform[v] end return bit.bor(unpack(flags)) end,
		inherit = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR"),
		horizontal_mirror_rotate_90 = ffi.cast("enum VkSurfaceTransformFlagBitsKHR", "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR"),
	},
	external_memory_handle_type_nv = {
		que_win32_kmt_bit_nv = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsNV", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV"),
		["11_image_bit_nv"] = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsNV", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV"),
		g_bits_max_enum_nv = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsNV", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.external_memory_handle_type_nv[v] end return bit.bor(unpack(flags)) end,
		["11_image_kmt_bit_nv"] = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsNV", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV"),
		que_win32_bit_nv = ffi.cast("enum VkExternalMemoryHandleTypeFlagBitsNV", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV"),
	},
	descriptor_type = {
		max_enum = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_MAX_ENUM"),
		sampler = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_SAMPLER"),
		storage_image = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE"),
		sampled_image = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE"),
		input_attachment = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT"),
		uniform_buffer = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER"),
		combined_image_sampler = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"),
		storage_buffer_dynamic = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC"),
		uniform_texel_buffer = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER"),
		end_range = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_END_RANGE"),
		storage_texel_buffer = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER"),
		begin_range = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_BEGIN_RANGE"),
		uniform_buffer_dynamic = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC"),
		storage_buffer = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER"),
		range_size = ffi.cast("enum VkDescriptorType", "VK_DESCRIPTOR_TYPE_RANGE_SIZE"),
	},
	descriptor_pool_create = {
		flag_bits_max_enum = ffi.cast("enum VkDescriptorPoolCreateFlagBits", "VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.descriptor_pool_create[v] end return bit.bor(unpack(flags)) end,
		free_descriptor_set = ffi.cast("enum VkDescriptorPoolCreateFlagBits", "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT"),
	},
	rasterization_order_amd = {
		enum_amd = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_MAX_ENUM_AMD"),
		ct_amd = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_STRICT_AMD"),
		e_size_amd = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD"),
		xed_amd = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_RELAXED_AMD"),
		range_amd = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_END_RANGE_AMD"),
		n_range_amd = ffi.cast("enum VkRasterizationOrderAMD", "VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD"),
	},
	compare_op = {
		not_equal = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_NOT_EQUAL"),
		end_range = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_END_RANGE"),
		greater_or_equal = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_GREATER_OR_EQUAL"),
		max_enum = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_MAX_ENUM"),
		never = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_NEVER"),
		equal = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_EQUAL"),
		less = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_LESS"),
		greater = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_GREATER"),
		less_or_equal = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_LESS_OR_EQUAL"),
		always = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_ALWAYS"),
		begin_range = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkCompareOp", "VK_COMPARE_OP_RANGE_SIZE"),
	},
	component_swizzle = {
		identity = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_IDENTITY"),
		one = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_ONE"),
		max_enum = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_MAX_ENUM"),
		g = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_G"),
		b = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_B"),
		zero = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_ZERO"),
		end_range = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_END_RANGE"),
		r = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_R"),
		begin_range = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_BEGIN_RANGE"),
		a = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_A"),
		range_size = ffi.cast("enum VkComponentSwizzle", "VK_COMPONENT_SWIZZLE_RANGE_SIZE"),
	},
	sparse_image_format = {
		nonstandard_block_size = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT"),
		aligned_mip_size = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.sparse_image_format[v] end return bit.bor(unpack(flags)) end,
		single_miptail = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkSparseImageFormatFlagBits", "VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM"),
	},
	dependency = {
		flag_bits_max_enum = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.dependency[v] end return bit.bor(unpack(flags)) end,
		by_region = ffi.cast("enum VkDependencyFlagBits", "VK_DEPENDENCY_BY_REGION_BIT"),
	},
	pipeline_cache_header_version = {
		end_range = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE"),
		max_enum = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM"),
		begin_range = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE"),
		one = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_ONE"),
		range_size = ffi.cast("enum VkPipelineCacheHeaderVersion", "VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE"),
	},
	sample_count = {
		["4"] = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_4_BIT"),
		["8"] = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_8_BIT"),
		["32"] = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_32_BIT"),
		["2"] = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_2_BIT"),
		["64"] = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_64_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.sample_count[v] end return bit.bor(unpack(flags)) end,
		["1"] = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_1_BIT"),
		["16"] = ffi.cast("enum VkSampleCountFlagBits", "VK_SAMPLE_COUNT_16_BIT"),
	},
	external_memory_feature_nv = {
		g_bits_max_enum_nv = ffi.cast("enum VkExternalMemoryFeatureFlagBitsNV", "VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.external_memory_feature_nv[v] end return bit.bor(unpack(flags)) end,
		ortable_bit_nv = ffi.cast("enum VkExternalMemoryFeatureFlagBitsNV", "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV"),
		icated_only_bit_nv = ffi.cast("enum VkExternalMemoryFeatureFlagBitsNV", "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV"),
	},
	query_type = {
		occlusion = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_OCCLUSION"),
		end_range = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_END_RANGE"),
		max_enum = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_MAX_ENUM"),
		begin_range = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_BEGIN_RANGE"),
		pipeline_statistics = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_PIPELINE_STATISTICS"),
		timestamp = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_TIMESTAMP"),
		range_size = ffi.cast("enum VkQueryType", "VK_QUERY_TYPE_RANGE_SIZE"),
	},
	pipeline_stage = {
		tessellation_control_shader = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT"),
		host = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_HOST_BIT"),
		draw_indirect = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT"),
		tessellation_evaluation_shader = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT"),
		color_attachment_output = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT"),
		early_fragment_tests = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT"),
		all_commands = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT"),
		all_graphics = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT"),
		top_of_pipe = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT"),
		compute_shader = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT"),
		vertex_input = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM"),
		transfer = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_TRANSFER_BIT"),
		bottom_of_pipe = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT"),
		late_fragment_tests = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT"),
		geometry_shader = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.pipeline_stage[v] end return bit.bor(unpack(flags)) end,
		vertex_shader = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT"),
		fragment_shader = ffi.cast("enum VkPipelineStageFlagBits", "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT"),
	},
	index_type = {
		uint32 = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_UINT32"),
		uint16 = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_UINT16"),
		max_enum = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_MAX_ENUM"),
		begin_range = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_BEGIN_RANGE"),
		end_range = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_END_RANGE"),
		range_size = ffi.cast("enum VkIndexType", "VK_INDEX_TYPE_RANGE_SIZE"),
	},
	fence_create = {
		signaled = ffi.cast("enum VkFenceCreateFlagBits", "VK_FENCE_CREATE_SIGNALED_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.fence_create[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkFenceCreateFlagBits", "VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM"),
	},
	debug_report_object_type = {
		swapchain = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT"),
		begin_range = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT"),
		end_range = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT"),
		buffer = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT"),
		command_pool = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT"),
		fence = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT"),
		pipeline_layout = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT"),
		event = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT"),
		pipeline = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT"),
		descriptor_set_layout = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT"),
		sampler = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT"),
		image_view = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT"),
		max_enum = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT"),
		surface = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT"),
		image = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT"),
		device_memory = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT"),
		buffer_view = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT"),
		range_size = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT"),
		debug_report = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT"),
		query_pool = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT"),
		framebuffer = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT"),
		semaphore = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT"),
		device = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT"),
		pipeline_cache = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT"),
		physical_device = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT"),
		instance = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT"),
		unknown = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT"),
		queue = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT"),
		shader_module = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT"),
		descriptor_pool = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT"),
		render_pass = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT"),
		descriptor_set = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT"),
		command_buffer = ffi.cast("enum VkDebugReportObjectTypeEXT", "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT"),
	},
	blend_op = {
		max = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MAX"),
		end_range = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_END_RANGE"),
		subtract = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_SUBTRACT"),
		max_enum = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MAX_ENUM"),
		min = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_MIN"),
		reverse_subtract = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_REVERSE_SUBTRACT"),
		begin_range = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_BEGIN_RANGE"),
		add = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_ADD"),
		range_size = ffi.cast("enum VkBlendOp", "VK_BLEND_OP_RANGE_SIZE"),
	},
	memory_heap = {
		device_local = ffi.cast("enum VkMemoryHeapFlagBits", "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.memory_heap[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkMemoryHeapFlagBits", "VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM"),
	},
	result = {
		error_validation_failed = ffi.cast("enum VkResult", "VK_ERROR_VALIDATION_FAILED_EXT"),
		error_initialization_failed = ffi.cast("enum VkResult", "VK_ERROR_INITIALIZATION_FAILED"),
		event_set = ffi.cast("enum VkResult", "VK_EVENT_SET"),
		error_memory_map_failed = ffi.cast("enum VkResult", "VK_ERROR_MEMORY_MAP_FAILED"),
		result_begin_range = ffi.cast("enum VkResult", "VK_RESULT_BEGIN_RANGE"),
		error_feature_not_present = ffi.cast("enum VkResult", "VK_ERROR_FEATURE_NOT_PRESENT"),
		result_max_enum = ffi.cast("enum VkResult", "VK_RESULT_MAX_ENUM"),
		error_incompatible_driver = ffi.cast("enum VkResult", "VK_ERROR_INCOMPATIBLE_DRIVER"),
		result_range_size = ffi.cast("enum VkResult", "VK_RESULT_RANGE_SIZE"),
		result_end_range = ffi.cast("enum VkResult", "VK_RESULT_END_RANGE"),
		not_ready = ffi.cast("enum VkResult", "VK_NOT_READY"),
		error_invalid_shader_nv = ffi.cast("enum VkResult", "VK_ERROR_INVALID_SHADER_NV"),
		error_incompatible_display = ffi.cast("enum VkResult", "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR"),
		incomplete = ffi.cast("enum VkResult", "VK_INCOMPLETE"),
		event_reset = ffi.cast("enum VkResult", "VK_EVENT_RESET"),
		error_out_of_date = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_DATE_KHR"),
		suboptimal = ffi.cast("enum VkResult", "VK_SUBOPTIMAL_KHR"),
		error_native_window_in_use = ffi.cast("enum VkResult", "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR"),
		error_out_of_device_memory = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_DEVICE_MEMORY"),
		timeout = ffi.cast("enum VkResult", "VK_TIMEOUT"),
		error_surface_lost = ffi.cast("enum VkResult", "VK_ERROR_SURFACE_LOST_KHR"),
		error_extension_not_present = ffi.cast("enum VkResult", "VK_ERROR_EXTENSION_NOT_PRESENT"),
		error_format_not_supported = ffi.cast("enum VkResult", "VK_ERROR_FORMAT_NOT_SUPPORTED"),
		error_device_lost = ffi.cast("enum VkResult", "VK_ERROR_DEVICE_LOST"),
		success = ffi.cast("enum VkResult", "VK_SUCCESS"),
		error_fragmented_pool = ffi.cast("enum VkResult", "VK_ERROR_FRAGMENTED_POOL"),
		error_layer_not_present = ffi.cast("enum VkResult", "VK_ERROR_LAYER_NOT_PRESENT"),
		error_out_of_host_memory = ffi.cast("enum VkResult", "VK_ERROR_OUT_OF_HOST_MEMORY"),
		error_too_many_objects = ffi.cast("enum VkResult", "VK_ERROR_TOO_MANY_OBJECTS"),
	},
	sharing_mode = {
		end_range = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_END_RANGE"),
		max_enum = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_MAX_ENUM"),
		exclusive = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_EXCLUSIVE"),
		begin_range = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_BEGIN_RANGE"),
		concurrent = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_CONCURRENT"),
		range_size = ffi.cast("enum VkSharingMode", "VK_SHARING_MODE_RANGE_SIZE"),
	},
	buffer_usage = {
		transfer_src = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_TRANSFER_SRC_BIT"),
		index_buffer = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_INDEX_BUFFER_BIT"),
		uniform_buffer = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM"),
		uniform_texel_buffer = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT"),
		vertex_buffer = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT"),
		storage_texel_buffer = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT"),
		indirect_buffer = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.buffer_usage[v] end return bit.bor(unpack(flags)) end,
		storage_buffer = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT"),
		transfer_dst = ffi.cast("enum VkBufferUsageFlagBits", "VK_BUFFER_USAGE_TRANSFER_DST_BIT"),
	},
	sampler_mipmap_mode = {
		linear = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_LINEAR"),
		nearest = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_NEAREST"),
		max_enum = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_MAX_ENUM"),
		begin_range = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE"),
		end_range = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_END_RANGE"),
		range_size = ffi.cast("enum VkSamplerMipmapMode", "VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE"),
	},
	subpass_contents = {
		end_range = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_END_RANGE"),
		inline = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_INLINE"),
		secondary_command_buffers = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS"),
		begin_range = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_BEGIN_RANGE"),
		max_enum = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_MAX_ENUM"),
		range_size = ffi.cast("enum VkSubpassContents", "VK_SUBPASS_CONTENTS_RANGE_SIZE"),
	},
	color_component = {
		b = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_B_BIT"),
		flag_bits_max_enum = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM"),
		r = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_R_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.color_component[v] end return bit.bor(unpack(flags)) end,
		a = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_A_BIT"),
		g = ffi.cast("enum VkColorComponentFlagBits", "VK_COLOR_COMPONENT_G_BIT"),
	},
	attachment_load_op = {
		load = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_LOAD"),
		dont_care = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_DONT_CARE"),
		max_enum = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_MAX_ENUM"),
		end_range = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_END_RANGE"),
		begin_range = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE"),
		clear = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_CLEAR"),
		range_size = ffi.cast("enum VkAttachmentLoadOp", "VK_ATTACHMENT_LOAD_OP_RANGE_SIZE"),
	},
	image_aspect = {
		flag_bits_max_enum = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM"),
		stencil = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_STENCIL_BIT"),
		color = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_COLOR_BIT"),
		metadata = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_METADATA_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.image_aspect[v] end return bit.bor(unpack(flags)) end,
		depth = ffi.cast("enum VkImageAspectFlagBits", "VK_IMAGE_ASPECT_DEPTH_BIT"),
	},
	colorspace = {
		_begin_range = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_BEGIN_RANGE_KHR"),
		_end_range = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_END_RANGE_KHR"),
		_range_size = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_RANGE_SIZE_KHR"),
		_max_enum = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_MAX_ENUM_KHR"),
		_srgb_nonlinear = ffi.cast("enum VkColorSpaceKHR", "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR"),
	},
	border_color = {
		end_range = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_END_RANGE"),
		float_opaque_white = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE"),
		float_transparent_black = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK"),
		max_enum = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_MAX_ENUM"),
		int_opaque_white = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_INT_OPAQUE_WHITE"),
		range_size = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_RANGE_SIZE"),
		int_opaque_black = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_INT_OPAQUE_BLACK"),
		begin_range = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_BEGIN_RANGE"),
		int_transparent_black = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK"),
		float_opaque_black = ffi.cast("enum VkBorderColor", "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK"),
	},
	image_view_type = {
		["2d_array"] = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_2D_ARRAY"),
		end_range = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_END_RANGE"),
		["3d"] = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_3D"),
		max_enum = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_MAX_ENUM"),
		["2d"] = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_2D"),
		["1d"] = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_1D"),
		cube = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_CUBE"),
		cube_array = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"),
		begin_range = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_BEGIN_RANGE"),
		range_size = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_RANGE_SIZE"),
		["1d_array"] = ffi.cast("enum VkImageViewType", "VK_IMAGE_VIEW_TYPE_1D_ARRAY"),
	},
	memory_property = {
		device_local = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT"),
		host_coherent = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"),
		host_cached = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_HOST_CACHED_BIT"),
		lazily_allocated = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT"),
		make_enums = function(flags) if #flags == 0 then return 0 end for i,v in ipairs(flags) do flags[i] = library.e.memory_property[v] end return bit.bor(unpack(flags)) end,
		flag_bits_max_enum = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM"),
		host_visible = ffi.cast("enum VkMemoryPropertyFlagBits", "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT"),
	},
}
function library.GetInstanceLayerProperties()
	local count = ffi.new("uint32_t[1]")
	CLIB.vkEnumerateInstanceLayerProperties(count, nil)
	if count[0] == 0 then return end

	local array = ffi.new("struct VkLayerProperties [?]", count[0])
	local status = CLIB.vkEnumerateInstanceLayerProperties(count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end
function library.GetPhysicalDevices(instance)
	local count = ffi.new("uint32_t[1]")
	CLIB.vkEnumeratePhysicalDevices(instance, count, nil)
	if count[0] == 0 then return end

	local array = ffi.new("struct VkPhysicalDevice_T * [?]", count[0])
	local status = CLIB.vkEnumeratePhysicalDevices(instance, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end
function library.GetInstanceExtensionProperties(pLayerName)
	local count = ffi.new("uint32_t[1]")
	CLIB.vkEnumerateInstanceExtensionProperties(pLayerName, count, nil)
	if count[0] == 0 then return end

	local array = ffi.new("struct VkExtensionProperties [?]", count[0])
	local status = CLIB.vkEnumerateInstanceExtensionProperties(pLayerName, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end
function library.GetDeviceLayerProperties(physicalDevice)
	local count = ffi.new("uint32_t[1]")
	CLIB.vkEnumerateDeviceLayerProperties(physicalDevice, count, nil)
	if count[0] == 0 then return end

	local array = ffi.new("struct VkLayerProperties [?]", count[0])
	local status = CLIB.vkEnumerateDeviceLayerProperties(physicalDevice, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end
function library.GetDeviceExtensionProperties(physicalDevice, pLayerName)
	local count = ffi.new("uint32_t[1]")
	CLIB.vkEnumerateDeviceExtensionProperties(physicalDevice, pLayerName, count, nil)
	if count[0] == 0 then return end

	local array = ffi.new("struct VkExtensionProperties [?]", count[0])
	local status = CLIB.vkEnumerateDeviceExtensionProperties(physicalDevice, pLayerName, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end

	return nil, status
end
function library.GetBufferMemoryRequirements(device, buffer)
	local box = ffi.new("struct VkMemoryRequirements [1]")
	CLIB.vkGetBufferMemoryRequirements(device, buffer, box)
	return box[0]
end
function library.GetPipelineCacheData(device, pipelineCache, pDataSize)
	local box = ffi.new("void [1]")
	local status = CLIB.vkGetPipelineCacheData(device, pipelineCache, pDataSize, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetRenderAreaGranularity(device, renderPass)
	local box = ffi.new("struct VkExtent2D [1]")
	CLIB.vkGetRenderAreaGranularity(device, renderPass, box)
	return box[0]
end
function library.GetPhysicalDeviceQueueFamilyProperties(physicalDevice)
	local count = ffi.new("uint32_t[1]")

	CLIB.vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, count, nil)

	local array = ffi.new("struct VkQueueFamilyProperties [?]", count[0])
	CLIB.vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, count, array)

	local out = {}

	for i = 0, count[0] - 1 do
		out[i + 1] = array[i]
	end

	return out
end
function library.GetDisplayPlaneSupportedDisplays(physicalDevice, planeIndex)
	local count = ffi.new("uint32_t[1]")

	library.GetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, count, nil)

	local array = ffi.new("struct VkDisplayKHR_T * [?]", count[0])
	local status = library.GetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end
	return nil, status
end
function library.GetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling)
	if type(format) == "string" then
		format = library.e.format[format]
	end
	if type(type) == "string" then
		type = library.e.image_type[type]
	end
	if type(samples) == "table" then
		samples = library.e.sample_count.make_enums(samples)
	elseif type(samples) == "string" then
		samples = library.e.sample_count[samples]
	end
	if type(usage) == "table" then
		usage = library.e.image_usage.make_enums(usage)
	elseif type(usage) == "string" then
		usage = library.e.image_usage[usage]
	end
	if type(tiling) == "string" then
		tiling = library.e.image_tiling[tiling]
	end
	local count = ffi.new("uint32_t[1]")

	CLIB.vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, count, nil)

	local array = ffi.new("struct VkSparseImageFormatProperties [?]", count[0])
	CLIB.vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, count, array)

	local out = {}

	for i = 0, count[0] - 1 do
		out[i + 1] = array[i]
	end

	return out
end
function library.GetPhysicalDeviceSurfaceFormats(physicalDevice, surface)
	local count = ffi.new("uint32_t[1]")

	library.GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, count, nil)

	local array = ffi.new("struct VkSurfaceFormatKHR [?]", count[0])
	local status = library.GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end
	return nil, status
end
function library.GetImageSubresourceLayout(device, image, pSubresource)
	if type(pSubresource) == "table" then
		pSubresource = library.s.ImageSubresource(pSubresource, false)
	end
	local box = ffi.new("struct VkSubresourceLayout [1]")
	CLIB.vkGetImageSubresourceLayout(device, image, pSubresource, box)
	return box[0]
end
function library.GetFenceStatus(device)
	local box = ffi.new("struct VkFence_T [1]")
	local status = CLIB.vkGetFenceStatus(device, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetPhysicalDeviceSurfaceCapabilities(physicalDevice, surface)
	local box = ffi.new("struct VkSurfaceCapabilitiesKHR [1]")
	local status = library.GetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetPhysicalDeviceSurfaceSupport(physicalDevice, queueFamilyIndex, surface)
	local box = ffi.new("unsigned int [1]")
	local status = library.GetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetPhysicalDeviceFeatures(physicalDevice)
	local box = ffi.new("struct VkPhysicalDeviceFeatures [1]")
	CLIB.vkGetPhysicalDeviceFeatures(physicalDevice, box)
	return box[0]
end
function library.GetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags)
	if type(format) == "string" then
		format = library.e.format[format]
	end
	if type(type) == "string" then
		type = library.e.image_type[type]
	end
	if type(tiling) == "string" then
		tiling = library.e.image_tiling[tiling]
	end
	if type(usage) == "table" then
		usage = library.e.image_usage.make_enums(usage)
	elseif type(usage) == "string" then
		usage = library.e.image_usage[usage]
	end
	if type(flags) == "table" then
		flags = library.e.image_create.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.image_create[flags]
	end
	local box = ffi.new("struct VkImageFormatProperties [1]")
	local status = CLIB.vkGetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetDeviceMemoryCommitment(device, memory)
	local box = ffi.new("unsigned long [1]")
	CLIB.vkGetDeviceMemoryCommitment(device, memory, box)
	return box[0]
end
function library.GetDisplayPlaneCapabilities(physicalDevice, mode, planeIndex)
	local box = ffi.new("struct VkDisplayPlaneCapabilitiesKHR [1]")
	local status = library.GetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetImageSparseMemoryRequirements(device, image)
	local count = ffi.new("uint32_t[1]")

	CLIB.vkGetImageSparseMemoryRequirements(device, image, count, nil)

	local array = ffi.new("struct VkSparseImageMemoryRequirements [?]", count[0])
	CLIB.vkGetImageSparseMemoryRequirements(device, image, count, array)

	local out = {}

	for i = 0, count[0] - 1 do
		out[i + 1] = array[i]
	end

	return out
end
function library.GetPhysicalDeviceExternalImageFormatPropertie(physicalDevice, format, type, tiling, usage, flags, externalHandleType)
	if type(format) == "string" then
		format = library.e.format[format]
	end
	if type(type) == "string" then
		type = library.e.image_type[type]
	end
	if type(tiling) == "string" then
		tiling = library.e.image_tiling[tiling]
	end
	if type(usage) == "table" then
		usage = library.e.image_usage.make_enums(usage)
	elseif type(usage) == "string" then
		usage = library.e.image_usage[usage]
	end
	if type(flags) == "table" then
		flags = library.e.image_create.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.image_create[flags]
	end
	if type(externalHandleType) == "table" then
		externalHandleType = library.e.external_memory_handle_type_nv.make_enums(externalHandleType)
	elseif type(externalHandleType) == "string" then
		externalHandleType = library.e.external_memory_handle_type_nv[externalHandleType]
	end
	local box = ffi.new("struct VkExternalImageFormatPropertiesNV [1]")
	local status = library.GetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetImageMemoryRequirements(device, image)
	local box = ffi.new("struct VkMemoryRequirements [1]")
	CLIB.vkGetImageMemoryRequirements(device, image, box)
	return box[0]
end
function library.GetEventStatus(device)
	local box = ffi.new("struct VkEvent_T [1]")
	local status = CLIB.vkGetEventStatus(device, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetPhysicalDeviceDisplayPlaneProperties(physicalDevice)
	local count = ffi.new("uint32_t[1]")

	library.GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, count, nil)

	local array = ffi.new("struct VkDisplayPlanePropertiesKHR [?]", count[0])
	local status = library.GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end
	return nil, status
end
function library.GetDeviceQueue(device, queueFamilyIndex, queueIndex)
	local box = ffi.new("struct VkQueue_T * [1]")
	CLIB.vkGetDeviceQueue(device, queueFamilyIndex, queueIndex, box)
	return box[0]
end
function library.GetPhysicalDeviceDisplayProperties(physicalDevice)
	local count = ffi.new("uint32_t[1]")

	library.GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, count, nil)

	local array = ffi.new("struct VkDisplayPropertiesKHR [?]", count[0])
	local status = library.GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end
	return nil, status
end
function library.AcquireNextImage(device, swapchain, timeout, semaphore, fence)
	local box = ffi.new("unsigned int [1]")
	local status = library.AcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, box)

	if status == "VK_SUCCESS" then
		return box[0], status
	end

	return nil, status
end
function library.GetSwapchainImages(device, swapchain)
	local count = ffi.new("uint32_t[1]")

	library.GetSwapchainImagesKHR(device, swapchain, count, nil)

	local array = ffi.new("struct VkImage_T * [?]", count[0])
	local status = library.GetSwapchainImagesKHR(device, swapchain, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end
	return nil, status
end
function library.GetDisplayModeProperties(physicalDevice, display)
	local count = ffi.new("uint32_t[1]")

	library.GetDisplayModePropertiesKHR(physicalDevice, display, count, nil)

	local array = ffi.new("struct VkDisplayModePropertiesKHR [?]", count[0])
	local status = library.GetDisplayModePropertiesKHR(physicalDevice, display, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end
	return nil, status
end
function library.GetPhysicalDeviceSurfacePresentModes(physicalDevice, surface)
	local count = ffi.new("uint32_t[1]")

	library.GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, count, nil)

	local array = ffi.new("enum VkPresentModeKHR [?]", count[0])
	local status = library.GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, count, array)

	if status == "VK_SUCCESS" then
		local out = {}

		for i = 0, count[0] - 1 do
			out[i + 1] = array[i]
		end

		return out
	end
	return nil, status
end
function library.GetPhysicalDeviceProperties(physicalDevice)
	local box = ffi.new("struct VkPhysicalDeviceProperties [1]")
	CLIB.vkGetPhysicalDeviceProperties(physicalDevice, box)
	return box[0]
end
function library.GetPhysicalDeviceFormatProperties(physicalDevice, format)
	if type(format) == "string" then
		format = library.e.format[format]
	end
	local box = ffi.new("struct VkFormatProperties [1]")
	CLIB.vkGetPhysicalDeviceFormatProperties(physicalDevice, format, box)
	return box[0]
end
function library.GetPhysicalDeviceMemoryProperties(physicalDevice)
	local box = ffi.new("struct VkPhysicalDeviceMemoryProperties [1]")
	CLIB.vkGetPhysicalDeviceMemoryProperties(physicalDevice, box)
	return box[0]
end
function library.MapMemory(device, memory, a, b, c, type, func)
	local data = ffi.new("void *[1]")

	local status = CLIB.vkMapMemory(device, memory, a, b, c, data)

	if status == "VK_SUCCESS" then
		if func then
			local ptr = func(ffi.cast(type .. " *", data[0]))
			if ptr then
				data[0] = ptr
			end
			library.UnmapMemory(device, memory)
		end
		return data[0]
	end

	return nil, status
end
	library.s = {}
function library.s.ApplicationInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_APPLICATION_INFO"
	return table_only and tbl or ffi.new("struct VkApplicationInfo", tbl)
end
function library.s.InstanceCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"
	if type(tbl.pApplicationInfo) == "table" then
		tbl.pApplicationInfo = library.s.ApplicationInfo(tbl.pApplicationInfo, false)
	end
	if type(tbl.ppEnabledLayerNames) == "table" then
		tbl.enabledLayerCount = #tbl.ppEnabledLayerNames
		tbl.ppEnabledLayerNames = library.util.StringList(tbl.ppEnabledLayerNames)
	end
	if type(tbl.ppEnabledExtensionNames) == "table" then
		tbl.enabledExtensionCount = #tbl.ppEnabledExtensionNames
		tbl.ppEnabledExtensionNames = library.util.StringList(tbl.ppEnabledExtensionNames)
	end
	return table_only and tbl or ffi.new("struct VkInstanceCreateInfo", tbl)
end
function library.s.DeviceQueueCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"
	return table_only and tbl or ffi.new("struct VkDeviceQueueCreateInfo", tbl)
end
function library.s.DeviceCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"
	if type(tbl.pQueueCreateInfos) == "table" then
		if not tbl.queueCreateInfoCount then
			tbl.queueCreateInfoCount = #tbl.pQueueCreateInfos
		end
		tbl.pQueueCreateInfos = library.s.DeviceQueueCreateInfoArray(tbl.pQueueCreateInfos, false)
	end
	if type(tbl.ppEnabledLayerNames) == "table" then
		tbl.enabledLayerCount = #tbl.ppEnabledLayerNames
		tbl.ppEnabledLayerNames = library.util.StringList(tbl.ppEnabledLayerNames)
	end
	if type(tbl.ppEnabledExtensionNames) == "table" then
		tbl.enabledExtensionCount = #tbl.ppEnabledExtensionNames
		tbl.ppEnabledExtensionNames = library.util.StringList(tbl.ppEnabledExtensionNames)
	end
	if type(tbl.pEnabledFeatures) == "table" then
		tbl.pEnabledFeatures = library.s.PhysicalDeviceFeatures(tbl.pEnabledFeatures, false)
	end
	return table_only and tbl or ffi.new("struct VkDeviceCreateInfo", tbl)
end
function library.s.SubmitInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SUBMIT_INFO"
	if type(tbl.pWaitSemaphores) == "table" then
		if not tbl.waitSemaphoreCount then
			tbl.waitSemaphoreCount = #tbl.pWaitSemaphores
		end
		tbl.pWaitSemaphores = library.s.SemaphoreArray(tbl.pWaitSemaphores, false)
	end
	if type(tbl.pCommandBuffers) == "table" then
		if not tbl.commandBufferCount then
			tbl.commandBufferCount = #tbl.pCommandBuffers
		end
		tbl.pCommandBuffers = library.s.CommandBufferArray(tbl.pCommandBuffers, false)
	end
	if type(tbl.pSignalSemaphores) == "table" then
		if not tbl.signalSemaphoreCount then
			tbl.signalSemaphoreCount = #tbl.pSignalSemaphores
		end
		tbl.pSignalSemaphores = library.s.SemaphoreArray(tbl.pSignalSemaphores, false)
	end
	return table_only and tbl or ffi.new("struct VkSubmitInfo", tbl)
end
function library.s.MemoryAllocateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"
	return table_only and tbl or ffi.new("struct VkMemoryAllocateInfo", tbl)
end
function library.s.MappedMemoryRange(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"
	return table_only and tbl or ffi.new("struct VkMappedMemoryRange", tbl)
end
function library.s.BindSparseInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"
	if type(tbl.pWaitSemaphores) == "table" then
		if not tbl.waitSemaphoreCount then
			tbl.waitSemaphoreCount = #tbl.pWaitSemaphores
		end
		tbl.pWaitSemaphores = library.s.SemaphoreArray(tbl.pWaitSemaphores, false)
	end
	if type(tbl.pBufferBinds) == "table" then
		if not tbl.bufferBindCount then
			tbl.bufferBindCount = #tbl.pBufferBinds
		end
		tbl.pBufferBinds = library.s.SparseBufferMemoryBindInfoArray(tbl.pBufferBinds, false)
	end
	if type(tbl.pImageOpaqueBinds) == "table" then
		if not tbl.imageOpaqueBindCount then
			tbl.imageOpaqueBindCount = #tbl.pImageOpaqueBinds
		end
		tbl.pImageOpaqueBinds = library.s.SparseImageOpaqueMemoryBindInfoArray(tbl.pImageOpaqueBinds, false)
	end
	if type(tbl.pImageBinds) == "table" then
		if not tbl.imageBindCount then
			tbl.imageBindCount = #tbl.pImageBinds
		end
		tbl.pImageBinds = library.s.SparseImageMemoryBindInfoArray(tbl.pImageBinds, false)
	end
	if type(tbl.pSignalSemaphores) == "table" then
		if not tbl.signalSemaphoreCount then
			tbl.signalSemaphoreCount = #tbl.pSignalSemaphores
		end
		tbl.pSignalSemaphores = library.s.SemaphoreArray(tbl.pSignalSemaphores, false)
	end
	return table_only and tbl or ffi.new("struct VkBindSparseInfo", tbl)
end
function library.s.FenceCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.fence_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.fence_create[tbl.flags]
	end
	return table_only and tbl or ffi.new("struct VkFenceCreateInfo", tbl)
end
function library.s.SemaphoreCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"
	return table_only and tbl or ffi.new("struct VkSemaphoreCreateInfo", tbl)
end
function library.s.EventCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"
	return table_only and tbl or ffi.new("struct VkEventCreateInfo", tbl)
end
function library.s.QueryPoolCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"
	if type(tbl.queryType) == "string" then
		tbl.queryType = library.e.query_type[tbl.queryType]
	end
	if type(tbl.pipelineStatistics) == "table" then
		tbl.pipelineStatistics = library.e.query_pipeline_statistic.make_enums(tbl.pipelineStatistics)
	elseif type(tbl.pipelineStatistics) == "string" then
		tbl.pipelineStatistics = library.e.query_pipeline_statistic[tbl.pipelineStatistics]
	end
	return table_only and tbl or ffi.new("struct VkQueryPoolCreateInfo", tbl)
end
function library.s.BufferCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.buffer_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.buffer_create[tbl.flags]
	end
	if type(tbl.usage) == "table" then
		tbl.usage = library.e.buffer_usage.make_enums(tbl.usage)
	elseif type(tbl.usage) == "string" then
		tbl.usage = library.e.buffer_usage[tbl.usage]
	end
	if type(tbl.sharingMode) == "string" then
		tbl.sharingMode = library.e.sharing_mode[tbl.sharingMode]
	end
	return table_only and tbl or ffi.new("struct VkBufferCreateInfo", tbl)
end
function library.s.BufferViewCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"
	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end
	return table_only and tbl or ffi.new("struct VkBufferViewCreateInfo", tbl)
end
function library.s.ImageCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.image_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.image_create[tbl.flags]
	end
	if type(tbl.imageType) == "string" then
		tbl.imageType = library.e.image_type[tbl.imageType]
	end
	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end
	if type(tbl.extent) == "table" then
		tbl.extent = library.s.Extent3D(tbl.extent, true)
	end
	if type(tbl.samples) == "table" then
		tbl.samples = library.e.sample_count.make_enums(tbl.samples)
	elseif type(tbl.samples) == "string" then
		tbl.samples = library.e.sample_count[tbl.samples]
	end
	if type(tbl.tiling) == "string" then
		tbl.tiling = library.e.image_tiling[tbl.tiling]
	end
	if type(tbl.usage) == "table" then
		tbl.usage = library.e.image_usage.make_enums(tbl.usage)
	elseif type(tbl.usage) == "string" then
		tbl.usage = library.e.image_usage[tbl.usage]
	end
	if type(tbl.sharingMode) == "string" then
		tbl.sharingMode = library.e.sharing_mode[tbl.sharingMode]
	end
	if type(tbl.initialLayout) == "string" then
		tbl.initialLayout = library.e.image_layout[tbl.initialLayout]
	end
	return table_only and tbl or ffi.new("struct VkImageCreateInfo", tbl)
end
function library.s.ImageViewCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"
	if type(tbl.viewType) == "string" then
		tbl.viewType = library.e.image_view_type[tbl.viewType]
	end
	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end
	if type(tbl.components) == "table" then
		tbl.components = library.s.ComponentMapping(tbl.components, true)
	end
	if type(tbl.subresourceRange) == "table" then
		tbl.subresourceRange = library.s.ImageSubresourceRange(tbl.subresourceRange, true)
	end
	return table_only and tbl or ffi.new("struct VkImageViewCreateInfo", tbl)
end
function library.s.ShaderModuleCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"
	return table_only and tbl or ffi.new("struct VkShaderModuleCreateInfo", tbl)
end
function library.s.PipelineCacheCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"
	return table_only and tbl or ffi.new("struct VkPipelineCacheCreateInfo", tbl)
end
function library.s.PipelineShaderStageCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"
	if type(tbl.stage) == "table" then
		tbl.stage = library.e.shader_stage.make_enums(tbl.stage)
	elseif type(tbl.stage) == "string" then
		tbl.stage = library.e.shader_stage[tbl.stage]
	end
	if type(tbl.pSpecializationInfo) == "table" then
		tbl.pSpecializationInfo = library.s.SpecializationInfo(tbl.pSpecializationInfo, false)
	end
	return table_only and tbl or ffi.new("struct VkPipelineShaderStageCreateInfo", tbl)
end
function library.s.PipelineVertexInputStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"
	if type(tbl.pVertexBindingDescriptions) == "table" then
		if not tbl.vertexBindingDescriptionCount then
			tbl.vertexBindingDescriptionCount = #tbl.pVertexBindingDescriptions
		end
		tbl.pVertexBindingDescriptions = library.s.VertexInputBindingDescriptionArray(tbl.pVertexBindingDescriptions, false)
	end
	if type(tbl.pVertexAttributeDescriptions) == "table" then
		if not tbl.vertexAttributeDescriptionCount then
			tbl.vertexAttributeDescriptionCount = #tbl.pVertexAttributeDescriptions
		end
		tbl.pVertexAttributeDescriptions = library.s.VertexInputAttributeDescriptionArray(tbl.pVertexAttributeDescriptions, false)
	end
	return table_only and tbl or ffi.new("struct VkPipelineVertexInputStateCreateInfo", tbl)
end
function library.s.PipelineInputAssemblyStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"
	if type(tbl.topology) == "string" then
		tbl.topology = library.e.primitive_topology[tbl.topology]
	end
	tbl.primitiveRestartEnable = tbl.primitiveRestartEnable and 1 or 0
	return table_only and tbl or ffi.new("struct VkPipelineInputAssemblyStateCreateInfo", tbl)
end
function library.s.PipelineTessellationStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"
	return table_only and tbl or ffi.new("struct VkPipelineTessellationStateCreateInfo", tbl)
end
function library.s.PipelineViewportStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"
	if type(tbl.pViewports) == "table" then
		if not tbl.viewportCount then
			tbl.viewportCount = #tbl.pViewports
		end
		tbl.pViewports = library.s.ViewportArray(tbl.pViewports, false)
	end
	if type(tbl.pScissors) == "table" then
		if not tbl.scissorCount then
			tbl.scissorCount = #tbl.pScissors
		end
		tbl.pScissors = library.s.Rect2DArray(tbl.pScissors, false)
	end
	return table_only and tbl or ffi.new("struct VkPipelineViewportStateCreateInfo", tbl)
end
function library.s.PipelineRasterizationStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"
	tbl.depthClampEnable = tbl.depthClampEnable and 1 or 0
	tbl.rasterizerDiscardEnable = tbl.rasterizerDiscardEnable and 1 or 0
	if type(tbl.polygonMode) == "string" then
		tbl.polygonMode = library.e.polygon_mode[tbl.polygonMode]
	end
	if type(tbl.cullMode) == "table" then
		tbl.cullMode = library.e.cull_mode.make_enums(tbl.cullMode)
	elseif type(tbl.cullMode) == "string" then
		tbl.cullMode = library.e.cull_mode[tbl.cullMode]
	end
	if type(tbl.frontFace) == "string" then
		tbl.frontFace = library.e.front_face[tbl.frontFace]
	end
	tbl.depthBiasEnable = tbl.depthBiasEnable and 1 or 0
	return table_only and tbl or ffi.new("struct VkPipelineRasterizationStateCreateInfo", tbl)
end
function library.s.PipelineMultisampleStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"
	if type(tbl.rasterizationSamples) == "table" then
		tbl.rasterizationSamples = library.e.sample_count.make_enums(tbl.rasterizationSamples)
	elseif type(tbl.rasterizationSamples) == "string" then
		tbl.rasterizationSamples = library.e.sample_count[tbl.rasterizationSamples]
	end
	tbl.sampleShadingEnable = tbl.sampleShadingEnable and 1 or 0
	tbl.alphaToCoverageEnable = tbl.alphaToCoverageEnable and 1 or 0
	tbl.alphaToOneEnable = tbl.alphaToOneEnable and 1 or 0
	return table_only and tbl or ffi.new("struct VkPipelineMultisampleStateCreateInfo", tbl)
end
function library.s.PipelineDepthStencilStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"
	tbl.depthTestEnable = tbl.depthTestEnable and 1 or 0
	tbl.depthWriteEnable = tbl.depthWriteEnable and 1 or 0
	if type(tbl.depthCompareOp) == "string" then
		tbl.depthCompareOp = library.e.compare_op[tbl.depthCompareOp]
	end
	tbl.depthBoundsTestEnable = tbl.depthBoundsTestEnable and 1 or 0
	tbl.stencilTestEnable = tbl.stencilTestEnable and 1 or 0
	if type(tbl.front) == "table" then
		tbl.front = library.s.StencilOpState(tbl.front, true)
	end
	if type(tbl.back) == "table" then
		tbl.back = library.s.StencilOpState(tbl.back, true)
	end
	return table_only and tbl or ffi.new("struct VkPipelineDepthStencilStateCreateInfo", tbl)
end
function library.s.PipelineColorBlendStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"
	tbl.logicOpEnable = tbl.logicOpEnable and 1 or 0
	if type(tbl.logicOp) == "string" then
		tbl.logicOp = library.e.logic_op[tbl.logicOp]
	end
	if type(tbl.pAttachments) == "table" then
		if not tbl.attachmentCount then
			tbl.attachmentCount = #tbl.pAttachments
		end
		tbl.pAttachments = library.s.PipelineColorBlendAttachmentStateArray(tbl.pAttachments, false)
	end
	return table_only and tbl or ffi.new("struct VkPipelineColorBlendStateCreateInfo", tbl)
end
function library.s.PipelineDynamicStateCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"
	if type(tbl.pDynamicStates) == "string" then
		tbl.pDynamicStates = library.e.dynamic_state[tbl.pDynamicStates]
	end
	return table_only and tbl or ffi.new("struct VkPipelineDynamicStateCreateInfo", tbl)
end
function library.s.GraphicsPipelineCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.pipeline_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.pipeline_create[tbl.flags]
	end
	if type(tbl.pStages) == "table" then
		if not tbl.stageCount then
			tbl.stageCount = #tbl.pStages
		end
		tbl.pStages = library.s.PipelineShaderStageCreateInfoArray(tbl.pStages, false)
	end
	if type(tbl.pVertexInputState) == "table" then
		tbl.pVertexInputState = library.s.PipelineVertexInputStateCreateInfo(tbl.pVertexInputState, false)
	end
	if type(tbl.pInputAssemblyState) == "table" then
		tbl.pInputAssemblyState = library.s.PipelineInputAssemblyStateCreateInfo(tbl.pInputAssemblyState, false)
	end
	if type(tbl.pTessellationState) == "table" then
		tbl.pTessellationState = library.s.PipelineTessellationStateCreateInfo(tbl.pTessellationState, false)
	end
	if type(tbl.pViewportState) == "table" then
		tbl.pViewportState = library.s.PipelineViewportStateCreateInfo(tbl.pViewportState, false)
	end
	if type(tbl.pRasterizationState) == "table" then
		tbl.pRasterizationState = library.s.PipelineRasterizationStateCreateInfo(tbl.pRasterizationState, false)
	end
	if type(tbl.pMultisampleState) == "table" then
		tbl.pMultisampleState = library.s.PipelineMultisampleStateCreateInfo(tbl.pMultisampleState, false)
	end
	if type(tbl.pDepthStencilState) == "table" then
		tbl.pDepthStencilState = library.s.PipelineDepthStencilStateCreateInfo(tbl.pDepthStencilState, false)
	end
	if type(tbl.pColorBlendState) == "table" then
		tbl.pColorBlendState = library.s.PipelineColorBlendStateCreateInfo(tbl.pColorBlendState, false)
	end
	if type(tbl.pDynamicState) == "table" then
		tbl.pDynamicState = library.s.PipelineDynamicStateCreateInfo(tbl.pDynamicState, false)
	end
	return table_only and tbl or ffi.new("struct VkGraphicsPipelineCreateInfo", tbl)
end
function library.s.ComputePipelineCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.pipeline_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.pipeline_create[tbl.flags]
	end
	if type(tbl.stage) == "table" then
		tbl.stage = library.s.PipelineShaderStageCreateInfo(tbl.stage, true)
	end
	return table_only and tbl or ffi.new("struct VkComputePipelineCreateInfo", tbl)
end
function library.s.PipelineLayoutCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"
	if type(tbl.pSetLayouts) == "table" then
		if not tbl.setLayoutCount then
			tbl.setLayoutCount = #tbl.pSetLayouts
		end
		tbl.pSetLayouts = library.s.DescriptorSetLayoutArray(tbl.pSetLayouts, false)
	end
	if type(tbl.pPushConstantRanges) == "table" then
		if not tbl.pushConstantRangeCount then
			tbl.pushConstantRangeCount = #tbl.pPushConstantRanges
		end
		tbl.pPushConstantRanges = library.s.PushConstantRangeArray(tbl.pPushConstantRanges, false)
	end
	return table_only and tbl or ffi.new("struct VkPipelineLayoutCreateInfo", tbl)
end
function library.s.SamplerCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"
	if type(tbl.magFilter) == "string" then
		tbl.magFilter = library.e.filter[tbl.magFilter]
	end
	if type(tbl.minFilter) == "string" then
		tbl.minFilter = library.e.filter[tbl.minFilter]
	end
	if type(tbl.mipmapMode) == "string" then
		tbl.mipmapMode = library.e.sampler_mipmap_mode[tbl.mipmapMode]
	end
	if type(tbl.addressModeU) == "string" then
		tbl.addressModeU = library.e.sampler_address_mode[tbl.addressModeU]
	end
	if type(tbl.addressModeV) == "string" then
		tbl.addressModeV = library.e.sampler_address_mode[tbl.addressModeV]
	end
	if type(tbl.addressModeW) == "string" then
		tbl.addressModeW = library.e.sampler_address_mode[tbl.addressModeW]
	end
	tbl.anisotropyEnable = tbl.anisotropyEnable and 1 or 0
	tbl.compareEnable = tbl.compareEnable and 1 or 0
	if type(tbl.compareOp) == "string" then
		tbl.compareOp = library.e.compare_op[tbl.compareOp]
	end
	if type(tbl.borderColor) == "string" then
		tbl.borderColor = library.e.border_color[tbl.borderColor]
	end
	return table_only and tbl or ffi.new("struct VkSamplerCreateInfo", tbl)
end
function library.s.DescriptorSetLayoutCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"
	if type(tbl.pBindings) == "table" then
		if not tbl.bindingCount then
			tbl.bindingCount = #tbl.pBindings
		end
		tbl.pBindings = library.s.DescriptorSetLayoutBindingArray(tbl.pBindings, false)
	end
	return table_only and tbl or ffi.new("struct VkDescriptorSetLayoutCreateInfo", tbl)
end
function library.s.DescriptorPoolCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.descriptor_pool_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.descriptor_pool_create[tbl.flags]
	end
	if type(tbl.pPoolSizes) == "table" then
		if not tbl.poolSizeCount then
			tbl.poolSizeCount = #tbl.pPoolSizes
		end
		tbl.pPoolSizes = library.s.DescriptorPoolSizeArray(tbl.pPoolSizes, false)
	end
	return table_only and tbl or ffi.new("struct VkDescriptorPoolCreateInfo", tbl)
end
function library.s.DescriptorSetAllocateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"
	if type(tbl.pSetLayouts) == "table" then
		if not tbl.descriptorSetCount then
			tbl.descriptorSetCount = #tbl.pSetLayouts
		end
		tbl.pSetLayouts = library.s.DescriptorSetLayoutArray(tbl.pSetLayouts, false)
	end
	return table_only and tbl or ffi.new("struct VkDescriptorSetAllocateInfo", tbl)
end
function library.s.WriteDescriptorSet(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"
	if type(tbl.descriptorType) == "string" then
		tbl.descriptorType = library.e.descriptor_type[tbl.descriptorType]
	end
	if type(tbl.pImageInfo) == "table" then
		if not tbl.descriptorCount then
			tbl.descriptorCount = #tbl.pImageInfo
		end
		tbl.pImageInfo = library.s.DescriptorImageInfoArray(tbl.pImageInfo)
	end
	if type(tbl.pBufferInfo) == "table" then
		if not tbl.descriptorCount then
			tbl.descriptorCount = #tbl.pBufferInfo
		end
		tbl.pBufferInfo = library.s.DescriptorBufferInfoArray(tbl.pBufferInfo)
	end
	if type(tbl.pTexelBufferView) == "table" then
		if not tbl.descriptorCount then
			tbl.descriptorCount = #tbl.pTexelBufferView
		end
		tbl.pTexelBufferView = library.s.BufferViewArray(tbl.pTexelBufferView)
	end
	return table_only and tbl or ffi.new("struct VkWriteDescriptorSet", tbl)
end
function library.s.CopyDescriptorSet(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"
	return table_only and tbl or ffi.new("struct VkCopyDescriptorSet", tbl)
end
function library.s.FramebufferCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"
	if type(tbl.pAttachments) == "table" then
		if not tbl.attachmentCount then
			tbl.attachmentCount = #tbl.pAttachments
		end
		tbl.pAttachments = library.s.ImageViewArray(tbl.pAttachments, false)
	end
	return table_only and tbl or ffi.new("struct VkFramebufferCreateInfo", tbl)
end
function library.s.RenderPassCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"
	if type(tbl.pAttachments) == "table" then
		if not tbl.attachmentCount then
			tbl.attachmentCount = #tbl.pAttachments
		end
		tbl.pAttachments = library.s.AttachmentDescriptionArray(tbl.pAttachments, false)
	end
	if type(tbl.pSubpasses) == "table" then
		if not tbl.subpassCount then
			tbl.subpassCount = #tbl.pSubpasses
		end
		tbl.pSubpasses = library.s.SubpassDescriptionArray(tbl.pSubpasses, false)
	end
	if type(tbl.pDependencies) == "table" then
		if not tbl.dependencyCount then
			tbl.dependencyCount = #tbl.pDependencies
		end
		tbl.pDependencies = library.s.SubpassDependencyArray(tbl.pDependencies, false)
	end
	return table_only and tbl or ffi.new("struct VkRenderPassCreateInfo", tbl)
end
function library.s.CommandPoolCreateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.command_pool_create.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.command_pool_create[tbl.flags]
	end
	return table_only and tbl or ffi.new("struct VkCommandPoolCreateInfo", tbl)
end
function library.s.CommandBufferAllocateInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"
	if type(tbl.level) == "string" then
		tbl.level = library.e.command_buffer_level[tbl.level]
	end
	return table_only and tbl or ffi.new("struct VkCommandBufferAllocateInfo", tbl)
end
function library.s.CommandBufferInheritanceInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"
	tbl.occlusionQueryEnable = tbl.occlusionQueryEnable and 1 or 0
	if type(tbl.queryFlags) == "table" then
		tbl.queryFlags = library.e.query_control.make_enums(tbl.queryFlags)
	elseif type(tbl.queryFlags) == "string" then
		tbl.queryFlags = library.e.query_control[tbl.queryFlags]
	end
	if type(tbl.pipelineStatistics) == "table" then
		tbl.pipelineStatistics = library.e.query_pipeline_statistic.make_enums(tbl.pipelineStatistics)
	elseif type(tbl.pipelineStatistics) == "string" then
		tbl.pipelineStatistics = library.e.query_pipeline_statistic[tbl.pipelineStatistics]
	end
	return table_only and tbl or ffi.new("struct VkCommandBufferInheritanceInfo", tbl)
end
function library.s.CommandBufferBeginInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.command_buffer_usage.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.command_buffer_usage[tbl.flags]
	end
	if type(tbl.pInheritanceInfo) == "table" then
		tbl.pInheritanceInfo = library.s.CommandBufferInheritanceInfo(tbl.pInheritanceInfo, false)
	end
	return table_only and tbl or ffi.new("struct VkCommandBufferBeginInfo", tbl)
end
function library.s.RenderPassBeginInfo(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"
	if type(tbl.renderArea) == "table" then
		tbl.renderArea = library.s.Rect2D(tbl.renderArea, true)
	end
	if type(tbl.pClearValues) == "table" then
		if not tbl.clearValueCount then
			tbl.clearValueCount = #tbl.pClearValues
		end
		tbl.pClearValues = library.s.ClearValueArray(tbl.pClearValues, false)
	end
	return table_only and tbl or ffi.new("struct VkRenderPassBeginInfo", tbl)
end
function library.s.BufferMemoryBarrier(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"
	if type(tbl.srcAccessMask) == "table" then
		tbl.srcAccessMask = library.e.access.make_enums(tbl.srcAccessMask)
	elseif type(tbl.srcAccessMask) == "string" then
		tbl.srcAccessMask = library.e.access[tbl.srcAccessMask]
	end
	if type(tbl.dstAccessMask) == "table" then
		tbl.dstAccessMask = library.e.access.make_enums(tbl.dstAccessMask)
	elseif type(tbl.dstAccessMask) == "string" then
		tbl.dstAccessMask = library.e.access[tbl.dstAccessMask]
	end
	return table_only and tbl or ffi.new("struct VkBufferMemoryBarrier", tbl)
end
function library.s.ImageMemoryBarrier(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"
	if type(tbl.srcAccessMask) == "table" then
		tbl.srcAccessMask = library.e.access.make_enums(tbl.srcAccessMask)
	elseif type(tbl.srcAccessMask) == "string" then
		tbl.srcAccessMask = library.e.access[tbl.srcAccessMask]
	end
	if type(tbl.dstAccessMask) == "table" then
		tbl.dstAccessMask = library.e.access.make_enums(tbl.dstAccessMask)
	elseif type(tbl.dstAccessMask) == "string" then
		tbl.dstAccessMask = library.e.access[tbl.dstAccessMask]
	end
	if type(tbl.oldLayout) == "string" then
		tbl.oldLayout = library.e.image_layout[tbl.oldLayout]
	end
	if type(tbl.newLayout) == "string" then
		tbl.newLayout = library.e.image_layout[tbl.newLayout]
	end
	if type(tbl.subresourceRange) == "table" then
		tbl.subresourceRange = library.s.ImageSubresourceRange(tbl.subresourceRange, true)
	end
	return table_only and tbl or ffi.new("struct VkImageMemoryBarrier", tbl)
end
function library.s.MemoryBarrier(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_MEMORY_BARRIER"
	if type(tbl.srcAccessMask) == "table" then
		tbl.srcAccessMask = library.e.access.make_enums(tbl.srcAccessMask)
	elseif type(tbl.srcAccessMask) == "string" then
		tbl.srcAccessMask = library.e.access[tbl.srcAccessMask]
	end
	if type(tbl.dstAccessMask) == "table" then
		tbl.dstAccessMask = library.e.access.make_enums(tbl.dstAccessMask)
	elseif type(tbl.dstAccessMask) == "string" then
		tbl.dstAccessMask = library.e.access[tbl.dstAccessMask]
	end
	return table_only and tbl or ffi.new("struct VkMemoryBarrier", tbl)
end
function library.s.SwapchainCreateInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"
	if type(tbl.imageFormat) == "string" then
		tbl.imageFormat = library.e.format[tbl.imageFormat]
	end
	if type(tbl.imageColorSpace) == "string" then
		tbl.imageColorSpace = library.e.colorspace[tbl.imageColorSpace]
	end
	if type(tbl.imageExtent) == "table" then
		tbl.imageExtent = library.s.Extent2D(tbl.imageExtent, true)
	end
	if type(tbl.imageUsage) == "table" then
		tbl.imageUsage = library.e.image_usage.make_enums(tbl.imageUsage)
	elseif type(tbl.imageUsage) == "string" then
		tbl.imageUsage = library.e.image_usage[tbl.imageUsage]
	end
	if type(tbl.imageSharingMode) == "string" then
		tbl.imageSharingMode = library.e.sharing_mode[tbl.imageSharingMode]
	end
	if type(tbl.preTransform) == "table" then
		tbl.preTransform = library.e.surface_transform.make_enums(tbl.preTransform)
	elseif type(tbl.preTransform) == "string" then
		tbl.preTransform = library.e.surface_transform[tbl.preTransform]
	end
	if type(tbl.compositeAlpha) == "table" then
		tbl.compositeAlpha = library.e.composite_alpha.make_enums(tbl.compositeAlpha)
	elseif type(tbl.compositeAlpha) == "string" then
		tbl.compositeAlpha = library.e.composite_alpha[tbl.compositeAlpha]
	end
	if type(tbl.presentMode) == "string" then
		tbl.presentMode = library.e.present_mode[tbl.presentMode]
	end
	return table_only and tbl or ffi.new("struct VkSwapchainCreateInfoKHR", tbl)
end
function library.s.PresentInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"
	if type(tbl.pWaitSemaphores) == "table" then
		if not tbl.waitSemaphoreCount then
			tbl.waitSemaphoreCount = #tbl.pWaitSemaphores
		end
		tbl.pWaitSemaphores = library.s.SemaphoreArray(tbl.pWaitSemaphores, false)
	end
	if type(tbl.pSwapchains) == "table" then
		if not tbl.swapchainCount then
			tbl.swapchainCount = #tbl.pSwapchains
		end
		tbl.pSwapchains = library.s.SwapchainKHRArray(tbl.pSwapchains, false)
	end
	if type(tbl.pResults) == "string" then
		tbl.pResults = library.e.result[tbl.pResults]
	end
	return table_only and tbl or ffi.new("struct VkPresentInfoKHR", tbl)
end
function library.s.DisplayModeCreateInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"
	if type(tbl.parameters) == "table" then
		tbl.parameters = library.s.DisplayModeParametersKHR(tbl.parameters, true)
	end
	return table_only and tbl or ffi.new("struct VkDisplayModeCreateInfoKHR", tbl)
end
function library.s.DisplaySurfaceCreateInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"
	if type(tbl.transform) == "table" then
		tbl.transform = library.e.surface_transform.make_enums(tbl.transform)
	elseif type(tbl.transform) == "string" then
		tbl.transform = library.e.surface_transform[tbl.transform]
	end
	if type(tbl.alphaMode) == "table" then
		tbl.alphaMode = library.e.display_plane_alpha.make_enums(tbl.alphaMode)
	elseif type(tbl.alphaMode) == "string" then
		tbl.alphaMode = library.e.display_plane_alpha[tbl.alphaMode]
	end
	if type(tbl.imageExtent) == "table" then
		tbl.imageExtent = library.s.Extent2D(tbl.imageExtent, true)
	end
	return table_only and tbl or ffi.new("struct VkDisplaySurfaceCreateInfoKHR", tbl)
end
function library.s.DisplayPresentInfoKHR(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"
	if type(tbl.srcRect) == "table" then
		tbl.srcRect = library.s.Rect2D(tbl.srcRect, true)
	end
	if type(tbl.dstRect) == "table" then
		tbl.dstRect = library.s.Rect2D(tbl.dstRect, true)
	end
	return table_only and tbl or ffi.new("struct VkDisplayPresentInfoKHR", tbl)
end
function library.s.DebugReportCallbackCreateInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.debug_report.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.debug_report[tbl.flags]
	end
	return table_only and tbl or ffi.new("struct VkDebugReportCallbackCreateInfoEXT", tbl)
end
function library.s.PipelineRasterizationStateRasterizationOrderAMD(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"
	if type(tbl.rasterizationOrder) == "string" then
		tbl.rasterizationOrder = library.e.rasterization_order_amd[tbl.rasterizationOrder]
	end
	return table_only and tbl or ffi.new("struct VkPipelineRasterizationStateRasterizationOrderAMD", tbl)
end
function library.s.DebugMarkerObjectNameInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"
	if type(tbl.objectType) == "string" then
		tbl.objectType = library.e.debug_report_object_type[tbl.objectType]
	end
	return table_only and tbl or ffi.new("struct VkDebugMarkerObjectNameInfoEXT", tbl)
end
function library.s.DebugMarkerObjectTagInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"
	if type(tbl.objectType) == "string" then
		tbl.objectType = library.e.debug_report_object_type[tbl.objectType]
	end
	return table_only and tbl or ffi.new("struct VkDebugMarkerObjectTagInfoEXT", tbl)
end
function library.s.DebugMarkerMarkerInfoEXT(tbl, table_only)
	tbl.sType = "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"
	return table_only and tbl or ffi.new("struct VkDebugMarkerMarkerInfoEXT", tbl)
end
function library.s.ExportMemoryAllocateInfoNV(tbl, table_only)
	if type(tbl.handleTypes) == "table" then
		tbl.handleTypes = library.e.external_memory_handle_type_nv.make_enums(tbl.handleTypes)
	elseif type(tbl.handleTypes) == "string" then
		tbl.handleTypes = library.e.external_memory_handle_type_nv[tbl.handleTypes]
	end
	return table_only and tbl or ffi.new("struct VkExportMemoryAllocateInfoNV", tbl)
end
function library.s.ExportMemoryAllocateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExportMemoryAllocateInfoNV(v)
	end
	return ffi.new("struct VkExportMemoryAllocateInfoNV[?]", #tbl, tbl)
end
function library.s.ExternalMemoryImageCreateInfoNV(tbl, table_only)
	if type(tbl.handleTypes) == "table" then
		tbl.handleTypes = library.e.external_memory_handle_type_nv.make_enums(tbl.handleTypes)
	elseif type(tbl.handleTypes) == "string" then
		tbl.handleTypes = library.e.external_memory_handle_type_nv[tbl.handleTypes]
	end
	return table_only and tbl or ffi.new("struct VkExternalMemoryImageCreateInfoNV", tbl)
end
function library.s.ExternalMemoryImageCreateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalMemoryImageCreateInfoNV(v)
	end
	return ffi.new("struct VkExternalMemoryImageCreateInfoNV[?]", #tbl, tbl)
end
function library.s.DedicatedAllocationMemoryAllocateInfoNV(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkDedicatedAllocationMemoryAllocateInfoNV", tbl)
end
function library.s.DedicatedAllocationMemoryAllocateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DedicatedAllocationMemoryAllocateInfoNV(v)
	end
	return ffi.new("struct VkDedicatedAllocationMemoryAllocateInfoNV[?]", #tbl, tbl)
end
function library.s.DescriptorPoolArray(tbl) return ffi.new("struct VkDescriptorPool_T *[?]", #tbl, tbl) end
function library.s.PipelineTessellationStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineTessellationStateCreateInfo(v)
	end
	return ffi.new("struct VkPipelineTessellationStateCreateInfo[?]", #tbl, tbl)
end
function library.s.SemaphoreArray(tbl) return ffi.new("struct VkSemaphore_T *[?]", #tbl, tbl) end
function library.s.ClearDepthStencilValue(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkClearDepthStencilValue", tbl)
end
function library.s.ClearDepthStencilValueArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ClearDepthStencilValue(v)
	end
	return ffi.new("struct VkClearDepthStencilValue[?]", #tbl, tbl)
end
function library.s.ImageSubresourceRange(tbl, table_only)
	if type(tbl.aspectMask) == "table" then
		tbl.aspectMask = library.e.image_aspect.make_enums(tbl.aspectMask)
	elseif type(tbl.aspectMask) == "string" then
		tbl.aspectMask = library.e.image_aspect[tbl.aspectMask]
	end
	return table_only and tbl or ffi.new("struct VkImageSubresourceRange", tbl)
end
function library.s.ImageSubresourceRangeArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageSubresourceRange(v)
	end
	return ffi.new("struct VkImageSubresourceRange[?]", #tbl, tbl)
end
function library.s.SparseBufferMemoryBindInfo(tbl, table_only)
	if type(tbl.pBinds) == "table" then
		if not tbl.bindCount then
			tbl.bindCount = #tbl.pBinds
		end
		tbl.pBinds = library.s.SparseMemoryBindArray(tbl.pBinds, false)
	end
	return table_only and tbl or ffi.new("struct VkSparseBufferMemoryBindInfo", tbl)
end
function library.s.SparseBufferMemoryBindInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseBufferMemoryBindInfo(v)
	end
	return ffi.new("struct VkSparseBufferMemoryBindInfo[?]", #tbl, tbl)
end
function library.s.InstanceArray(tbl) return ffi.new("struct VkInstance_T *[?]", #tbl, tbl) end
function library.s.ImageViewArray(tbl) return ffi.new("struct VkImageView_T *[?]", #tbl, tbl) end
function library.s.DedicatedAllocationBufferCreateInfoNV(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkDedicatedAllocationBufferCreateInfoNV", tbl)
end
function library.s.DedicatedAllocationBufferCreateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DedicatedAllocationBufferCreateInfoNV(v)
	end
	return ffi.new("struct VkDedicatedAllocationBufferCreateInfoNV[?]", #tbl, tbl)
end
function library.s.DescriptorSetArray(tbl) return ffi.new("struct VkDescriptorSet_T *[?]", #tbl, tbl) end
function library.s.PipelineRasterizationStateRasterizationOrderAMDArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineRasterizationStateRasterizationOrderAMD(v)
	end
	return ffi.new("struct VkPipelineRasterizationStateRasterizationOrderAMD[?]", #tbl, tbl)
end
function library.s.ComponentMapping(tbl, table_only)
	if type(tbl.r) == "string" then
		tbl.r = library.e.component_swizzle[tbl.r]
	end
	if type(tbl.g) == "string" then
		tbl.g = library.e.component_swizzle[tbl.g]
	end
	if type(tbl.b) == "string" then
		tbl.b = library.e.component_swizzle[tbl.b]
	end
	if type(tbl.a) == "string" then
		tbl.a = library.e.component_swizzle[tbl.a]
	end
	return table_only and tbl or ffi.new("struct VkComponentMapping", tbl)
end
function library.s.ComponentMappingArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ComponentMapping(v)
	end
	return ffi.new("struct VkComponentMapping[?]", #tbl, tbl)
end
function library.s.PipelineMultisampleStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineMultisampleStateCreateInfo(v)
	end
	return ffi.new("struct VkPipelineMultisampleStateCreateInfo[?]", #tbl, tbl)
end
function library.s.DebugReportCallbackCreateInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DebugReportCallbackCreateInfoEXT(v)
	end
	return ffi.new("struct VkDebugReportCallbackCreateInfoEXT[?]", #tbl, tbl)
end
function library.s.DebugMarkerObjectNameInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DebugMarkerObjectNameInfoEXT(v)
	end
	return ffi.new("struct VkDebugMarkerObjectNameInfoEXT[?]", #tbl, tbl)
end
function library.s.DispatchIndirectCommand(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkDispatchIndirectCommand", tbl)
end
function library.s.DispatchIndirectCommandArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DispatchIndirectCommand(v)
	end
	return ffi.new("struct VkDispatchIndirectCommand[?]", #tbl, tbl)
end
function library.s.DisplayPresentInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayPresentInfoKHR(v)
	end
	return ffi.new("struct VkDisplayPresentInfoKHR[?]", #tbl, tbl)
end
function library.s.DescriptorSetAllocateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorSetAllocateInfo(v)
	end
	return ffi.new("struct VkDescriptorSetAllocateInfo[?]", #tbl, tbl)
end
function library.s.WriteDescriptorSetArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.WriteDescriptorSet(v)
	end
	return ffi.new("struct VkWriteDescriptorSet[?]", #tbl, tbl)
end
function library.s.DebugMarkerObjectTagInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DebugMarkerObjectTagInfoEXT(v)
	end
	return ffi.new("struct VkDebugMarkerObjectTagInfoEXT[?]", #tbl, tbl)
end
function library.s.PipelineColorBlendStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineColorBlendStateCreateInfo(v)
	end
	return ffi.new("struct VkPipelineColorBlendStateCreateInfo[?]", #tbl, tbl)
end
function library.s.SurfaceKHRArray(tbl) return ffi.new("struct VkSurfaceKHR_T *[?]", #tbl, tbl) end
function library.s.BufferArray(tbl) return ffi.new("struct VkBuffer_T *[?]", #tbl, tbl) end
function library.s.PipelineCacheArray(tbl) return ffi.new("struct VkPipelineCache_T *[?]", #tbl, tbl) end
function library.s.DebugReportCallbackEXTArray(tbl) return ffi.new("struct VkDebugReportCallbackEXT_T *[?]", #tbl, tbl) end
function library.s.ImageArray(tbl) return ffi.new("struct VkImage_T *[?]", #tbl, tbl) end
function library.s.QueryPoolCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.QueryPoolCreateInfo(v)
	end
	return ffi.new("struct VkQueryPoolCreateInfo[?]", #tbl, tbl)
end
function library.s.PipelineShaderStageCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineShaderStageCreateInfo(v)
	end
	return ffi.new("struct VkPipelineShaderStageCreateInfo[?]", #tbl, tbl)
end
function library.s.PipelineVertexInputStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineVertexInputStateCreateInfo(v)
	end
	return ffi.new("struct VkPipelineVertexInputStateCreateInfo[?]", #tbl, tbl)
end
function library.s.Rect2D(tbl, table_only)
	if type(tbl.offset) == "table" then
		tbl.offset = library.s.Offset2D(tbl.offset, true)
	end
	if type(tbl.extent) == "table" then
		tbl.extent = library.s.Extent2D(tbl.extent, true)
	end
	return table_only and tbl or ffi.new("struct VkRect2D", tbl)
end
function library.s.Rect2DArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.Rect2D(v)
	end
	return ffi.new("struct VkRect2D[?]", #tbl, tbl)
end
function library.s.SparseImageOpaqueMemoryBindInfo(tbl, table_only)
	if type(tbl.pBinds) == "table" then
		if not tbl.bindCount then
			tbl.bindCount = #tbl.pBinds
		end
		tbl.pBinds = library.s.SparseMemoryBindArray(tbl.pBinds, false)
	end
	return table_only and tbl or ffi.new("struct VkSparseImageOpaqueMemoryBindInfo", tbl)
end
function library.s.SparseImageOpaqueMemoryBindInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseImageOpaqueMemoryBindInfo(v)
	end
	return ffi.new("struct VkSparseImageOpaqueMemoryBindInfo[?]", #tbl, tbl)
end
function library.s.BufferMemoryBarrierArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BufferMemoryBarrier(v)
	end
	return ffi.new("struct VkBufferMemoryBarrier[?]", #tbl, tbl)
end
function library.s.DisplaySurfaceCreateInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplaySurfaceCreateInfoKHR(v)
	end
	return ffi.new("struct VkDisplaySurfaceCreateInfoKHR[?]", #tbl, tbl)
end
function library.s.DisplayPlanePropertiesKHR(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkDisplayPlanePropertiesKHR", tbl)
end
function library.s.DisplayPlanePropertiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayPlanePropertiesKHR(v)
	end
	return ffi.new("struct VkDisplayPlanePropertiesKHR[?]", #tbl, tbl)
end
function library.s.RenderPassBeginInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.RenderPassBeginInfo(v)
	end
	return ffi.new("struct VkRenderPassBeginInfo[?]", #tbl, tbl)
end
function library.s.DisplayPlaneCapabilitiesKHR(tbl, table_only)
	if type(tbl.supportedAlpha) == "table" then
		tbl.supportedAlpha = library.e.display_plane_alpha.make_enums(tbl.supportedAlpha)
	elseif type(tbl.supportedAlpha) == "string" then
		tbl.supportedAlpha = library.e.display_plane_alpha[tbl.supportedAlpha]
	end
	if type(tbl.minSrcPosition) == "table" then
		tbl.minSrcPosition = library.s.Offset2D(tbl.minSrcPosition, true)
	end
	if type(tbl.maxSrcPosition) == "table" then
		tbl.maxSrcPosition = library.s.Offset2D(tbl.maxSrcPosition, true)
	end
	if type(tbl.minSrcExtent) == "table" then
		tbl.minSrcExtent = library.s.Extent2D(tbl.minSrcExtent, true)
	end
	if type(tbl.maxSrcExtent) == "table" then
		tbl.maxSrcExtent = library.s.Extent2D(tbl.maxSrcExtent, true)
	end
	if type(tbl.minDstPosition) == "table" then
		tbl.minDstPosition = library.s.Offset2D(tbl.minDstPosition, true)
	end
	if type(tbl.maxDstPosition) == "table" then
		tbl.maxDstPosition = library.s.Offset2D(tbl.maxDstPosition, true)
	end
	if type(tbl.minDstExtent) == "table" then
		tbl.minDstExtent = library.s.Extent2D(tbl.minDstExtent, true)
	end
	if type(tbl.maxDstExtent) == "table" then
		tbl.maxDstExtent = library.s.Extent2D(tbl.maxDstExtent, true)
	end
	return table_only and tbl or ffi.new("struct VkDisplayPlaneCapabilitiesKHR", tbl)
end
function library.s.DisplayPlaneCapabilitiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayPlaneCapabilitiesKHR(v)
	end
	return ffi.new("struct VkDisplayPlaneCapabilitiesKHR[?]", #tbl, tbl)
end
function library.s.DisplayPropertiesKHR(tbl, table_only)
	if type(tbl.physicalDimensions) == "table" then
		tbl.physicalDimensions = library.s.Extent2D(tbl.physicalDimensions, true)
	end
	if type(tbl.physicalResolution) == "table" then
		tbl.physicalResolution = library.s.Extent2D(tbl.physicalResolution, true)
	end
	if type(tbl.supportedTransforms) == "table" then
		tbl.supportedTransforms = library.e.surface_transform.make_enums(tbl.supportedTransforms)
	elseif type(tbl.supportedTransforms) == "string" then
		tbl.supportedTransforms = library.e.surface_transform[tbl.supportedTransforms]
	end
	return table_only and tbl or ffi.new("struct VkDisplayPropertiesKHR", tbl)
end
function library.s.DisplayPropertiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayPropertiesKHR(v)
	end
	return ffi.new("struct VkDisplayPropertiesKHR[?]", #tbl, tbl)
end
function library.s.PipelineLayoutArray(tbl) return ffi.new("struct VkPipelineLayout_T *[?]", #tbl, tbl) end
function library.s.DisplayModeKHRArray(tbl) return ffi.new("struct VkDisplayModeKHR_T *[?]", #tbl, tbl) end
function library.s.ImageCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageCreateInfo(v)
	end
	return ffi.new("struct VkImageCreateInfo[?]", #tbl, tbl)
end
function library.s.ComputePipelineCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ComputePipelineCreateInfo(v)
	end
	return ffi.new("struct VkComputePipelineCreateInfo[?]", #tbl, tbl)
end
function library.s.SparseMemoryBind(tbl, table_only)
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.sparse_memory_bind.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.sparse_memory_bind[tbl.flags]
	end
	return table_only and tbl or ffi.new("struct VkSparseMemoryBind", tbl)
end
function library.s.SparseMemoryBindArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseMemoryBind(v)
	end
	return ffi.new("struct VkSparseMemoryBind[?]", #tbl, tbl)
end
function library.s.StencilOpState(tbl, table_only)
	if type(tbl.failOp) == "string" then
		tbl.failOp = library.e.stencil_op[tbl.failOp]
	end
	if type(tbl.passOp) == "string" then
		tbl.passOp = library.e.stencil_op[tbl.passOp]
	end
	if type(tbl.depthFailOp) == "string" then
		tbl.depthFailOp = library.e.stencil_op[tbl.depthFailOp]
	end
	if type(tbl.compareOp) == "string" then
		tbl.compareOp = library.e.compare_op[tbl.compareOp]
	end
	return table_only and tbl or ffi.new("struct VkStencilOpState", tbl)
end
function library.s.StencilOpStateArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.StencilOpState(v)
	end
	return ffi.new("struct VkStencilOpState[?]", #tbl, tbl)
end
function library.s.DescriptorSetLayoutCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorSetLayoutCreateInfo(v)
	end
	return ffi.new("struct VkDescriptorSetLayoutCreateInfo[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceArray(tbl) return ffi.new("struct VkPhysicalDevice_T *[?]", #tbl, tbl) end
function library.s.PhysicalDeviceSparseProperties(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceSparseProperties", tbl)
end
function library.s.PhysicalDeviceSparsePropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceSparseProperties(v)
	end
	return ffi.new("struct VkPhysicalDeviceSparseProperties[?]", #tbl, tbl)
end
function library.s.ShaderModuleArray(tbl) return ffi.new("struct VkShaderModule_T *[?]", #tbl, tbl) end
function library.s.PipelineColorBlendAttachmentState(tbl, table_only)
	tbl.blendEnable = tbl.blendEnable and 1 or 0
	if type(tbl.srcColorBlendFactor) == "string" then
		tbl.srcColorBlendFactor = library.e.blend_factor[tbl.srcColorBlendFactor]
	end
	if type(tbl.dstColorBlendFactor) == "string" then
		tbl.dstColorBlendFactor = library.e.blend_factor[tbl.dstColorBlendFactor]
	end
	if type(tbl.colorBlendOp) == "string" then
		tbl.colorBlendOp = library.e.blend_op[tbl.colorBlendOp]
	end
	if type(tbl.srcAlphaBlendFactor) == "string" then
		tbl.srcAlphaBlendFactor = library.e.blend_factor[tbl.srcAlphaBlendFactor]
	end
	if type(tbl.dstAlphaBlendFactor) == "string" then
		tbl.dstAlphaBlendFactor = library.e.blend_factor[tbl.dstAlphaBlendFactor]
	end
	if type(tbl.alphaBlendOp) == "string" then
		tbl.alphaBlendOp = library.e.blend_op[tbl.alphaBlendOp]
	end
	if type(tbl.colorWriteMask) == "table" then
		tbl.colorWriteMask = library.e.color_component.make_enums(tbl.colorWriteMask)
	elseif type(tbl.colorWriteMask) == "string" then
		tbl.colorWriteMask = library.e.color_component[tbl.colorWriteMask]
	end
	return table_only and tbl or ffi.new("struct VkPipelineColorBlendAttachmentState", tbl)
end
function library.s.PipelineColorBlendAttachmentStateArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineColorBlendAttachmentState(v)
	end
	return ffi.new("struct VkPipelineColorBlendAttachmentState[?]", #tbl, tbl)
end
function library.s.Extent2D(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkExtent2D", tbl)
end
function library.s.Extent2DArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.Extent2D(v)
	end
	return ffi.new("struct VkExtent2D[?]", #tbl, tbl)
end
function library.s.Extent3D(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkExtent3D", tbl)
end
function library.s.Extent3DArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.Extent3D(v)
	end
	return ffi.new("struct VkExtent3D[?]", #tbl, tbl)
end
function library.s.SwapchainCreateInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SwapchainCreateInfoKHR(v)
	end
	return ffi.new("struct VkSwapchainCreateInfoKHR[?]", #tbl, tbl)
end
function library.s.SwapchainKHRArray(tbl) return ffi.new("struct VkSwapchainKHR_T *[?]", #tbl, tbl) end
function library.s.PipelineDepthStencilStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineDepthStencilStateCreateInfo(v)
	end
	return ffi.new("struct VkPipelineDepthStencilStateCreateInfo[?]", #tbl, tbl)
end
function library.s.SurfaceFormatKHR(tbl, table_only)
	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end
	if type(tbl.colorSpace) == "string" then
		tbl.colorSpace = library.e.colorspace[tbl.colorSpace]
	end
	return table_only and tbl or ffi.new("struct VkSurfaceFormatKHR", tbl)
end
function library.s.SurfaceFormatKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SurfaceFormatKHR(v)
	end
	return ffi.new("struct VkSurfaceFormatKHR[?]", #tbl, tbl)
end
function library.s.SurfaceCapabilitiesKHR(tbl, table_only)
	if type(tbl.currentExtent) == "table" then
		tbl.currentExtent = library.s.Extent2D(tbl.currentExtent, true)
	end
	if type(tbl.minImageExtent) == "table" then
		tbl.minImageExtent = library.s.Extent2D(tbl.minImageExtent, true)
	end
	if type(tbl.maxImageExtent) == "table" then
		tbl.maxImageExtent = library.s.Extent2D(tbl.maxImageExtent, true)
	end
	if type(tbl.supportedTransforms) == "table" then
		tbl.supportedTransforms = library.e.surface_transform.make_enums(tbl.supportedTransforms)
	elseif type(tbl.supportedTransforms) == "string" then
		tbl.supportedTransforms = library.e.surface_transform[tbl.supportedTransforms]
	end
	if type(tbl.currentTransform) == "table" then
		tbl.currentTransform = library.e.surface_transform.make_enums(tbl.currentTransform)
	elseif type(tbl.currentTransform) == "string" then
		tbl.currentTransform = library.e.surface_transform[tbl.currentTransform]
	end
	if type(tbl.supportedCompositeAlpha) == "table" then
		tbl.supportedCompositeAlpha = library.e.composite_alpha.make_enums(tbl.supportedCompositeAlpha)
	elseif type(tbl.supportedCompositeAlpha) == "string" then
		tbl.supportedCompositeAlpha = library.e.composite_alpha[tbl.supportedCompositeAlpha]
	end
	if type(tbl.supportedUsageFlags) == "table" then
		tbl.supportedUsageFlags = library.e.image_usage.make_enums(tbl.supportedUsageFlags)
	elseif type(tbl.supportedUsageFlags) == "string" then
		tbl.supportedUsageFlags = library.e.image_usage[tbl.supportedUsageFlags]
	end
	return table_only and tbl or ffi.new("struct VkSurfaceCapabilitiesKHR", tbl)
end
function library.s.SurfaceCapabilitiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SurfaceCapabilitiesKHR(v)
	end
	return ffi.new("struct VkSurfaceCapabilitiesKHR[?]", #tbl, tbl)
end
function library.s.PipelineViewportStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineViewportStateCreateInfo(v)
	end
	return ffi.new("struct VkPipelineViewportStateCreateInfo[?]", #tbl, tbl)
end
function library.s.ImageFormatProperties(tbl, table_only)
	if type(tbl.maxExtent) == "table" then
		tbl.maxExtent = library.s.Extent3D(tbl.maxExtent, true)
	end
	if type(tbl.sampleCounts) == "table" then
		tbl.sampleCounts = library.e.sample_count.make_enums(tbl.sampleCounts)
	elseif type(tbl.sampleCounts) == "string" then
		tbl.sampleCounts = library.e.sample_count[tbl.sampleCounts]
	end
	return table_only and tbl or ffi.new("struct VkImageFormatProperties", tbl)
end
function library.s.ImageFormatPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageFormatProperties(v)
	end
	return ffi.new("struct VkImageFormatProperties[?]", #tbl, tbl)
end
function library.s.AttachmentDescription(tbl, table_only)
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.attachment_description.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.attachment_description[tbl.flags]
	end
	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end
	if type(tbl.samples) == "table" then
		tbl.samples = library.e.sample_count.make_enums(tbl.samples)
	elseif type(tbl.samples) == "string" then
		tbl.samples = library.e.sample_count[tbl.samples]
	end
	if type(tbl.loadOp) == "string" then
		tbl.loadOp = library.e.attachment_load_op[tbl.loadOp]
	end
	if type(tbl.storeOp) == "string" then
		tbl.storeOp = library.e.attachment_store_op[tbl.storeOp]
	end
	if type(tbl.stencilLoadOp) == "string" then
		tbl.stencilLoadOp = library.e.attachment_load_op[tbl.stencilLoadOp]
	end
	if type(tbl.stencilStoreOp) == "string" then
		tbl.stencilStoreOp = library.e.attachment_store_op[tbl.stencilStoreOp]
	end
	if type(tbl.initialLayout) == "string" then
		tbl.initialLayout = library.e.image_layout[tbl.initialLayout]
	end
	if type(tbl.finalLayout) == "string" then
		tbl.finalLayout = library.e.image_layout[tbl.finalLayout]
	end
	return table_only and tbl or ffi.new("struct VkAttachmentDescription", tbl)
end
function library.s.AttachmentDescriptionArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.AttachmentDescription(v)
	end
	return ffi.new("struct VkAttachmentDescription[?]", #tbl, tbl)
end
function library.s.ApplicationInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ApplicationInfo(v)
	end
	return ffi.new("struct VkApplicationInfo[?]", #tbl, tbl)
end
function library.s.RenderPassArray(tbl) return ffi.new("struct VkRenderPass_T *[?]", #tbl, tbl) end
function library.s.SpecializationInfo(tbl, table_only)
	if type(tbl.pMapEntries) == "table" then
		if not tbl.mapEntryCount then
			tbl.mapEntryCount = #tbl.pMapEntries
		end
		tbl.pMapEntries = library.s.SpecializationMapEntryArray(tbl.pMapEntries, false)
	end
	return table_only and tbl or ffi.new("struct VkSpecializationInfo", tbl)
end
function library.s.SpecializationInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SpecializationInfo(v)
	end
	return ffi.new("struct VkSpecializationInfo[?]", #tbl, tbl)
end
function library.s.AttachmentReference(tbl, table_only)
	if type(tbl.layout) == "string" then
		tbl.layout = library.e.image_layout[tbl.layout]
	end
	return table_only and tbl or ffi.new("struct VkAttachmentReference", tbl)
end
function library.s.AttachmentReferenceArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.AttachmentReference(v)
	end
	return ffi.new("struct VkAttachmentReference[?]", #tbl, tbl)
end
function library.s.FramebufferCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.FramebufferCreateInfo(v)
	end
	return ffi.new("struct VkFramebufferCreateInfo[?]", #tbl, tbl)
end
function library.s.DrawIndirectCommand(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkDrawIndirectCommand", tbl)
end
function library.s.DrawIndirectCommandArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DrawIndirectCommand(v)
	end
	return ffi.new("struct VkDrawIndirectCommand[?]", #tbl, tbl)
end
function library.s.SparseImageMemoryBindInfo(tbl, table_only)
	if type(tbl.pBinds) == "table" then
		if not tbl.bindCount then
			tbl.bindCount = #tbl.pBinds
		end
		tbl.pBinds = library.s.SparseImageMemoryBindArray(tbl.pBinds, false)
	end
	return table_only and tbl or ffi.new("struct VkSparseImageMemoryBindInfo", tbl)
end
function library.s.SparseImageMemoryBindInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseImageMemoryBindInfo(v)
	end
	return ffi.new("struct VkSparseImageMemoryBindInfo[?]", #tbl, tbl)
end
function library.s.SamplerArray(tbl) return ffi.new("struct VkSampler_T *[?]", #tbl, tbl) end
function library.s.QueryPoolArray(tbl) return ffi.new("struct VkQueryPool_T *[?]", #tbl, tbl) end
function library.s.DebugMarkerMarkerInfoEXTArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DebugMarkerMarkerInfoEXT(v)
	end
	return ffi.new("struct VkDebugMarkerMarkerInfoEXT[?]", #tbl, tbl)
end
function library.s.ImageResolve(tbl, table_only)
	if type(tbl.srcSubresource) == "table" then
		tbl.srcSubresource = library.s.ImageSubresourceLayers(tbl.srcSubresource, true)
	end
	if type(tbl.srcOffset) == "table" then
		tbl.srcOffset = library.s.Offset3D(tbl.srcOffset, true)
	end
	if type(tbl.dstSubresource) == "table" then
		tbl.dstSubresource = library.s.ImageSubresourceLayers(tbl.dstSubresource, true)
	end
	if type(tbl.dstOffset) == "table" then
		tbl.dstOffset = library.s.Offset3D(tbl.dstOffset, true)
	end
	if type(tbl.extent) == "table" then
		tbl.extent = library.s.Extent3D(tbl.extent, true)
	end
	return table_only and tbl or ffi.new("struct VkImageResolve", tbl)
end
function library.s.ImageResolveArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageResolve(v)
	end
	return ffi.new("struct VkImageResolve[?]", #tbl, tbl)
end
function library.s.DisplayKHRArray(tbl) return ffi.new("struct VkDisplayKHR_T *[?]", #tbl, tbl) end
function library.s.BufferViewCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BufferViewCreateInfo(v)
	end
	return ffi.new("struct VkBufferViewCreateInfo[?]", #tbl, tbl)
end
function library.s.PipelineRasterizationStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineRasterizationStateCreateInfo(v)
	end
	return ffi.new("struct VkPipelineRasterizationStateCreateInfo[?]", #tbl, tbl)
end
function library.s.PipelineCacheCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineCacheCreateInfo(v)
	end
	return ffi.new("struct VkPipelineCacheCreateInfo[?]", #tbl, tbl)
end
function library.s.ClearValue(tbl, table_only)
	if type(tbl.color) == "table" then
		tbl.color = library.s.ClearColorValue(tbl.color, true)
	end
	if type(tbl.depthStencil) == "table" then
		tbl.depthStencil = library.s.ClearDepthStencilValue(tbl.depthStencil, true)
	end
	return table_only and tbl or ffi.new("union VkClearValue", tbl)
end
function library.s.ClearValueArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ClearValue(v)
	end
	return ffi.new("union VkClearValue[?]", #tbl, tbl)
end
function library.s.SubpassDescription(tbl, table_only)
	if type(tbl.pipelineBindPoint) == "string" then
		tbl.pipelineBindPoint = library.e.pipeline_bind_point[tbl.pipelineBindPoint]
	end
	if type(tbl.pInputAttachments) == "table" then
		if not tbl.inputAttachmentCount then
			tbl.inputAttachmentCount = #tbl.pInputAttachments
		end
		tbl.pInputAttachments = library.s.AttachmentReferenceArray(tbl.pInputAttachments, false)
	end
	if type(tbl.pColorAttachments) == "table" then
		if not tbl.colorAttachmentCount then
			tbl.colorAttachmentCount = #tbl.pColorAttachments
		end
		tbl.pColorAttachments = library.s.AttachmentReferenceArray(tbl.pColorAttachments, false)
	end
	if type(tbl.pResolveAttachments) == "table" then
		tbl.pResolveAttachments = library.s.AttachmentReference(tbl.pResolveAttachments, false)
	end
	if type(tbl.pDepthStencilAttachment) == "table" then
		tbl.pDepthStencilAttachment = library.s.AttachmentReference(tbl.pDepthStencilAttachment, false)
	end
	return table_only and tbl or ffi.new("struct VkSubpassDescription", tbl)
end
function library.s.SubpassDescriptionArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SubpassDescription(v)
	end
	return ffi.new("struct VkSubpassDescription[?]", #tbl, tbl)
end
function library.s.ClearAttachment(tbl, table_only)
	if type(tbl.aspectMask) == "table" then
		tbl.aspectMask = library.e.image_aspect.make_enums(tbl.aspectMask)
	elseif type(tbl.aspectMask) == "string" then
		tbl.aspectMask = library.e.image_aspect[tbl.aspectMask]
	end
	if type(tbl.clearValue) == "table" then
		tbl.clearValue = library.s.ClearValue(tbl.clearValue, true)
	end
	return table_only and tbl or ffi.new("struct VkClearAttachment", tbl)
end
function library.s.ClearAttachmentArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ClearAttachment(v)
	end
	return ffi.new("struct VkClearAttachment[?]", #tbl, tbl)
end
function library.s.SubresourceLayout(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkSubresourceLayout", tbl)
end
function library.s.SubresourceLayoutArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SubresourceLayout(v)
	end
	return ffi.new("struct VkSubresourceLayout[?]", #tbl, tbl)
end
function library.s.SparseImageFormatProperties(tbl, table_only)
	if type(tbl.aspectMask) == "table" then
		tbl.aspectMask = library.e.image_aspect.make_enums(tbl.aspectMask)
	elseif type(tbl.aspectMask) == "string" then
		tbl.aspectMask = library.e.image_aspect[tbl.aspectMask]
	end
	if type(tbl.imageGranularity) == "table" then
		tbl.imageGranularity = library.s.Extent3D(tbl.imageGranularity, true)
	end
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.sparse_image_format.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.sparse_image_format[tbl.flags]
	end
	return table_only and tbl or ffi.new("struct VkSparseImageFormatProperties", tbl)
end
function library.s.SparseImageFormatPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseImageFormatProperties(v)
	end
	return ffi.new("struct VkSparseImageFormatProperties[?]", #tbl, tbl)
end
function library.s.DeviceMemoryArray(tbl) return ffi.new("struct VkDeviceMemory_T *[?]", #tbl, tbl) end
function library.s.QueueFamilyProperties(tbl, table_only)
	if type(tbl.queueFlags) == "table" then
		tbl.queueFlags = library.e.queue.make_enums(tbl.queueFlags)
	elseif type(tbl.queueFlags) == "string" then
		tbl.queueFlags = library.e.queue[tbl.queueFlags]
	end
	if type(tbl.minImageTransferGranularity) == "table" then
		tbl.minImageTransferGranularity = library.s.Extent3D(tbl.minImageTransferGranularity, true)
	end
	return table_only and tbl or ffi.new("struct VkQueueFamilyProperties", tbl)
end
function library.s.QueueFamilyPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.QueueFamilyProperties(v)
	end
	return ffi.new("struct VkQueueFamilyProperties[?]", #tbl, tbl)
end
function library.s.ClearRect(tbl, table_only)
	if type(tbl.rect) == "table" then
		tbl.rect = library.s.Rect2D(tbl.rect, true)
	end
	return table_only and tbl or ffi.new("struct VkClearRect", tbl)
end
function library.s.ClearRectArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ClearRect(v)
	end
	return ffi.new("struct VkClearRect[?]", #tbl, tbl)
end
function library.s.LayerProperties(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkLayerProperties", tbl)
end
function library.s.LayerPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.LayerProperties(v)
	end
	return ffi.new("struct VkLayerProperties[?]", #tbl, tbl)
end
function library.s.CommandBufferArray(tbl) return ffi.new("struct VkCommandBuffer_T *[?]", #tbl, tbl) end
function library.s.DescriptorImageInfo(tbl, table_only)
	if type(tbl.imageLayout) == "string" then
		tbl.imageLayout = library.e.image_layout[tbl.imageLayout]
	end
	return table_only and tbl or ffi.new("struct VkDescriptorImageInfo", tbl)
end
function library.s.DescriptorImageInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorImageInfo(v)
	end
	return ffi.new("struct VkDescriptorImageInfo[?]", #tbl, tbl)
end
function library.s.DescriptorPoolSize(tbl, table_only)
	if type(tbl.type) == "string" then
		tbl.type = library.e.descriptor_type[tbl.type]
	end
	return table_only and tbl or ffi.new("struct VkDescriptorPoolSize", tbl)
end
function library.s.DescriptorPoolSizeArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorPoolSize(v)
	end
	return ffi.new("struct VkDescriptorPoolSize[?]", #tbl, tbl)
end
function library.s.ClearColorValue(tbl, table_only)
	return table_only and tbl or ffi.new("union VkClearColorValue", tbl)
end
function library.s.ClearColorValueArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ClearColorValue(v)
	end
	return ffi.new("union VkClearColorValue[?]", #tbl, tbl)
end
function library.s.ExternalImageFormatPropertiesNV(tbl, table_only)
	if type(tbl.imageFormatProperties) == "table" then
		tbl.imageFormatProperties = library.s.ImageFormatProperties(tbl.imageFormatProperties, true)
	end
	if type(tbl.externalMemoryFeatures) == "table" then
		tbl.externalMemoryFeatures = library.e.external_memory_feature_nv.make_enums(tbl.externalMemoryFeatures)
	elseif type(tbl.externalMemoryFeatures) == "string" then
		tbl.externalMemoryFeatures = library.e.external_memory_feature_nv[tbl.externalMemoryFeatures]
	end
	if type(tbl.exportFromImportedHandleTypes) == "table" then
		tbl.exportFromImportedHandleTypes = library.e.external_memory_handle_type_nv.make_enums(tbl.exportFromImportedHandleTypes)
	elseif type(tbl.exportFromImportedHandleTypes) == "string" then
		tbl.exportFromImportedHandleTypes = library.e.external_memory_handle_type_nv[tbl.exportFromImportedHandleTypes]
	end
	if type(tbl.compatibleHandleTypes) == "table" then
		tbl.compatibleHandleTypes = library.e.external_memory_handle_type_nv.make_enums(tbl.compatibleHandleTypes)
	elseif type(tbl.compatibleHandleTypes) == "string" then
		tbl.compatibleHandleTypes = library.e.external_memory_handle_type_nv[tbl.compatibleHandleTypes]
	end
	return table_only and tbl or ffi.new("struct VkExternalImageFormatPropertiesNV", tbl)
end
function library.s.ExternalImageFormatPropertiesNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExternalImageFormatPropertiesNV(v)
	end
	return ffi.new("struct VkExternalImageFormatPropertiesNV[?]", #tbl, tbl)
end
function library.s.CommandBufferInheritanceInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.CommandBufferInheritanceInfo(v)
	end
	return ffi.new("struct VkCommandBufferInheritanceInfo[?]", #tbl, tbl)
end
function library.s.DisplayModeParametersKHR(tbl, table_only)
	if type(tbl.visibleRegion) == "table" then
		tbl.visibleRegion = library.s.Extent2D(tbl.visibleRegion, true)
	end
	return table_only and tbl or ffi.new("struct VkDisplayModeParametersKHR", tbl)
end
function library.s.DisplayModeParametersKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayModeParametersKHR(v)
	end
	return ffi.new("struct VkDisplayModeParametersKHR[?]", #tbl, tbl)
end
function library.s.CommandBufferAllocateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.CommandBufferAllocateInfo(v)
	end
	return ffi.new("struct VkCommandBufferAllocateInfo[?]", #tbl, tbl)
end
function library.s.FormatProperties(tbl, table_only)
	if type(tbl.linearTilingFeatures) == "table" then
		tbl.linearTilingFeatures = library.e.format_feature.make_enums(tbl.linearTilingFeatures)
	elseif type(tbl.linearTilingFeatures) == "string" then
		tbl.linearTilingFeatures = library.e.format_feature[tbl.linearTilingFeatures]
	end
	if type(tbl.optimalTilingFeatures) == "table" then
		tbl.optimalTilingFeatures = library.e.format_feature.make_enums(tbl.optimalTilingFeatures)
	elseif type(tbl.optimalTilingFeatures) == "string" then
		tbl.optimalTilingFeatures = library.e.format_feature[tbl.optimalTilingFeatures]
	end
	if type(tbl.bufferFeatures) == "table" then
		tbl.bufferFeatures = library.e.format_feature.make_enums(tbl.bufferFeatures)
	elseif type(tbl.bufferFeatures) == "string" then
		tbl.bufferFeatures = library.e.format_feature[tbl.bufferFeatures]
	end
	return table_only and tbl or ffi.new("struct VkFormatProperties", tbl)
end
function library.s.FormatPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.FormatProperties(v)
	end
	return ffi.new("struct VkFormatProperties[?]", #tbl, tbl)
end
function library.s.ImageSubresource(tbl, table_only)
	if type(tbl.aspectMask) == "table" then
		tbl.aspectMask = library.e.image_aspect.make_enums(tbl.aspectMask)
	elseif type(tbl.aspectMask) == "string" then
		tbl.aspectMask = library.e.image_aspect[tbl.aspectMask]
	end
	return table_only and tbl or ffi.new("struct VkImageSubresource", tbl)
end
function library.s.ImageSubresourceArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageSubresource(v)
	end
	return ffi.new("struct VkImageSubresource[?]", #tbl, tbl)
end
function library.s.CopyDescriptorSetArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.CopyDescriptorSet(v)
	end
	return ffi.new("struct VkCopyDescriptorSet[?]", #tbl, tbl)
end
function library.s.SamplerCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SamplerCreateInfo(v)
	end
	return ffi.new("struct VkSamplerCreateInfo[?]", #tbl, tbl)
end
function library.s.EventCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.EventCreateInfo(v)
	end
	return ffi.new("struct VkEventCreateInfo[?]", #tbl, tbl)
end
function library.s.VertexInputBindingDescription(tbl, table_only)
	if type(tbl.inputRate) == "string" then
		tbl.inputRate = library.e.vertex_input_rate[tbl.inputRate]
	end
	return table_only and tbl or ffi.new("struct VkVertexInputBindingDescription", tbl)
end
function library.s.VertexInputBindingDescriptionArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.VertexInputBindingDescription(v)
	end
	return ffi.new("struct VkVertexInputBindingDescription[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceProperties(tbl, table_only)
	if type(tbl.deviceType) == "string" then
		tbl.deviceType = library.e.physical_device_type[tbl.deviceType]
	end
	if type(tbl.limits) == "table" then
		tbl.limits = library.s.PhysicalDeviceLimits(tbl.limits, true)
	end
	if type(tbl.sparseProperties) == "table" then
		tbl.sparseProperties = library.s.PhysicalDeviceSparseProperties(tbl.sparseProperties, true)
	end
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceProperties", tbl)
end
function library.s.PhysicalDevicePropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceProperties(v)
	end
	return ffi.new("struct VkPhysicalDeviceProperties[?]", #tbl, tbl)
end
function library.s.PresentInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PresentInfoKHR(v)
	end
	return ffi.new("struct VkPresentInfoKHR[?]", #tbl, tbl)
end
function library.s.DedicatedAllocationImageCreateInfoNV(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkDedicatedAllocationImageCreateInfoNV", tbl)
end
function library.s.DedicatedAllocationImageCreateInfoNVArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DedicatedAllocationImageCreateInfoNV(v)
	end
	return ffi.new("struct VkDedicatedAllocationImageCreateInfoNV[?]", #tbl, tbl)
end
function library.s.GraphicsPipelineCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.GraphicsPipelineCreateInfo(v)
	end
	return ffi.new("struct VkGraphicsPipelineCreateInfo[?]", #tbl, tbl)
end
function library.s.BufferCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BufferCreateInfo(v)
	end
	return ffi.new("struct VkBufferCreateInfo[?]", #tbl, tbl)
end
function library.s.AllocationCallbacks(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkAllocationCallbacks", tbl)
end
function library.s.AllocationCallbacksArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.AllocationCallbacks(v)
	end
	return ffi.new("struct VkAllocationCallbacks[?]", #tbl, tbl)
end
function library.s.SparseImageMemoryRequirements(tbl, table_only)
	if type(tbl.formatProperties) == "table" then
		tbl.formatProperties = library.s.SparseImageFormatProperties(tbl.formatProperties, true)
	end
	return table_only and tbl or ffi.new("struct VkSparseImageMemoryRequirements", tbl)
end
function library.s.SparseImageMemoryRequirementsArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseImageMemoryRequirements(v)
	end
	return ffi.new("struct VkSparseImageMemoryRequirements[?]", #tbl, tbl)
end
function library.s.SubpassDependency(tbl, table_only)
	if type(tbl.srcStageMask) == "table" then
		tbl.srcStageMask = library.e.pipeline_stage.make_enums(tbl.srcStageMask)
	elseif type(tbl.srcStageMask) == "string" then
		tbl.srcStageMask = library.e.pipeline_stage[tbl.srcStageMask]
	end
	if type(tbl.dstStageMask) == "table" then
		tbl.dstStageMask = library.e.pipeline_stage.make_enums(tbl.dstStageMask)
	elseif type(tbl.dstStageMask) == "string" then
		tbl.dstStageMask = library.e.pipeline_stage[tbl.dstStageMask]
	end
	if type(tbl.srcAccessMask) == "table" then
		tbl.srcAccessMask = library.e.access.make_enums(tbl.srcAccessMask)
	elseif type(tbl.srcAccessMask) == "string" then
		tbl.srcAccessMask = library.e.access[tbl.srcAccessMask]
	end
	if type(tbl.dstAccessMask) == "table" then
		tbl.dstAccessMask = library.e.access.make_enums(tbl.dstAccessMask)
	elseif type(tbl.dstAccessMask) == "string" then
		tbl.dstAccessMask = library.e.access[tbl.dstAccessMask]
	end
	if type(tbl.dependencyFlags) == "table" then
		tbl.dependencyFlags = library.e.dependency.make_enums(tbl.dependencyFlags)
	elseif type(tbl.dependencyFlags) == "string" then
		tbl.dependencyFlags = library.e.dependency[tbl.dependencyFlags]
	end
	return table_only and tbl or ffi.new("struct VkSubpassDependency", tbl)
end
function library.s.SubpassDependencyArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SubpassDependency(v)
	end
	return ffi.new("struct VkSubpassDependency[?]", #tbl, tbl)
end
function library.s.ImageCopy(tbl, table_only)
	if type(tbl.srcSubresource) == "table" then
		tbl.srcSubresource = library.s.ImageSubresourceLayers(tbl.srcSubresource, true)
	end
	if type(tbl.srcOffset) == "table" then
		tbl.srcOffset = library.s.Offset3D(tbl.srcOffset, true)
	end
	if type(tbl.dstSubresource) == "table" then
		tbl.dstSubresource = library.s.ImageSubresourceLayers(tbl.dstSubresource, true)
	end
	if type(tbl.dstOffset) == "table" then
		tbl.dstOffset = library.s.Offset3D(tbl.dstOffset, true)
	end
	if type(tbl.extent) == "table" then
		tbl.extent = library.s.Extent3D(tbl.extent, true)
	end
	return table_only and tbl or ffi.new("struct VkImageCopy", tbl)
end
function library.s.ImageCopyArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageCopy(v)
	end
	return ffi.new("struct VkImageCopy[?]", #tbl, tbl)
end
function library.s.DescriptorSetLayoutArray(tbl) return ffi.new("struct VkDescriptorSetLayout_T *[?]", #tbl, tbl) end
function library.s.VertexInputAttributeDescription(tbl, table_only)
	if type(tbl.format) == "string" then
		tbl.format = library.e.format[tbl.format]
	end
	return table_only and tbl or ffi.new("struct VkVertexInputAttributeDescription", tbl)
end
function library.s.VertexInputAttributeDescriptionArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.VertexInputAttributeDescription(v)
	end
	return ffi.new("struct VkVertexInputAttributeDescription[?]", #tbl, tbl)
end
function library.s.CommandPoolArray(tbl) return ffi.new("struct VkCommandPool_T *[?]", #tbl, tbl) end
function library.s.DrawIndexedIndirectCommand(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkDrawIndexedIndirectCommand", tbl)
end
function library.s.DrawIndexedIndirectCommandArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DrawIndexedIndirectCommand(v)
	end
	return ffi.new("struct VkDrawIndexedIndirectCommand[?]", #tbl, tbl)
end
function library.s.ImageMemoryBarrierArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageMemoryBarrier(v)
	end
	return ffi.new("struct VkImageMemoryBarrier[?]", #tbl, tbl)
end
function library.s.ImageSubresourceLayers(tbl, table_only)
	if type(tbl.aspectMask) == "table" then
		tbl.aspectMask = library.e.image_aspect.make_enums(tbl.aspectMask)
	elseif type(tbl.aspectMask) == "string" then
		tbl.aspectMask = library.e.image_aspect[tbl.aspectMask]
	end
	return table_only and tbl or ffi.new("struct VkImageSubresourceLayers", tbl)
end
function library.s.ImageSubresourceLayersArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageSubresourceLayers(v)
	end
	return ffi.new("struct VkImageSubresourceLayers[?]", #tbl, tbl)
end
function library.s.Offset2D(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkOffset2D", tbl)
end
function library.s.Offset2DArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.Offset2D(v)
	end
	return ffi.new("struct VkOffset2D[?]", #tbl, tbl)
end
function library.s.CommandBufferBeginInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.CommandBufferBeginInfo(v)
	end
	return ffi.new("struct VkCommandBufferBeginInfo[?]", #tbl, tbl)
end
function library.s.DisplayModeCreateInfoKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayModeCreateInfoKHR(v)
	end
	return ffi.new("struct VkDisplayModeCreateInfoKHR[?]", #tbl, tbl)
end
function library.s.RenderPassCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.RenderPassCreateInfo(v)
	end
	return ffi.new("struct VkRenderPassCreateInfo[?]", #tbl, tbl)
end
function library.s.DescriptorBufferInfo(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkDescriptorBufferInfo", tbl)
end
function library.s.DescriptorBufferInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorBufferInfo(v)
	end
	return ffi.new("struct VkDescriptorBufferInfo[?]", #tbl, tbl)
end
function library.s.DescriptorSetLayoutBinding(tbl, table_only)
	if type(tbl.descriptorType) == "string" then
		tbl.descriptorType = library.e.descriptor_type[tbl.descriptorType]
	end
	if type(tbl.stageFlags) == "table" then
		tbl.stageFlags = library.e.shader_stage.make_enums(tbl.stageFlags)
	elseif type(tbl.stageFlags) == "string" then
		tbl.stageFlags = library.e.shader_stage[tbl.stageFlags]
	end
	return table_only and tbl or ffi.new("struct VkDescriptorSetLayoutBinding", tbl)
end
function library.s.DescriptorSetLayoutBindingArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorSetLayoutBinding(v)
	end
	return ffi.new("struct VkDescriptorSetLayoutBinding[?]", #tbl, tbl)
end
function library.s.PipelineLayoutCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineLayoutCreateInfo(v)
	end
	return ffi.new("struct VkPipelineLayoutCreateInfo[?]", #tbl, tbl)
end
function library.s.Offset3D(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkOffset3D", tbl)
end
function library.s.Offset3DArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.Offset3D(v)
	end
	return ffi.new("struct VkOffset3D[?]", #tbl, tbl)
end
function library.s.ShaderModuleCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ShaderModuleCreateInfo(v)
	end
	return ffi.new("struct VkShaderModuleCreateInfo[?]", #tbl, tbl)
end
function library.s.QueueArray(tbl) return ffi.new("struct VkQueue_T *[?]", #tbl, tbl) end
function library.s.DeviceQueueCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceQueueCreateInfo(v)
	end
	return ffi.new("struct VkDeviceQueueCreateInfo[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceMemoryProperties(tbl, table_only)
	if type(tbl.memoryTypes) == "table" then
		tbl.memoryTypes = library.s.MemoryType(tbl.memoryTypes, true)
	end
	if type(tbl.memoryHeaps) == "table" then
		tbl.memoryHeaps = library.s.MemoryHeap(tbl.memoryHeaps, true)
	end
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceMemoryProperties", tbl)
end
function library.s.PhysicalDeviceMemoryPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceMemoryProperties(v)
	end
	return ffi.new("struct VkPhysicalDeviceMemoryProperties[?]", #tbl, tbl)
end
function library.s.PhysicalDeviceLimits(tbl, table_only)
	if type(tbl.framebufferColorSampleCounts) == "table" then
		tbl.framebufferColorSampleCounts = library.e.sample_count.make_enums(tbl.framebufferColorSampleCounts)
	elseif type(tbl.framebufferColorSampleCounts) == "string" then
		tbl.framebufferColorSampleCounts = library.e.sample_count[tbl.framebufferColorSampleCounts]
	end
	if type(tbl.framebufferDepthSampleCounts) == "table" then
		tbl.framebufferDepthSampleCounts = library.e.sample_count.make_enums(tbl.framebufferDepthSampleCounts)
	elseif type(tbl.framebufferDepthSampleCounts) == "string" then
		tbl.framebufferDepthSampleCounts = library.e.sample_count[tbl.framebufferDepthSampleCounts]
	end
	if type(tbl.framebufferStencilSampleCounts) == "table" then
		tbl.framebufferStencilSampleCounts = library.e.sample_count.make_enums(tbl.framebufferStencilSampleCounts)
	elseif type(tbl.framebufferStencilSampleCounts) == "string" then
		tbl.framebufferStencilSampleCounts = library.e.sample_count[tbl.framebufferStencilSampleCounts]
	end
	if type(tbl.framebufferNoAttachmentsSampleCounts) == "table" then
		tbl.framebufferNoAttachmentsSampleCounts = library.e.sample_count.make_enums(tbl.framebufferNoAttachmentsSampleCounts)
	elseif type(tbl.framebufferNoAttachmentsSampleCounts) == "string" then
		tbl.framebufferNoAttachmentsSampleCounts = library.e.sample_count[tbl.framebufferNoAttachmentsSampleCounts]
	end
	if type(tbl.sampledImageColorSampleCounts) == "table" then
		tbl.sampledImageColorSampleCounts = library.e.sample_count.make_enums(tbl.sampledImageColorSampleCounts)
	elseif type(tbl.sampledImageColorSampleCounts) == "string" then
		tbl.sampledImageColorSampleCounts = library.e.sample_count[tbl.sampledImageColorSampleCounts]
	end
	if type(tbl.sampledImageIntegerSampleCounts) == "table" then
		tbl.sampledImageIntegerSampleCounts = library.e.sample_count.make_enums(tbl.sampledImageIntegerSampleCounts)
	elseif type(tbl.sampledImageIntegerSampleCounts) == "string" then
		tbl.sampledImageIntegerSampleCounts = library.e.sample_count[tbl.sampledImageIntegerSampleCounts]
	end
	if type(tbl.sampledImageDepthSampleCounts) == "table" then
		tbl.sampledImageDepthSampleCounts = library.e.sample_count.make_enums(tbl.sampledImageDepthSampleCounts)
	elseif type(tbl.sampledImageDepthSampleCounts) == "string" then
		tbl.sampledImageDepthSampleCounts = library.e.sample_count[tbl.sampledImageDepthSampleCounts]
	end
	if type(tbl.sampledImageStencilSampleCounts) == "table" then
		tbl.sampledImageStencilSampleCounts = library.e.sample_count.make_enums(tbl.sampledImageStencilSampleCounts)
	elseif type(tbl.sampledImageStencilSampleCounts) == "string" then
		tbl.sampledImageStencilSampleCounts = library.e.sample_count[tbl.sampledImageStencilSampleCounts]
	end
	if type(tbl.storageImageSampleCounts) == "table" then
		tbl.storageImageSampleCounts = library.e.sample_count.make_enums(tbl.storageImageSampleCounts)
	elseif type(tbl.storageImageSampleCounts) == "string" then
		tbl.storageImageSampleCounts = library.e.sample_count[tbl.storageImageSampleCounts]
	end
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceLimits", tbl)
end
function library.s.PhysicalDeviceLimitsArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceLimits(v)
	end
	return ffi.new("struct VkPhysicalDeviceLimits[?]", #tbl, tbl)
end
function library.s.SparseImageMemoryBind(tbl, table_only)
	if type(tbl.subresource) == "table" then
		tbl.subresource = library.s.ImageSubresource(tbl.subresource, true)
	end
	if type(tbl.offset) == "table" then
		tbl.offset = library.s.Offset3D(tbl.offset, true)
	end
	if type(tbl.extent) == "table" then
		tbl.extent = library.s.Extent3D(tbl.extent, true)
	end
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.sparse_memory_bind.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.sparse_memory_bind[tbl.flags]
	end
	return table_only and tbl or ffi.new("struct VkSparseImageMemoryBind", tbl)
end
function library.s.SparseImageMemoryBindArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SparseImageMemoryBind(v)
	end
	return ffi.new("struct VkSparseImageMemoryBind[?]", #tbl, tbl)
end
function library.s.FenceCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.FenceCreateInfo(v)
	end
	return ffi.new("struct VkFenceCreateInfo[?]", #tbl, tbl)
end
function library.s.MemoryAllocateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryAllocateInfo(v)
	end
	return ffi.new("struct VkMemoryAllocateInfo[?]", #tbl, tbl)
end
function library.s.MemoryHeap(tbl, table_only)
	if type(tbl.flags) == "table" then
		tbl.flags = library.e.memory_heap.make_enums(tbl.flags)
	elseif type(tbl.flags) == "string" then
		tbl.flags = library.e.memory_heap[tbl.flags]
	end
	return table_only and tbl or ffi.new("struct VkMemoryHeap", tbl)
end
function library.s.MemoryHeapArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryHeap(v)
	end
	return ffi.new("struct VkMemoryHeap[?]", #tbl, tbl)
end
function library.s.SemaphoreCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SemaphoreCreateInfo(v)
	end
	return ffi.new("struct VkSemaphoreCreateInfo[?]", #tbl, tbl)
end
function library.s.MemoryType(tbl, table_only)
	if type(tbl.propertyFlags) == "table" then
		tbl.propertyFlags = library.e.memory_property.make_enums(tbl.propertyFlags)
	elseif type(tbl.propertyFlags) == "string" then
		tbl.propertyFlags = library.e.memory_property[tbl.propertyFlags]
	end
	return table_only and tbl or ffi.new("struct VkMemoryType", tbl)
end
function library.s.MemoryTypeArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryType(v)
	end
	return ffi.new("struct VkMemoryType[?]", #tbl, tbl)
end
function library.s.PipelineArray(tbl) return ffi.new("struct VkPipeline_T *[?]", #tbl, tbl) end
function library.s.PipelineInputAssemblyStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineInputAssemblyStateCreateInfo(v)
	end
	return ffi.new("struct VkPipelineInputAssemblyStateCreateInfo[?]", #tbl, tbl)
end
function library.s.PipelineDynamicStateCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PipelineDynamicStateCreateInfo(v)
	end
	return ffi.new("struct VkPipelineDynamicStateCreateInfo[?]", #tbl, tbl)
end
function library.s.ImageBlit(tbl, table_only)
	if type(tbl.srcSubresource) == "table" then
		tbl.srcSubresource = library.s.ImageSubresourceLayers(tbl.srcSubresource, true)
	end
	if type(tbl.srcOffsets) == "table" then
		tbl.srcOffsets = library.s.Offset3D(tbl.srcOffsets, true)
	end
	if type(tbl.dstSubresource) == "table" then
		tbl.dstSubresource = library.s.ImageSubresourceLayers(tbl.dstSubresource, true)
	end
	if type(tbl.dstOffsets) == "table" then
		tbl.dstOffsets = library.s.Offset3D(tbl.dstOffsets, true)
	end
	return table_only and tbl or ffi.new("struct VkImageBlit", tbl)
end
function library.s.ImageBlitArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageBlit(v)
	end
	return ffi.new("struct VkImageBlit[?]", #tbl, tbl)
end
function library.s.CommandPoolCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.CommandPoolCreateInfo(v)
	end
	return ffi.new("struct VkCommandPoolCreateInfo[?]", #tbl, tbl)
end
function library.s.DeviceCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DeviceCreateInfo(v)
	end
	return ffi.new("struct VkDeviceCreateInfo[?]", #tbl, tbl)
end
function library.s.DisplayModePropertiesKHR(tbl, table_only)
	if type(tbl.parameters) == "table" then
		tbl.parameters = library.s.DisplayModeParametersKHR(tbl.parameters, true)
	end
	return table_only and tbl or ffi.new("struct VkDisplayModePropertiesKHR", tbl)
end
function library.s.DisplayModePropertiesKHRArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DisplayModePropertiesKHR(v)
	end
	return ffi.new("struct VkDisplayModePropertiesKHR[?]", #tbl, tbl)
end
function library.s.FramebufferArray(tbl) return ffi.new("struct VkFramebuffer_T *[?]", #tbl, tbl) end
function library.s.FenceArray(tbl) return ffi.new("struct VkFence_T *[?]", #tbl, tbl) end
function library.s.BufferCopy(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkBufferCopy", tbl)
end
function library.s.BufferCopyArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BufferCopy(v)
	end
	return ffi.new("struct VkBufferCopy[?]", #tbl, tbl)
end
function library.s.ExtensionProperties(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkExtensionProperties", tbl)
end
function library.s.ExtensionPropertiesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ExtensionProperties(v)
	end
	return ffi.new("struct VkExtensionProperties[?]", #tbl, tbl)
end
function library.s.EventArray(tbl) return ffi.new("struct VkEvent_T *[?]", #tbl, tbl) end
function library.s.PhysicalDeviceFeatures(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkPhysicalDeviceFeatures", tbl)
end
function library.s.PhysicalDeviceFeaturesArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PhysicalDeviceFeatures(v)
	end
	return ffi.new("struct VkPhysicalDeviceFeatures[?]", #tbl, tbl)
end
function library.s.BindSparseInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BindSparseInfo(v)
	end
	return ffi.new("struct VkBindSparseInfo[?]", #tbl, tbl)
end
function library.s.BufferViewArray(tbl) return ffi.new("struct VkBufferView_T *[?]", #tbl, tbl) end
function library.s.SpecializationMapEntry(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkSpecializationMapEntry", tbl)
end
function library.s.SpecializationMapEntryArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SpecializationMapEntry(v)
	end
	return ffi.new("struct VkSpecializationMapEntry[?]", #tbl, tbl)
end
function library.s.MappedMemoryRangeArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MappedMemoryRange(v)
	end
	return ffi.new("struct VkMappedMemoryRange[?]", #tbl, tbl)
end
function library.s.MemoryRequirements(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkMemoryRequirements", tbl)
end
function library.s.MemoryRequirementsArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryRequirements(v)
	end
	return ffi.new("struct VkMemoryRequirements[?]", #tbl, tbl)
end
function library.s.SubmitInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.SubmitInfo(v)
	end
	return ffi.new("struct VkSubmitInfo[?]", #tbl, tbl)
end
function library.s.InstanceCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.InstanceCreateInfo(v)
	end
	return ffi.new("struct VkInstanceCreateInfo[?]", #tbl, tbl)
end
function library.s.DeviceArray(tbl) return ffi.new("struct VkDevice_T *[?]", #tbl, tbl) end
function library.s.ImageViewCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.ImageViewCreateInfo(v)
	end
	return ffi.new("struct VkImageViewCreateInfo[?]", #tbl, tbl)
end
function library.s.Viewport(tbl, table_only)
	return table_only and tbl or ffi.new("struct VkViewport", tbl)
end
function library.s.ViewportArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.Viewport(v)
	end
	return ffi.new("struct VkViewport[?]", #tbl, tbl)
end
function library.s.DescriptorPoolCreateInfoArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.DescriptorPoolCreateInfo(v)
	end
	return ffi.new("struct VkDescriptorPoolCreateInfo[?]", #tbl, tbl)
end
function library.s.BufferImageCopy(tbl, table_only)
	if type(tbl.imageSubresource) == "table" then
		tbl.imageSubresource = library.s.ImageSubresourceLayers(tbl.imageSubresource, true)
	end
	if type(tbl.imageOffset) == "table" then
		tbl.imageOffset = library.s.Offset3D(tbl.imageOffset, true)
	end
	if type(tbl.imageExtent) == "table" then
		tbl.imageExtent = library.s.Extent3D(tbl.imageExtent, true)
	end
	return table_only and tbl or ffi.new("struct VkBufferImageCopy", tbl)
end
function library.s.BufferImageCopyArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.BufferImageCopy(v)
	end
	return ffi.new("struct VkBufferImageCopy[?]", #tbl, tbl)
end
function library.s.MemoryBarrierArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.MemoryBarrier(v)
	end
	return ffi.new("struct VkMemoryBarrier[?]", #tbl, tbl)
end
function library.s.PushConstantRange(tbl, table_only)
	if type(tbl.stageFlags) == "table" then
		tbl.stageFlags = library.e.shader_stage.make_enums(tbl.stageFlags)
	elseif type(tbl.stageFlags) == "string" then
		tbl.stageFlags = library.e.shader_stage[tbl.stageFlags]
	end
	return table_only and tbl or ffi.new("struct VkPushConstantRange", tbl)
end
function library.s.PushConstantRangeArray(tbl)
	for i, v in ipairs(tbl) do
		tbl[i] = library.s.PushConstantRange(v)
	end
	return ffi.new("struct VkPushConstantRange[?]", #tbl, tbl)
end
function library.CreateBufferView(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.BufferViewCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkBufferView_T * [1]")
	local status = CLIB.vkCreateBufferView(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator)
	if type(pCreateInfos) == "table" then
		if not createInfoCount then
			createInfoCount = #pCreateInfos
		end
		pCreateInfos = library.s.GraphicsPipelineCreateInfoArray(pCreateInfos, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkPipeline_T * [1]")
	local status = CLIB.vkCreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfos
		return box[0], status
	end

	return nil, status
end
function library.CreateShaderModule(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.ShaderModuleCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkShaderModule_T * [1]")
	local status = CLIB.vkCreateShaderModule(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateFramebuffer(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.FramebufferCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkFramebuffer_T * [1]")
	local status = CLIB.vkCreateFramebuffer(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator)
	if type(pCreateInfos) == "table" then
		if not createInfoCount then
			createInfoCount = #pCreateInfos
		end
		pCreateInfos = library.s.ComputePipelineCreateInfoArray(pCreateInfos, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkPipeline_T * [1]")
	local status = CLIB.vkCreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfos
		return box[0], status
	end

	return nil, status
end
function library.CreateDescriptorSetLayout(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DescriptorSetLayoutCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkDescriptorSetLayout_T * [1]")
	local status = CLIB.vkCreateDescriptorSetLayout(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.AllocateCommandBuffers(device, pAllocateInfo)
	if type(pAllocateInfo) == "table" then
		pAllocateInfo = library.s.CommandBufferAllocateInfo(pAllocateInfo, false)
	end
	local box = ffi.new("struct VkCommandBuffer_T * [1]")
	local status = CLIB.vkAllocateCommandBuffers(device, pAllocateInfo, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pAllocateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateDescriptorPool(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DescriptorPoolCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkDescriptorPool_T * [1]")
	local status = CLIB.vkCreateDescriptorPool(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateBuffer(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.BufferCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkBuffer_T * [1]")
	local status = CLIB.vkCreateBuffer(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateSemaphore(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.SemaphoreCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkSemaphore_T * [1]")
	local status = CLIB.vkCreateSemaphore(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreatePipelineCache(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.PipelineCacheCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkPipelineCache_T * [1]")
	local status = CLIB.vkCreatePipelineCache(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateImageView(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.ImageViewCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkImageView_T * [1]")
	local status = CLIB.vkCreateImageView(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateDevice(physicalDevice, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DeviceCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkDevice_T * [1]")
	local status = CLIB.vkCreateDevice(physicalDevice, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateInstance(pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.InstanceCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkInstance_T * [1]")
	local status = CLIB.vkCreateInstance(pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateDebugReportCallback(instance, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DebugReportCallbackCreateInfoEXT(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkDebugReportCallbackEXT_T * [1]")
	local status = library.CreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateSharedSwapchains(device, swapchainCount, pCreateInfos, pAllocator)
	if type(pCreateInfos) == "table" then
		if not swapchainCount then
			swapchainCount = #pCreateInfos
		end
		pCreateInfos = library.s.SwapchainCreateInfoKHRArray(pCreateInfos, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkSwapchainKHR_T * [1]")
	local status = library.CreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfos
		return box[0], status
	end

	return nil, status
end
function library.CreateDisplayPlaneSurface(instance, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DisplaySurfaceCreateInfoKHR(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkSurfaceKHR_T * [1]")
	local status = library.CreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateImage(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.ImageCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkImage_T * [1]")
	local status = CLIB.vkCreateImage(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateSwapchain(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.SwapchainCreateInfoKHR(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkSwapchainKHR_T * [1]")
	local status = library.CreateSwapchainKHR(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.AllocateMemory(device, pAllocateInfo, pAllocator)
	if type(pAllocateInfo) == "table" then
		pAllocateInfo = library.s.MemoryAllocateInfo(pAllocateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkDeviceMemory_T * [1]")
	local status = CLIB.vkAllocateMemory(device, pAllocateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pAllocateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateDisplayMode(physicalDevice, display, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.DisplayModeCreateInfoKHR(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkDisplayModeKHR_T * [1]")
	local status = library.CreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateFence(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.FenceCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkFence_T * [1]")
	local status = CLIB.vkCreateFence(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateRenderPass(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.RenderPassCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkRenderPass_T * [1]")
	local status = CLIB.vkCreateRenderPass(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateQueryPool(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.QueryPoolCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkQueryPool_T * [1]")
	local status = CLIB.vkCreateQueryPool(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateSampler(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.SamplerCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkSampler_T * [1]")
	local status = CLIB.vkCreateSampler(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateCommandPool(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.CommandPoolCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkCommandPool_T * [1]")
	local status = CLIB.vkCreateCommandPool(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreateEvent(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.EventCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkEvent_T * [1]")
	local status = CLIB.vkCreateEvent(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.AllocateDescriptorSets(device, pAllocateInfo)
	if type(pAllocateInfo) == "table" then
		pAllocateInfo = library.s.DescriptorSetAllocateInfo(pAllocateInfo, false)
	end
	local box = ffi.new("struct VkDescriptorSet_T * [1]")
	local status = CLIB.vkAllocateDescriptorSets(device, pAllocateInfo, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pAllocateInfo
		return box[0], status
	end

	return nil, status
end
function library.CreatePipelineLayout(device, pCreateInfo, pAllocator)
	if type(pCreateInfo) == "table" then
		pCreateInfo = library.s.PipelineLayoutCreateInfo(pCreateInfo, false)
	end
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	local box = ffi.new("struct VkPipelineLayout_T * [1]")
	local status = CLIB.vkCreatePipelineLayout(device, pCreateInfo, pAllocator, box)

	if status == "VK_SUCCESS" then
		library.struct_gc[ box ] = pCreateInfo
		return box[0], status
	end

	return nil, status
end
function library.DeviceWaitIdle(device)
	return CLIB.vkDeviceWaitIdle(device)
end

function library.CmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions)
	if type(srcImageLayout) == "string" then
		srcImageLayout = library.e.image_layout[srcImageLayout]
	end
	if type(pRegions) == "table" then
		if not regionCount then
			regionCount = #pRegions
		end
		pRegions = library.s.BufferImageCopyArray(pRegions, false)
	end
	return CLIB.vkCmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions)
end

function library.CmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)
	if type(srcImageLayout) == "string" then
		srcImageLayout = library.e.image_layout[srcImageLayout]
	end
	if type(dstImageLayout) == "string" then
		dstImageLayout = library.e.image_layout[dstImageLayout]
	end
	if type(pRegions) == "table" then
		if not regionCount then
			regionCount = #pRegions
		end
		pRegions = library.s.ImageResolveArray(pRegions, false)
	end
	return CLIB.vkCmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)
end

function library.CmdSetStencilCompareMask(commandBuffer, faceMask, compareMask)
	if type(faceMask) == "table" then
		faceMask = library.e.stencil_face.make_enums(faceMask)
	elseif type(faceMask) == "string" then
		faceMask = library.e.stencil_face[faceMask]
	end
	return CLIB.vkCmdSetStencilCompareMask(commandBuffer, faceMask, compareMask)
end

function library.DestroyInstance(instance, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyInstance(instance, pAllocator)
end

function library.ResetEvent(device, event)
	return CLIB.vkResetEvent(device, event)
end

function library.QueueWaitIdle(queue)
	return CLIB.vkQueueWaitIdle(queue)
end

function library.CmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query)
	if type(pipelineStage) == "table" then
		pipelineStage = library.e.pipeline_stage.make_enums(pipelineStage)
	elseif type(pipelineStage) == "string" then
		pipelineStage = library.e.pipeline_stage[pipelineStage]
	end
	return CLIB.vkCmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query)
end

function library.DestroySurface(instance, surface, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return library.DestroySurfaceKHR(instance, surface, pAllocator)
end

function library.CmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags)
	if type(flags) == "table" then
		flags = library.e.query_result.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.query_result[flags]
	end
	return CLIB.vkCmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags)
end

function library.MergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches)
	if type(pSrcCaches) == "table" then
		if not srcCacheCount then
			srcCacheCount = #pSrcCaches
		end
		pSrcCaches = library.s.PipelineCacheArray(pSrcCaches, false)
	end
	return CLIB.vkMergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches)
end

function library.CmdSetStencilWriteMask(commandBuffer, faceMask, writeMask)
	if type(faceMask) == "table" then
		faceMask = library.e.stencil_face.make_enums(faceMask)
	elseif type(faceMask) == "string" then
		faceMask = library.e.stencil_face[faceMask]
	end
	return CLIB.vkCmdSetStencilWriteMask(commandBuffer, faceMask, writeMask)
end

function library.CmdResetEvent(commandBuffer, event, stageMask)
	if type(stageMask) == "table" then
		stageMask = library.e.pipeline_stage.make_enums(stageMask)
	elseif type(stageMask) == "string" then
		stageMask = library.e.pipeline_stage[stageMask]
	end
	return CLIB.vkCmdResetEvent(commandBuffer, event, stageMask)
end

function library.BindBufferMemory(device, buffer, memory, memoryOffset)
	return CLIB.vkBindBufferMemory(device, buffer, memory, memoryOffset)
end

function library.CmdSetEvent(commandBuffer, event, stageMask)
	if type(stageMask) == "table" then
		stageMask = library.e.pipeline_stage.make_enums(stageMask)
	elseif type(stageMask) == "string" then
		stageMask = library.e.pipeline_stage[stageMask]
	end
	return CLIB.vkCmdSetEvent(commandBuffer, event, stageMask)
end

function library.CmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets)
	if type(pipelineBindPoint) == "string" then
		pipelineBindPoint = library.e.pipeline_bind_point[pipelineBindPoint]
	end
	if type(pDescriptorSets) == "table" then
		if not descriptorSetCount then
			descriptorSetCount = #pDescriptorSets
		end
		pDescriptorSets = library.s.DescriptorSetArray(pDescriptorSets, false)
	end
	return CLIB.vkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets)
end

function library.CmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds)
	return CLIB.vkCmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds)
end

function library.CmdDispatchIndirect(commandBuffer, buffer, offset)
	return CLIB.vkCmdDispatchIndirect(commandBuffer, buffer, offset)
end

function library.DestroyEvent(device, event, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyEvent(device, event, pAllocator)
end

function library.CmdNextSubpass(commandBuffer, contents)
	if type(contents) == "string" then
		contents = library.e.subpass_contents[contents]
	end
	return CLIB.vkCmdNextSubpass(commandBuffer, contents)
end

function library.CmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions)
	if type(pRegions) == "table" then
		if not regionCount then
			regionCount = #pRegions
		end
		pRegions = library.s.BufferCopyArray(pRegions, false)
	end
	return CLIB.vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions)
end

function library.CmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
	return library.CmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
end

function library.DestroyBuffer(device, buffer, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyBuffer(device, buffer, pAllocator)
end

function library.CmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)
	if type(srcImageLayout) == "string" then
		srcImageLayout = library.e.image_layout[srcImageLayout]
	end
	if type(dstImageLayout) == "string" then
		dstImageLayout = library.e.image_layout[dstImageLayout]
	end
	if type(pRegions) == "table" then
		if not regionCount then
			regionCount = #pRegions
		end
		pRegions = library.s.ImageCopyArray(pRegions, false)
	end
	return CLIB.vkCmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)
end

function library.DestroyQueryPool(device, queryPool, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyQueryPool(device, queryPool, pAllocator)
end

function library.CmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData)
	return CLIB.vkCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData)
end

function library.CmdSetStencilReference(commandBuffer, faceMask, reference)
	if type(faceMask) == "table" then
		faceMask = library.e.stencil_face.make_enums(faceMask)
	elseif type(faceMask) == "string" then
		faceMask = library.e.stencil_face[faceMask]
	end
	return CLIB.vkCmdSetStencilReference(commandBuffer, faceMask, reference)
end

function library.FreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers)
	if type(pCommandBuffers) == "table" then
		if not commandBufferCount then
			commandBufferCount = #pCommandBuffers
		end
		pCommandBuffers = library.s.CommandBufferArray(pCommandBuffers, false)
	end
	return CLIB.vkFreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers)
end

function library.DestroyDebugReportCallback(instance, callback, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return library.DestroyDebugReportCallbackEXT(instance, callback, pAllocator)
end

function library.CmdBeginQuery(commandBuffer, queryPool, query, flags)
	if type(flags) == "table" then
		flags = library.e.query_control.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.query_control[flags]
	end
	return CLIB.vkCmdBeginQuery(commandBuffer, queryPool, query, flags)
end

function library.DestroyPipeline(device, pipeline, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyPipeline(device, pipeline, pAllocator)
end

function library.QueueSubmit(queue, submitCount, pSubmits, fence)
	if type(pSubmits) == "table" then
		if not submitCount then
			submitCount = #pSubmits
		end
		pSubmits = library.s.SubmitInfoArray(pSubmits, false)
	end
	return CLIB.vkQueueSubmit(queue, submitCount, pSubmits, fence)
end

function library.CmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter)
	if type(srcImageLayout) == "string" then
		srcImageLayout = library.e.image_layout[srcImageLayout]
	end
	if type(dstImageLayout) == "string" then
		dstImageLayout = library.e.image_layout[dstImageLayout]
	end
	if type(pRegions) == "table" then
		if not regionCount then
			regionCount = #pRegions
		end
		pRegions = library.s.ImageBlitArray(pRegions, false)
	end
	if type(filter) == "string" then
		filter = library.e.filter[filter]
	end
	return CLIB.vkCmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter)
end

function library.CmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride)
	return CLIB.vkCmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride)
end

function library.CmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor)
	return CLIB.vkCmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor)
end

function library.DestroyShaderModule(device, shaderModule, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyShaderModule(device, shaderModule, pAllocator)
end

function library.DestroyPipelineLayout(device, pipelineLayout, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyPipelineLayout(device, pipelineLayout, pAllocator)
end

function library.DestroySampler(device, sampler, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroySampler(device, sampler, pAllocator)
end

function library.FreeMemory(device, memory, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkFreeMemory(device, memory, pAllocator)
end

function library.DestroyFramebuffer(device, framebuffer, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyFramebuffer(device, framebuffer, pAllocator)
end

function library.CmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions)
	if type(dstImageLayout) == "string" then
		dstImageLayout = library.e.image_layout[dstImageLayout]
	end
	if type(pRegions) == "table" then
		if not regionCount then
			regionCount = #pRegions
		end
		pRegions = library.s.BufferImageCopyArray(pRegions, false)
	end
	return CLIB.vkCmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions)
end

function library.CmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets)
	if type(pBuffers) == "table" then
		if not bindingCount then
			bindingCount = #pBuffers
		end
		pBuffers = library.s.BufferArray(pBuffers, false)
	end
	return CLIB.vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets)
end

function library.DestroyCommandPool(device, commandPool, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyCommandPool(device, commandPool, pAllocator)
end

function library.InvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges)
	if type(pMemoryRanges) == "table" then
		if not memoryRangeCount then
			memoryRangeCount = #pMemoryRanges
		end
		pMemoryRanges = library.s.MappedMemoryRangeArray(pMemoryRanges, false)
	end
	return CLIB.vkInvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges)
end

function library.CmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline)
	if type(pipelineBindPoint) == "string" then
		pipelineBindPoint = library.e.pipeline_bind_point[pipelineBindPoint]
	end
	return CLIB.vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline)
end

function library.DestroyBufferView(device, bufferView, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyBufferView(device, bufferView, pAllocator)
end

function library.DestroyImageView(device, imageView, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyImageView(device, imageView, pAllocator)
end

function library.ResetCommandBuffer(commandBuffer, flags)
	if type(flags) == "table" then
		flags = library.e.command_buffer_reset.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.command_buffer_reset[flags]
	end
	return CLIB.vkResetCommandBuffer(commandBuffer, flags)
end

function library.CmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride)
	return CLIB.vkCmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride)
end

function library.DestroySwapchain(device, swapchain, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return library.DestroySwapchainKHR(device, swapchain, pAllocator)
end

function library.GetInstanceProcAddr(instance, pName)
	return CLIB.vkGetInstanceProcAddr(instance, pName)
end

function library.DebugReportMessage(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage)
	if type(flags) == "table" then
		flags = library.e.debug_report.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.debug_report[flags]
	end
	if type(objectType) == "string" then
		objectType = library.e.debug_report_object_type[objectType]
	end
	return library.DebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage)
end

function library.SetEvent(device, event)
	return CLIB.vkSetEvent(device, event)
end

function library.CmdDebugMarkerEnd(commandBuffer)
	return library.CmdDebugMarkerEndEXT(commandBuffer)
end

function library.CmdDebugMarkerBegin(commandBuffer, pMarkerInfo)
	if type(pMarkerInfo) == "table" then
		pMarkerInfo = library.s.DebugMarkerMarkerInfoEXT(pMarkerInfo, false)
	end
	return library.CmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo)
end

function library.CmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges)
	if type(imageLayout) == "string" then
		imageLayout = library.e.image_layout[imageLayout]
	end
	if type(pDepthStencil) == "table" then
		pDepthStencil = library.s.ClearDepthStencilValue(pDepthStencil, false)
	end
	if type(pRanges) == "table" then
		if not rangeCount then
			rangeCount = #pRanges
		end
		pRanges = library.s.ImageSubresourceRangeArray(pRanges, false)
	end
	return CLIB.vkCmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges)
end

function library.CmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount)
	return CLIB.vkCmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount)
end

function library.BeginCommandBuffer(commandBuffer, pBeginInfo)
	if type(pBeginInfo) == "table" then
		pBeginInfo = library.s.CommandBufferBeginInfo(pBeginInfo, false)
	end
	return CLIB.vkBeginCommandBuffer(commandBuffer, pBeginInfo)
end

function library.DebugMarkerSetObjectTag(device, pTagInfo)
	if type(pTagInfo) == "table" then
		pTagInfo = library.s.DebugMarkerObjectTagInfoEXT(pTagInfo, false)
	end
	return library.DebugMarkerSetObjectTagEXT(device, pTagInfo)
end

function library.CmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance)
	return CLIB.vkCmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance)
end

function library.CmdDebugMarkerInsert(commandBuffer, pMarkerInfo)
	if type(pMarkerInfo) == "table" then
		pMarkerInfo = library.s.DebugMarkerMarkerInfoEXT(pMarkerInfo, false)
	end
	return library.CmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo)
end

function library.CmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data)
	return CLIB.vkCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data)
end

function library.CmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)
	if type(pEvents) == "table" then
		if not eventCount then
			eventCount = #pEvents
		end
		pEvents = library.s.EventArray(pEvents, false)
	end
	if type(srcStageMask) == "table" then
		srcStageMask = library.e.pipeline_stage.make_enums(srcStageMask)
	elseif type(srcStageMask) == "string" then
		srcStageMask = library.e.pipeline_stage[srcStageMask]
	end
	if type(dstStageMask) == "table" then
		dstStageMask = library.e.pipeline_stage.make_enums(dstStageMask)
	elseif type(dstStageMask) == "string" then
		dstStageMask = library.e.pipeline_stage[dstStageMask]
	end
	if type(pMemoryBarriers) == "table" then
		if not memoryBarrierCount then
			memoryBarrierCount = #pMemoryBarriers
		end
		pMemoryBarriers = library.s.MemoryBarrierArray(pMemoryBarriers, false)
	end
	if type(pBufferMemoryBarriers) == "table" then
		if not bufferMemoryBarrierCount then
			bufferMemoryBarrierCount = #pBufferMemoryBarriers
		end
		pBufferMemoryBarriers = library.s.BufferMemoryBarrierArray(pBufferMemoryBarriers, false)
	end
	if type(pImageMemoryBarriers) == "table" then
		if not imageMemoryBarrierCount then
			imageMemoryBarrierCount = #pImageMemoryBarriers
		end
		pImageMemoryBarriers = library.s.ImageMemoryBarrierArray(pImageMemoryBarriers, false)
	end
	return CLIB.vkCmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)
end

function library.CmdEndRenderPass(commandBuffer)
	return CLIB.vkCmdEndRenderPass(commandBuffer)
end

function library.CmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
	return library.CmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)
end

function library.QueuePresent(queue, pPresentInfo)
	if type(pPresentInfo) == "table" then
		pPresentInfo = library.s.PresentInfoKHR(pPresentInfo, false)
	end
	return library.QueuePresentKHR(queue, pPresentInfo)
end

function library.DestroyFence(device, fence, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyFence(device, fence, pAllocator)
end

function library.CmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges)
	if type(imageLayout) == "string" then
		imageLayout = library.e.image_layout[imageLayout]
	end
	if type(pColor) == "table" then
		pColor = library.s.ClearColorValue(pColor, false)
	end
	if type(pRanges) == "table" then
		if not rangeCount then
			rangeCount = #pRanges
		end
		pRanges = library.s.ImageSubresourceRangeArray(pRanges, false)
	end
	return CLIB.vkCmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges)
end

function library.CmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers)
	if type(pCommandBuffers) == "table" then
		if not commandBufferCount then
			commandBufferCount = #pCommandBuffers
		end
		pCommandBuffers = library.s.CommandBufferArray(pCommandBuffers, false)
	end
	return CLIB.vkCmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers)
end

function library.CmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents)
	if type(pRenderPassBegin) == "table" then
		pRenderPassBegin = library.s.RenderPassBeginInfo(pRenderPassBegin, false)
	end
	if type(contents) == "string" then
		contents = library.e.subpass_contents[contents]
	end
	return CLIB.vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents)
end

function library.CmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects)
	if type(pAttachments) == "table" then
		if not attachmentCount then
			attachmentCount = #pAttachments
		end
		pAttachments = library.s.ClearAttachmentArray(pAttachments, false)
	end
	if type(pRects) == "table" then
		if not rectCount then
			rectCount = #pRects
		end
		pRects = library.s.ClearRectArray(pRects, false)
	end
	return CLIB.vkCmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects)
end

function library.CmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues)
	if type(stageFlags) == "table" then
		stageFlags = library.e.shader_stage.make_enums(stageFlags)
	elseif type(stageFlags) == "string" then
		stageFlags = library.e.shader_stage[stageFlags]
	end
	return CLIB.vkCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues)
end

function library.DebugMarkerSetObjectName(device, pNameInfo)
	if type(pNameInfo) == "table" then
		pNameInfo = library.s.DebugMarkerObjectNameInfoEXT(pNameInfo, false)
	end
	return library.DebugMarkerSetObjectNameEXT(device, pNameInfo)
end

function library.CmdEndQuery(commandBuffer, queryPool, query)
	return CLIB.vkCmdEndQuery(commandBuffer, queryPool, query)
end

function library.CmdBindIndexBuffer(commandBuffer, buffer, offset, indexType)
	if type(indexType) == "string" then
		indexType = library.e.index_type[indexType]
	end
	return CLIB.vkCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType)
end

function library.EndCommandBuffer(commandBuffer)
	return CLIB.vkEndCommandBuffer(commandBuffer)
end

function library.DestroyImage(device, image, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyImage(device, image, pAllocator)
end

function library.DestroySemaphore(device, semaphore, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroySemaphore(device, semaphore, pAllocator)
end

function library.CmdSetBlendConstants(commandBuffer, unknown_2)
	return CLIB.vkCmdSetBlendConstants(commandBuffer, unknown_2)
end

function library.DestroyPipelineCache(device, pipelineCache, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyPipelineCache(device, pipelineCache, pAllocator)
end

function library.GetDeviceProcAddr(device, pName)
	return CLIB.vkGetDeviceProcAddr(device, pName)
end

function library.BindImageMemory(device, image, memory, memoryOffset)
	return CLIB.vkBindImageMemory(device, image, memory, memoryOffset)
end

function library.DestroyRenderPass(device, renderPass, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyRenderPass(device, renderPass, pAllocator)
end

function library.UnmapMemory(device, memory)
	return CLIB.vkUnmapMemory(device, memory)
end

function library.DestroyDescriptorPool(device, descriptorPool, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyDescriptorPool(device, descriptorPool, pAllocator)
end

function library.CmdDispatch(commandBuffer, x, y, z)
	return CLIB.vkCmdDispatch(commandBuffer, x, y, z)
end

function library.ResetDescriptorPool(device, descriptorPool, flags)
	return CLIB.vkResetDescriptorPool(device, descriptorPool, flags)
end

function library.WaitForFences(device, fenceCount, pFences, waitAll, timeout)
	if type(pFences) == "table" then
		if not fenceCount then
			fenceCount = #pFences
		end
		pFences = library.s.FenceArray(pFences, false)
	end
	tbl.waitAll = waitAll and 1 or 0
	return CLIB.vkWaitForFences(device, fenceCount, pFences, waitAll, timeout)
end

function library.CmdSetLineWidth(commandBuffer, lineWidth)
	return CLIB.vkCmdSetLineWidth(commandBuffer, lineWidth)
end

function library.ResetFences(device, fenceCount, pFences)
	if type(pFences) == "table" then
		if not fenceCount then
			fenceCount = #pFences
		end
		pFences = library.s.FenceArray(pFences, false)
	end
	return CLIB.vkResetFences(device, fenceCount, pFences)
end

function library.DestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator)
end

function library.FlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges)
	if type(pMemoryRanges) == "table" then
		if not memoryRangeCount then
			memoryRangeCount = #pMemoryRanges
		end
		pMemoryRanges = library.s.MappedMemoryRangeArray(pMemoryRanges, false)
	end
	return CLIB.vkFlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges)
end

function library.DestroyDevice(device, pAllocator)
	if type(pAllocator) == "table" then
		pAllocator = library.s.AllocationCallbacks(pAllocator, false)
	end
	return CLIB.vkDestroyDevice(device, pAllocator)
end

function library.FreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets)
	if type(pDescriptorSets) == "table" then
		if not descriptorSetCount then
			descriptorSetCount = #pDescriptorSets
		end
		pDescriptorSets = library.s.DescriptorSetArray(pDescriptorSets, false)
	end
	return CLIB.vkFreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets)
end

function library.CmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance)
	return CLIB.vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance)
end

function library.CmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors)
	if type(pScissors) == "table" then
		if not scissorCount then
			scissorCount = #pScissors
		end
		pScissors = library.s.Rect2DArray(pScissors, false)
	end
	return CLIB.vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors)
end

function library.QueueBindSparse(queue, bindInfoCount, pBindInfo, fence)
	if type(pBindInfo) == "table" then
		if not bindInfoCount then
			bindInfoCount = #pBindInfo
		end
		pBindInfo = library.s.BindSparseInfoArray(pBindInfo, false)
	end
	return CLIB.vkQueueBindSparse(queue, bindInfoCount, pBindInfo, fence)
end

function library.UpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies)
	if type(pDescriptorWrites) == "table" then
		if not descriptorWriteCount then
			descriptorWriteCount = #pDescriptorWrites
		end
		pDescriptorWrites = library.s.WriteDescriptorSetArray(pDescriptorWrites, false)
	end
	if type(pDescriptorCopies) == "table" then
		if not descriptorCopyCount then
			descriptorCopyCount = #pDescriptorCopies
		end
		pDescriptorCopies = library.s.CopyDescriptorSetArray(pDescriptorCopies, false)
	end
	return CLIB.vkUpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies)
end

function library.GetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags)
	if type(flags) == "table" then
		flags = library.e.query_result.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.query_result[flags]
	end
	return CLIB.vkGetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags)
end

function library.CmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)
	if type(srcStageMask) == "table" then
		srcStageMask = library.e.pipeline_stage.make_enums(srcStageMask)
	elseif type(srcStageMask) == "string" then
		srcStageMask = library.e.pipeline_stage[srcStageMask]
	end
	if type(dstStageMask) == "table" then
		dstStageMask = library.e.pipeline_stage.make_enums(dstStageMask)
	elseif type(dstStageMask) == "string" then
		dstStageMask = library.e.pipeline_stage[dstStageMask]
	end
	if type(dependencyFlags) == "table" then
		dependencyFlags = library.e.dependency.make_enums(dependencyFlags)
	elseif type(dependencyFlags) == "string" then
		dependencyFlags = library.e.dependency[dependencyFlags]
	end
	if type(pMemoryBarriers) == "table" then
		if not memoryBarrierCount then
			memoryBarrierCount = #pMemoryBarriers
		end
		pMemoryBarriers = library.s.MemoryBarrierArray(pMemoryBarriers, false)
	end
	if type(pBufferMemoryBarriers) == "table" then
		if not bufferMemoryBarrierCount then
			bufferMemoryBarrierCount = #pBufferMemoryBarriers
		end
		pBufferMemoryBarriers = library.s.BufferMemoryBarrierArray(pBufferMemoryBarriers, false)
	end
	if type(pImageMemoryBarriers) == "table" then
		if not imageMemoryBarrierCount then
			imageMemoryBarrierCount = #pImageMemoryBarriers
		end
		pImageMemoryBarriers = library.s.ImageMemoryBarrierArray(pImageMemoryBarriers, false)
	end
	return CLIB.vkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)
end

function library.ResetCommandPool(device, commandPool, flags)
	if type(flags) == "table" then
		flags = library.e.command_pool_reset.make_enums(flags)
	elseif type(flags) == "string" then
		flags = library.e.command_pool_reset[flags]
	end
	return CLIB.vkResetCommandPool(device, commandPool, flags)
end

function library.CmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports)
	if type(pViewports) == "table" then
		if not viewportCount then
			viewportCount = #pViewports
		end
		pViewports = library.s.ViewportArray(pViewports, false)
	end
	return CLIB.vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports)
end

do
	local META = {
		DestroySurface = library.DestroySurface,
		CreateDisplayPlaneSurface = library.CreateDisplayPlaneSurface,
		Destroy = library.DestroyInstance,
		DebugReportMessage = library.DebugReportMessage,
		LoadProcAddr = library.util.LoadInstanceProcAddr,
		DestroyDebugReportCallback = library.DestroyDebugReportCallback,
		GetProcAddr = library.GetInstanceProcAddr,
		CreateDebugReportCallback = library.CreateDebugReportCallback,
		GetPhysicalDevices = library.GetPhysicalDevices,
	}
	META.__index = META
	ffi.metatype("struct VkInstance_T", META)
end
do
	local META = {
		BindIndexBuffer = library.CmdBindIndexBuffer,
		CopyBufferToImage = library.CmdCopyBufferToImage,
		DrawIndirectCount = library.CmdDrawIndirectCount,
		DrawIndexedIndirect = library.CmdDrawIndexedIndirect,
		SetBlendConstants = library.CmdSetBlendConstants,
		CopyBuffer = library.CmdCopyBuffer,
		BindVertexBuffers = library.CmdBindVertexBuffers,
		SetDepthBounds = library.CmdSetDepthBounds,
		PushConstants = library.CmdPushConstants,
		DispatchIndirect = library.CmdDispatchIndirect,
		ClearColorImage = library.CmdClearColorImage,
		DebugMarkerInsert = library.CmdDebugMarkerInsert,
		ResolveImage = library.CmdResolveImage,
		WriteTimestamp = library.CmdWriteTimestamp,
		SetStencilReference = library.CmdSetStencilReference,
		ResetQueryPool = library.CmdResetQueryPool,
		DrawIndirect = library.CmdDrawIndirect,
		SetViewport = library.CmdSetViewport,
		End = library.EndCommandBuffer,
		ClearAttachments = library.CmdClearAttachments,
		SetDepthBias = library.CmdSetDepthBias,
		SetScissor = library.CmdSetScissor,
		WaitEvents = library.CmdWaitEvents,
		DrawIndexedIndirectCount = library.CmdDrawIndexedIndirectCount,
		FillBuffer = library.CmdFillBuffer,
		Reset = library.ResetCommandBuffer,
		Dispatch = library.CmdDispatch,
		CopyQueryPoolResults = library.CmdCopyQueryPoolResults,
		SetEvent = library.CmdSetEvent,
		BindDescriptorSets = library.CmdBindDescriptorSets,
		EndQuery = library.CmdEndQuery,
		BlitImage = library.CmdBlitImage,
		BindPipeline = library.CmdBindPipeline,
		SetStencilWriteMask = library.CmdSetStencilWriteMask,
		SetLineWidth = library.CmdSetLineWidth,
		ResetEvent = library.CmdResetEvent,
		Draw = library.CmdDraw,
		UpdateBuffer = library.CmdUpdateBuffer,
		ClearDepthStencilImage = library.CmdClearDepthStencilImage,
		EndRenderPass = library.CmdEndRenderPass,
		BeginRenderPass = library.CmdBeginRenderPass,
		DrawIndexed = library.CmdDrawIndexed,
		SetStencilCompareMask = library.CmdSetStencilCompareMask,
		ExecuteCommands = library.CmdExecuteCommands,
		CopyImageToBuffer = library.CmdCopyImageToBuffer,
		DebugMarkerEnd = library.CmdDebugMarkerEnd,
		CopyImage = library.CmdCopyImage,
		NextSubpass = library.CmdNextSubpass,
		DebugMarkerBegin = library.CmdDebugMarkerBegin,
		BeginQuery = library.CmdBeginQuery,
		PipelineBarrier = library.CmdPipelineBarrier,
		Begin = library.BeginCommandBuffer,
	}
	META.__index = META
	ffi.metatype("struct VkCommandBuffer_T", META)
end
do
	local META = {
		CreateBufferView = library.CreateBufferView,
		DestroySemaphore = library.DestroySemaphore,
		CreateFramebuffer = library.CreateFramebuffer,
		DestroyPipelineLayout = library.DestroyPipelineLayout,
		GetEventStatus = library.GetEventStatus,
		DebugMarkerSetObjectName = library.DebugMarkerSetObjectName,
		DestroySwapchain = library.DestroySwapchain,
		GetFenceStatus = library.GetFenceStatus,
		CreateComputePipelines = library.CreateComputePipelines,
		GetPipelineCacheData = library.GetPipelineCacheData,
		GetQueryPoolResults = library.GetQueryPoolResults,
		DestroyBufferView = library.DestroyBufferView,
		WaitIdle = library.DeviceWaitIdle,
		CreateDescriptorSetLayout = library.CreateDescriptorSetLayout,
		DestroyCommandPool = library.DestroyCommandPool,
		CreateFence = library.CreateFence,
		DestroyFence = library.DestroyFence,
		WaitForFences = library.WaitForFences,
		CreateSwapchain = library.CreateSwapchain,
		CreateImage = library.CreateImage,
		GetBufferMemoryRequirements = library.GetBufferMemoryRequirements,
		CreatePipelineLayout = library.CreatePipelineLayout,
		BindImageMemory = library.BindImageMemory,
		UnmapMemory = library.UnmapMemory,
		Destroy = library.DestroyDevice,
		DestroyQueryPool = library.DestroyQueryPool,
		CreateSampler = library.CreateSampler,
		FreeDescriptorSets = library.FreeDescriptorSets,
		CreateQueryPool = library.CreateQueryPool,
		DestroySampler = library.DestroySampler,
		CreateCommandPool = library.CreateCommandPool,
		ResetCommandPool = library.ResetCommandPool,
		GetImageMemoryRequirements = library.GetImageMemoryRequirements,
		ResetDescriptorPool = library.ResetDescriptorPool,
		GetProcAddr = library.GetDeviceProcAddr,
		CreateImageView = library.CreateImageView,
		CreateDescriptorPool = library.CreateDescriptorPool,
		DestroyFramebuffer = library.DestroyFramebuffer,
		DestroyDescriptorSetLayout = library.DestroyDescriptorSetLayout,
		AllocateMemory = library.AllocateMemory,
		FreeCommandBuffers = library.FreeCommandBuffers,
		ResetEvent = library.ResetEvent,
		GetImageSparseMemoryRequirements = library.GetImageSparseMemoryRequirements,
		DebugMarkerSetObjectTag = library.DebugMarkerSetObjectTag,
		LoadProcAddr = library.util.LoadDeviceProcAddr,
		DestroyBuffer = library.DestroyBuffer,
		FreeMemory = library.FreeMemory,
		DestroyShaderModule = library.DestroyShaderModule,
		FlushMappedMemoryRanges = library.FlushMappedMemoryRanges,
		UpdateDescriptorSets = library.UpdateDescriptorSets,
		CreateBuffer = library.CreateBuffer,
		GetSwapchainImages = library.GetSwapchainImages,
		DestroyPipelineCache = library.DestroyPipelineCache,
		AcquireNextImage = library.AcquireNextImage,
		GetMemoryCommitment = library.GetDeviceMemoryCommitment,
		SetEvent = library.SetEvent,
		DestroyPipeline = library.DestroyPipeline,
		GetQueue = library.GetDeviceQueue,
		DestroyEvent = library.DestroyEvent,
		BindBufferMemory = library.BindBufferMemory,
		MergePipelineCaches = library.MergePipelineCaches,
		DestroyImageView = library.DestroyImageView,
		CreateRenderPass = library.CreateRenderPass,
		CreateEvent = library.CreateEvent,
		GetRenderAreaGranularity = library.GetRenderAreaGranularity,
		DestroyDescriptorPool = library.DestroyDescriptorPool,
		InvalidateMappedMemoryRanges = library.InvalidateMappedMemoryRanges,
		CreateSemaphore = library.CreateSemaphore,
		DestroyImage = library.DestroyImage,
		GetImageSubresourceLayout = library.GetImageSubresourceLayout,
		CreateGraphicsPipelines = library.CreateGraphicsPipelines,
		CreatePipelineCache = library.CreatePipelineCache,
		AllocateDescriptorSets = library.AllocateDescriptorSets,
		MapMemory = library.MapMemory,
		DestroyRenderPass = library.DestroyRenderPass,
		AllocateCommandBuffers = library.AllocateCommandBuffers,
		CreateSharedSwapchains = library.CreateSharedSwapchains,
		CreateShaderModule = library.CreateShaderModule,
		ResetFences = library.ResetFences,
	}
	META.__index = META
	ffi.metatype("struct VkDevice_T", META)
end
do
	local META = {
		Present = library.QueuePresent,
		WaitIdle = library.QueueWaitIdle,
		BindSparse = library.QueueBindSparse,
		Submit = library.QueueSubmit,
	}
	META.__index = META
	ffi.metatype("struct VkQueue_T", META)
end
do
	local META = {
		GetDisplayPlaneProperties = library.GetPhysicalDeviceDisplayPlaneProperties,
		GetQueueFamilyProperties = library.GetPhysicalDeviceQueueFamilyProperties,
		GetSurfaceCapabilities = library.GetPhysicalDeviceSurfaceCapabilities,
		GetSurfacePresentModes = library.GetPhysicalDeviceSurfacePresentModes,
		GetDeviceExtensionProperties = library.GetDeviceExtensionProperties,
		GetDisplayPlaneSupportedDisplays = library.GetDisplayPlaneSupportedDisplays,
		GetMemoryProperties = library.GetPhysicalDeviceMemoryProperties,
		GetDisplayProperties = library.GetPhysicalDeviceDisplayProperties,
		CreateDevice = library.CreateDevice,
		GetDisplayPlaneCapabilities = library.GetDisplayPlaneCapabilities,
		GetDeviceLayerProperties = library.GetDeviceLayerProperties,
		CreateDisplayMode = library.CreateDisplayMode,
		GetSurfaceFormats = library.GetPhysicalDeviceSurfaceFormats,
		GetSparseImageFormatProperties = library.GetPhysicalDeviceSparseImageFormatProperties,
		GetFormatProperties = library.GetPhysicalDeviceFormatProperties,
		GetFeatures = library.GetPhysicalDeviceFeatures,
		GetImageFormatProperties = library.GetPhysicalDeviceImageFormatProperties,
		GetProperties = library.GetPhysicalDeviceProperties,
		GetSurfaceSupport = library.GetPhysicalDeviceSurfaceSupport,
		GetExternalImageFormatPropertie = library.GetPhysicalDeviceExternalImageFormatPropertie,
		GetDisplayModeProperties = library.GetDisplayModeProperties,
	}
	META.__index = META
	ffi.metatype("struct VkPhysicalDevice_T", META)
end
library.clib = CLIB
return library
